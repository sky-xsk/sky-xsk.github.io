<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue项目国际化，中英繁，三种语言切换]]></title>
    <url>%2F2018%2F08%2F31%2Fvue%E9%A1%B9%E7%9B%AE%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%8C%E4%B8%AD%E8%8B%B1%E7%B9%81%EF%BC%8C%E4%B8%89%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[我们的软件，为了满足不同地区的需求，我们的前端部分需要做，多语言的支持，这里做一个简单的分享！ 1.首先，安装；1npm install vue-i18n 2.在与main.js同级目录下，新建文件夹，如图吧：3.看一下main.js,注意文件的目录结构，层级；4.看i18n.js；5.看index.js6.cn.js7.en.js8.tw.js9.下面是在组件里切换语言；截图，不上代码的原因，希望可以自己动手写一遍，不要复制粘贴！其实吧! 截图也挺累！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node+vue 项目，不断更新中。。。]]></title>
    <url>%2F2018%2F08%2F31%2Fnode-vue-%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%E3%80%82%E3%80%82%E3%80%82%2F</url>
    <content type="text"><![CDATA[请移步，github！https://github.com/sky-xsk/node-vue-记得给个“start”，谢谢！ 请移步，github！https://github.com/sky-xsk/node-vue-记得给个“start”，谢谢！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+iview+mqtt（mqttws31.js） 简单实例]]></title>
    <url>%2F2018%2F05%2F15%2Fvue-iview-mqtt%EF%BC%88mqttws31-js%EF%BC%89-%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[怎么新建一个项目工程，这里就不说了！主要说mqtt，怎么使用mqttws31.js，发送一个消息，怎么接收显示的问题！代码会放到我的GitHub上，往后看！ ###index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;消息队列&lt;/title&gt; &lt;meta http-equiv=&quot;Access-Control-Allow-Origin&quot; content=&quot;*&quot; /&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/main.css&quot;&gt; &lt;script src=&quot;./tools/mqttws31.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; //引入js &lt;script src=&quot;./tools/config.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; //引入主题配置文件&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/dist/vendors.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/dist/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ###config.js 12345678 host = &apos;222.73.204.54&apos;; // hostname or IP address ,自己配的消息队列服务，这里用的在线的服务，测试工具的话也会放到github；地址在最下方！ port = 9001; //端口 addtopic = &apos;add&apos;; //约定的主题//下面暂时不用在意，下次会讲 useTLS = false; username = null; password = null; cleansession = false; 上面东西配好后，下面就是重点了: 具体代码解释，会写到注释里！ ###app.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; reconnectTimeout: 2000, mqtt: &#123;&#125;, msg:&quot;&quot;, &#125; &#125;, mounted() &#123; this.MQTTconnect(); &#125;, methods: &#123; //实时货柜变化 addtopic(msg) &#123; this.msg = msg; &#125;, //实时通信 MQTTconnect() &#123; this.mqtt = new Paho.MQTT.Client( //实例化一个对象 host, port, &quot;client&quot; + this.getuuid(), //防止多个浏览器打开，导致的问题，保证唯一性 ); var options = &#123; timeout: 10, useSSL: useTLS, cleanSession: cleansession, //如果为false(flag=0)，Client断开连接后，Server应该保存Client的订阅信息。如果为true(flag=1)，表示Server应该立刻丢弃任何会话状态信息。 onSuccess: this.onConnect, onFailure: function(message) &#123; //连接失败定时重连 setTimeout(this.MQTTconnect, this.reconnectTimeout); &#125; &#125;; this.mqtt.onConnectionLost = this.onConnectionLost; this.mqtt.onMessageArrived = this.onMessageArrived; //用户名和密码的验证，我这里都为空；不加验证 if (username != null) &#123; options.userName = username; options.password = password; &#125; this.mqtt.connect(options); &#125;, //uuid随机生成 getuuid() &#123; var uid = []; var hexDigits = &quot;0123456789abcdefghijklmnopqrst&quot;; for (var i = 0; i &lt; 32; i++) &#123; uid[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1); &#125; uid[6] = &quot;4&quot;; uid[15] = hexDigits.substr((uid[15] &amp; 0x3) | 0x8, 1); var uuid = uid.join(&quot;&quot;); return uuid; &#125;, //连接 onConnect() &#123; //连接成功，订阅主题 this.mqtt.subscribe(addtopic, &#123; qos: 2 //QoS0，最多一次送达。也就是发出去就fire掉，没有后面的事情了。 // QoS1，至少一次送达。发出去之后必须等待ack，没有ack，就要找时机重发 // QoS2，准确一次送达。消息id将拥有一个简单的生命周期。 &#125;); //发布一个消息，再连接成功后，发送一个响应，确保连接没有问题； this.mqtt.send(&quot;login&quot;, &quot;&#123;\&quot;command\&quot;:\&quot;login\&quot;,\&quot;clientId\&quot;:\&quot;&quot; + this.mqtt.clientId + &quot;\&quot;&#125;&quot;, 0); &#125;, //连接丢失 onConnectionLost(response) &#123; //console.log(&quot;异常掉线，掉线信息为:&quot; + response.errorMessage); &#125;, //接收到消息，处理 onMessageArrived(message) &#123; var topics = message.destinationName; var msg = $.parseJSON(message.payloadString); //判断主题，调用方法，这里可以订阅多个主题，在此处判断，接受不同的主题，调用不同的方法！ if (topics == &quot;add&quot;) &#123; //添加 this.addtopic(msg); &#125;else &#123; return; &#125; &#125;, &#125;, &#125;&lt;/script&gt;&lt;style&gt; .apps &#123; width: 100%; overflow: hidden; &#125;&lt;/style&gt; ###消息验证提供一个这样的在线的测试工具；介绍一下：1.server： 消息队列服务所在的地址，保证和config.js里面的地址一样；2.port：端口保证和config.js里面的地址一样；3.订阅：是订阅主题的地方，要和config.js约定的主题相同，才可！4.发布，填写topic，我们是“add”，payload,内容，如上图！随便写！点击发布，在你的页面，就能看到你发送的信息了！ ###ok，结束了！拿去用到项目里吧！1github地址：https://github.com/sky-xsk/vue-iview-mqtt-mqttws31.js- 给个星星star，说明你看过！谢谢！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结几种常见的垂直居中布局]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%80%BB%E7%BB%93%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[废话不多说，直接看代码！ ###1.margin: auto;实现绝对定位元素的水平垂直居中，IE7及以下低版本浏览器不兼容 1&lt;div class=&apos;maps1&apos;&gt;&lt;/div&gt; 123456789101112131415161718* &#123; margin: 0; padding: 0; border: 0; list-style: none;&#125;.maps1&#123; width: 200px; height: 200px; background-color: #000; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; ###2. margin的负间距实现绝对定位元素的水平垂直居中,兼容性比较好，比较常用1&lt;div class=&apos;maps2&apos;&gt;&lt;/div&gt; 12345678910111213141516* &#123; margin: 0; padding: 0; border: 0; list-style: none;&#125;.maps2&#123; position: absolute; left: 50%; top: 50%; width: 200px; height: 200px; background-color: green; border: 10px solid #000; margin: -110px 0 0 -110px;&#125; ###3.通过transform偏移实现绝对定位元素的水平垂直居中， IE8及以下低版本浏览器不兼容12345678910111213141516171819* &#123; margin: 0; padding: 0; border: 0; list-style: none;&#125;.maps3&#123; position: absolute; left: 50%; top: 50%; width: 200px; height: 200px; background-color: gray; -webkit-transform: translate(-50%, -50%); -moz-transform: translate(-50%, -50%); -o-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125; ###4.CSS3弹性盒模型布局不定宽高实现水平垂直居中 ，CSS3弹性盒模型布局本身就不支持低版本IE6-9浏览器的兼容123&lt;div class=&quot;maps4&quot;&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637body,html &#123; height: 100%;&#125;* &#123; margin: 0; padding: 0; border: 0; list-style: none;&#125;.maps4&#123; /** height:100%就是让页面撑满整个可视区 */ height: 100%; /** 流行版弹性盒模型布局 */ display: flex; display: -webkit-flex; /** 老安卓版弹性盒模型布局 */ /** display: box; display: -webkit-box; /** 老安卓版的横向居中 */ /**box-pack: center; -webkit-box-pack: center; /** 老安卓版的垂直居中 */ /**box-align: center; -webkit-box-align: center; /** 流行版的横向居中 */ justify-content: center; -webkit-justify-content: center; /** 流行版的垂直居中 */ align-items: center; -webkit-align-items: center;&#125;.maps4 div &#123; width: 100px; height: 100px; background-color: black;&#125; 看代码应该是比较清晰的了，当自己的笔记，不喜勿喷！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue2.0 keep-alive]]></title>
    <url>%2F2018%2F04%2F27%2Fvue2-0-keep-alive%2F</url>
    <content type="text"><![CDATA[参考 ###1.用法vue2.0提供了一个keep-alive组件用来缓存组件,避免多次加载相应的组件,减少性能消耗12345&lt;keep-alive&gt; &lt;component&gt; &lt;!-- 组件将被缓存 --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 有时候 可能需要缓存整个站点的所有页面,而页面一般一进去都要触发请求的在使用keep-alive的情况下123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 将首次触发请求写在created钩子函数中,就能实现缓存,比如列表页,去了详情页 回来,还是在原来的页面 ###2.缓存部分页面或者组件 ####(1)使用router. meta属性12345// 这是目前用的比较多的方式&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; router设置12345678910routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/index&apos;, component: Index, meta: &#123; keepAlive: true &#125;&#125;, &#123; path: &apos;/common&apos;, component: TestParent, children: [ &#123; path: &apos;/test2&apos;, component: Test2, meta: &#123; keepAlive: true &#125; &#125; ] &#125; // 表示index和test2都使用keep-alive ####(2).使用新增属性inlcude/exclude2.1.0后提供了include/exclude两个属性 可以针对性缓存相应的组件12345678910&lt;!-- comma-delimited string --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- regex (use v-bind) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;//其中a,b是组件的name 注意:这种方法都是预先知道组件的名称的(2)动态判断123&lt;keep-alive :include=&quot;includedComponents&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; includedComponents动态设置即可 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决vue打包时出现的错误（自己写的js，打包时出错）]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%A7%A3%E5%86%B3vue%E6%89%93%E5%8C%85%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%88%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84js%EF%BC%8C%E6%89%93%E5%8C%85%E6%97%B6%E5%87%BA%E9%94%99%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天，打包项目是遇到这样的报错：12ERROR in static/js/app.3229f4e0a68089746e5c.js from UglifyJsUnexpected token: punc (() [./static/js/tool.js:14,0][static/js/app.3229f4e0a68089746e5c.js:72,11] 这里说一下，static是自己新建的文件夹放置自己写js文件，tool.js就是自己写的，在vue文件里或者其他js文件里引用；解决方法：修改build文件夹下的1webpack.base.conf.js 找到module对象：修改如下代码修改前：12345&#123; test: /\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)] &#125;, 修改后： 12345&#123;test: /\.js$/,loader: &apos;babel-loader&apos;,include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;static/js/tool.js&apos;)]&#125;, 再次打包，问题完美解决！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解js的运行机制]]></title>
    <url>%2F2017%2F12%2F08%2F%E7%90%86%E8%A7%A3js%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[最近比较忙，硬是没抽出时间总结一点小知识。最近在网上看到一篇不错的文章，转一下！本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。 不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论： javascript是按照语句出现的顺序执行的看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的：12345let a = &apos;1&apos;;console.log(a);let b = &apos;2&apos;;console.log(b); 然而实际上js是这样的：1234567891011121314setTimeout(function()&#123; console.log(&apos;定时器开始啦&apos;)&#125;);new Promise(function(resolve)&#123; console.log(&apos;马上执行for循环啦&apos;); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125;&#125;).then(function()&#123; console.log(&apos;执行then函数啦&apos;)&#125;);console.log(&apos;代码执行结束&apos;); 依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果：1234//&quot;定时器开始啦&quot;//&quot;马上执行for循环啦&quot;//&quot;执行then函数啦&quot;//&quot;代码执行结束&quot; 去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？我们真的要彻底弄明白javascript的执行机制了。 ###1.关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ ###2.javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务异步任务当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。说了这么多文字，不如直接一段代码更直白：123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log(&apos;发送成功!&apos;); &#125;&#125;)console.log(&apos;代码执行结束&apos;); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。执行console.log(‘代码执行结束’)。ajax事件完成，回调函数success进入Event Queue。主线程从Event Queue读取回调函数success并执行。相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 ###3.又爱又恨的setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：123setTimeout(() =&gt; &#123; console.log(&apos;延时3秒&apos;);&#125;,3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？ 先看一个例子：1234setTimeout(() =&gt; &#123; task();&#125;,3000)console.log(&apos;执行console&apos;); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：12//执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码：12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。执行sleep函数，很慢，非常慢，计时仍在继续。3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。sleep终于执行完了，task()终于从Event Queue进入了主线程执行。上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：12345//代码1console.log(&apos;先执行这里&apos;);setTimeout(() =&gt; &#123; console.log(&apos;执行啦&apos;)&#125;,0); 12345//代码2console.log(&apos;先执行这里&apos;);setTimeout(() =&gt; &#123; console.log(&apos;执行啦&apos;)&#125;,3000); 代码1的输出结果是：12//先执行这里//执行啦 代码2的输出结果是：123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 ###4.又恨又爱的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 ###5.Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。 Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：1234567891011setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;)new Promise(function(resolve) &#123; console.log(&apos;promise&apos;);&#125;).then(function() &#123; console.log(&apos;then&apos;);&#125;)console.log(&apos;console&apos;); 这段代码作为宏任务，进入主线程。先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。遇到console.log()，立即执行。好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。结束。事件循环，宏任务，微任务的关系如图所示： 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：123456789101112131415161718192021222324252627282930313233343536console.log(&apos;1&apos;);setTimeout(function() &#123; console.log(&apos;2&apos;); process.nextTick(function() &#123; console.log(&apos;3&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;4&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;5&apos;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&apos;6&apos;);&#125;)new Promise(function(resolve) &#123; console.log(&apos;7&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;8&apos;)&#125;)setTimeout(function() &#123; console.log(&apos;9&apos;); process.nextTick(function() &#123; console.log(&apos;10&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;11&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;12&apos;) &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。宏任务Event Queue 微任务Event QueuesetTimeout1 process1setTimeout2 then1上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。执行then1，输出8。好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。宏任务Event Queue 微任务Event QueuesetTimeout2 process2then2第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。输出3。输出5。第二轮事件循环结束，第二轮输出2，4，3，5。第三轮事件循环开始，此时只剩setTimeout2了，执行。直接输出9。将process.nextTick()分发到微任务Event Queue中。记为process3。直接执行new Promise，输出11。将then分发到微任务Event Queue中，记为then3。宏任务Event Queue 微任务Event Queueprocess3then3第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。输出10。输出12。第三轮事件循环结束，第三轮输出9，11，10，12。整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) ###6.写在最后(1)js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 (2)事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 (3)javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 (4)setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 (5)最后的最后javascript是一门单线程语言Event Loop是javascript的执行机制牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！ 1转自http://www.zhangxinxu.com/php/myRecommBackup.php?id=js-excude-detail 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用axios+element-ui 增删改查小例子]]></title>
    <url>%2F2017%2F10%2F17%2F%E7%94%A8axios-element-ui-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%B0%8F%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[axios-elementui增删改查小例子，代码见github,给加个星星：1https://github.com/sky-xsk/axios-elementui- 我用的是公司内部提供的api，所以不在公司内部，是看不到效果的，最主要的还是对源码的参考！放心我会附上图片效果的! 之前使用vue-reource写的，并且没有封装，这个例子用的是es6里的promise进行的封装，单独抽取出api接口；代码如下：模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;template&gt; &lt;div id=&quot;user&quot;&gt; &lt;h1&gt;vue2.0+axios+elementui 简单的增删改查&lt;/h1&gt; &lt;el-row class=&quot;line-display&quot;&gt; &lt;el-col :span=&quot;22&quot; :offset=&quot;1&quot;&gt; &lt;div class=&quot;grid-content&quot; style=&quot;margin-top:30px;&quot;&gt; &lt;!-- 操作 --&gt; &lt;ul class=&quot;btn-edit fr&quot;&gt; &lt;li &gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogCreateVisible = true&quot;&gt; &lt;i class=&quot;el-icon-plus iconss&quot; &gt;&lt;/i&gt;添加用户&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;delete&quot; :disabled=&quot;selected.length==0&quot; @click=&quot;removeUsers()&quot; &gt;删除&lt;/el-button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 用户列表--&gt; &lt;el-col :span=&quot;24&quot; style=&quot;height:20px;&quot;&gt;&lt;/el-col&gt; &lt;el-table :data=&quot;users&quot; stripe v-loading=&quot;loading&quot; element-loading-text=&quot;拼命加载中...&quot; style=&quot;width: 100%;margin-top:20px;&quot; height=&quot;443&quot; @sort-change=&quot;tableSortChange&quot; @selection-change=&quot;tableSelectionChange&quot; &gt; &lt;el-table-column type=&quot;selection&quot; width=&quot;60&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column sortable=&quot;custom&quot; prop=&quot;username&quot; label=&quot;用户名&quot; width=&quot;100&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;80&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;phone&quot; label=&quot;手机&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;email&quot; label=&quot;邮箱&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;create_time&quot; sortable=&quot;custom&quot; label=&quot;注册日期&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;is_active&quot; label=&quot;状态&quot; width=&quot;75&quot; inline-template&gt; &lt;el-tag :type=&quot;row.is_active === true ? &apos;primary&apos; : &apos;success&apos;&quot; close-transition&gt;&#123;&#123;row.is_active|isEnabledFormatter&#125;&#125;&lt;/el-tag&gt; &lt;/el-table-column&gt; &lt;el-table-column inline-template label=&quot;操作&quot; width=&quot;250&quot;&gt; &lt;span&gt; &lt;el-button type=&quot;danger&quot; size=&quot;small&quot; @click=&quot;removeUser(row)&quot;&gt;删除&lt;/el-button&gt; &lt;el-button type=&quot;success&quot; size=&quot;small&quot; @click=&quot;setCurrent(row)&quot;&gt;编辑&lt;/el-button&gt; &lt;/span&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;div style=&quot; width:100%; ovflow:hidden; height:40px;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;!-- 创建用户 begin--&gt; &lt;el-dialog title=&quot;创建用户&quot; v-model=&quot;dialogCreateVisible&quot; :close-on-click-modal=&quot;false&quot; :close-on-press-escape=&quot;false&quot; @close=&quot;reset&quot; &gt; &lt;el-form id=&quot;#create&quot; :model=&quot;create&quot; :rules=&quot;rules&quot; ref=&quot;create&quot; label-width=&quot;100px&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;el-input v-model=&quot;create.username&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;create.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;create.password&quot; type=&quot;password&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt; &lt;el-input v-model=&quot;create.checkPass&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot; prop=&quot;phone&quot;&gt; &lt;el-input v-model=&quot;create.phone&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt; &lt;el-input v-model=&quot;create.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;是否启用&quot;&gt; &lt;el-switch on-text=&quot;&quot; off-text=&quot;&quot; v-model=&quot;create.is_active&quot;&gt;&lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogCreateVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; :loading=&quot;createLoading&quot; @click=&quot;createUser&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- 修改用户 begin--&gt; &lt;el-dialog title=&quot;修改用户信息&quot; v-model=&quot;dialogUpdateVisible&quot; :close-on-click-modal=&quot;false&quot; :close-on-press-escape=&quot;false&quot;&gt; &lt;el-form id=&quot;#update&quot; :model=&quot;update&quot; :rules=&quot;updateRules&quot; ref=&quot;update&quot; label-width=&quot;100px&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;update.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot; prop=&quot;phone&quot;&gt; &lt;el-input v-model=&quot;update.phone&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt; &lt;el-input v-model=&quot;update.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;是否启用&quot;&gt; &lt;el-switch on-text=&quot;&quot; off-text=&quot;&quot; v-model=&quot;update.is_active&quot;&gt;&lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogUpdateVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; :loading=&quot;updateLoading&quot; @click=&quot;updateUser&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt; js代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311&lt;script&gt; import &#123; mapState, mapMutations, mapGetters, mapActions &#125; from &apos;vuex&apos;; import api from &apos;../api/api.js&apos; var placeholders = &#123; &quot;name&quot;: &quot;请输入查找姓名&quot;, &quot;username&quot;: &quot;请输入查找用户名&quot;, &quot;phone&quot;: &quot;请输入查找电话&quot; &#125;; function getuuid() &#123; var uid = []; var hexDigits = &quot;0123456789abcdefghijklmnopqrst&quot;; for (var i = 0; i &lt; 32; i++) &#123; uid[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1); &#125; uid[6] = &quot;4&quot;; uid[15] = hexDigits.substr((uid[15] &amp; 0x3) | 0x8, 1); var uuid = uid.join(&quot;&quot;); return uuid; &#125; export default &#123; name:&apos;&apos;, data : function () &#123; var validatePass = (rule, value, callback) =&gt; &#123; if (value === &apos;&apos;) &#123; callback(new Error(&apos;请再次输入密码&apos;)); &#125; else if (value !== this.create.password) &#123; callback(new Error(&apos;两次输入密码不一致!&apos;)); &#125; else &#123; callback(); &#125; &#125;; return&#123; users:[], filter: &#123; per_page: 10, // 页大小 page: 1, // 当前页 name: &apos;&apos;, username: &apos;&apos;, phone: &apos;&apos;, is_active: &apos;&apos;, create_time:&apos;&apos;, sorts: &apos;&apos; &#125;, create: &#123; id: &apos;&apos;, username: &apos;&apos;, name: &apos;&apos;, password: &apos;&apos;, checkPass: &apos;&apos;, phone: &apos;&apos;, email: &apos;&apos;, is_active: true &#125;, currentId: &apos;&apos;, update: &#123; name: &apos;&apos;, phone: &apos;&apos;, email: &apos;&apos;, is_active: true &#125;, rules: &#123; name: [&#123; required: true, message: &apos;请输入姓名&apos;, trigger: &apos;blur&apos; &#125;, &#123; min: 3, max: 15, message: &apos;长度在 3 到 15 个字符&apos; &#125;], username: [&#123; required: true, message: &apos;请输入用户名&apos;, trigger: &apos;blur&apos; &#125;, &#123; min: 3, max: 25, message: &apos;长度在 3 到 25 个字符&apos; &#125;, &#123; pattern: /^[A-Za-z0-9]+$/, message: &apos;用户名只能为字母和数字&apos; &#125;], password: [&#123; required: true, message: &apos;请输入密码&apos;, trigger: &apos;blur&apos; &#125;, &#123; min: 6, max: 25, message: &apos;长度在 6 到 25 个字符&apos; &#125;], checkPass: [&#123; required: true, message: &apos;请再次输入密码&apos;, trigger: &apos;blur&apos; &#125;, &#123; validator: validatePass &#125;], email: [&#123; type: &apos;email&apos;, message: &apos;邮箱格式不正确&apos; &#125;], phone: [&#123; pattern: /^1[34578]\d&#123;9&#125;$/, message: &apos;请输入中国国内的手机号码&apos; &#125;] &#125;, updateRules: &#123; name: [&#123; required: true, message: &apos;请输入姓名&apos;, trigger: &apos;blur&apos; &#125;, &#123; min: 3, max: 15, message: &apos;长度在 3 到 15 个字符&apos; &#125;], email: [&#123; type: &apos;email&apos;, message: &apos;邮箱格式不正确&apos; &#125;], phone: [&#123; pattern: /^1[34578]\d&#123;9&#125;$/, message: &apos;请输入中国国内的手机号码&apos; &#125;] &#125;, total_rows:0, loading:true, keywords: &apos;&apos;, //搜索框的关键字内容 select: &apos;username&apos;, //搜索框的搜索字段 selected: [], //已选择项 dialogCreateVisible: false, //创建对话框的显示状态 dialogUpdateVisible: false, //编辑对话框的显示状态 createLoading: false, updateLoading: false, placeholder: placeholders[&quot;username&quot;] &#125; &#125;, mounted:function()&#123; this.getUsers(); &#125;, methods:&#123; tableSelectionChange(val) &#123; this.selected = val; &#125;, //排序 tableSortChange(val) &#123; if (val.prop != null) &#123; if (val.order == &apos;descending&apos;) &#123; this.filter.sorts = &apos;-&apos; + val.prop; &#125; else &#123; this.filter.sorts = &apos;&apos; + val.prop; &#125; &#125; else &#123; this.filter.sorts = &apos;&apos;; &#125; this.getUsers(); &#125;, //每页显示多少条 pageSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); this.filter.per_page = val; this.getUsers(); &#125;, //当前页选择 pageCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); this.filter.page = val; this.getUsers(); &#125;, searchFieldChange(val) &#123; this.placeholder = placeholders[val]; console.log(`搜索字段： $&#123;val&#125; `); &#125;, rowClick(row, event) &#123; var index = $.inArray(row, this.selected) if (index &lt; 0) &#123; this.selected.push(row); this.$refs.usersTable.toggleRowSelection(row, true); &#125; else &#123; this.selected.splice(index, 1); this.$refs.usersTable.toggleRowSelection(row, false); &#125; &#125;, // 重置表单 reset() &#123; this.$refs.create.resetFields(); &#125;, setCurrent(user) &#123; this.currentId = user.id; this.update.name = user.name; this.update.phone = user.phone; this.update.email = user.email; this.update.is_active = user.is_active; this.dialogUpdateVisible = true; &#125;, //获取用户数据 getUsers()&#123; this.loading = true; api._get().then(res =&gt; &#123; this.users = res.datas; this.total_rows = res.datas.total_rows; this.loading=false; console.log(res); &#125;,err =&gt; &#123; console.log(err); &#125;) &#125;, //创建用户 createUser() &#123; this.$refs.create.validate((valid) =&gt; &#123; if (valid) &#123; this.create.id = getuuid(); this.createLoading = true; api._post(this.create).then(res =&gt; &#123; this.$message.success(&apos;创建用户成功！&apos;); this.dialogCreateVisible = false; this.createLoading = false; this.reset(); this.getUsers(); &#125;).catch((res) =&gt; &#123; var data = res; if (data instanceof Array) &#123; this.$message.error(data[0][&quot;message&quot;]); &#125; else if (data instanceof Object) &#123; this.$message.error(data[&quot;message&quot;]); &#125; this.createLoading = false; &#125;); &#125; else &#123; //this.$message.error(&apos;存在输入校验错误!&apos;); return false; &#125; &#125;); &#125;, // 更新用户资料 updateUser() &#123; this.$refs.update.validate((valid) =&gt; &#123; if (valid) &#123; this.updateLoading = true; api._update(this.currentId, this.update).then(res =&gt; &#123; this.$message.success(&apos;修改用户资料成功！&apos;); this.dialogUpdateVisible = false; this.updateLoading = false; this.getUsers(); &#125;).catch((res) =&gt; &#123; var data = res; if (data instanceof Array) &#123; this.$message.error(data[0][&quot;message&quot;]); &#125; else if (data instanceof Object) &#123; this.$message.error(data[&quot;message&quot;]); &#125; this.updateLoading = false; &#125;); &#125; else &#123; return false; &#125; &#125;); &#125;, // 删除单个用户 removeUser(user) &#123; this.$confirm(&apos;此操作将永久删除用户 &apos; + user.username + &apos;, 是否继续?&apos;, &apos;提示&apos;, &#123; type: &apos;warning&apos; &#125;).then(() =&gt; &#123; api._remove(user).then(res =&gt; &#123; this.$message.success(&apos;成功删除了用户&apos; + user.username + &apos;!&apos;); this.getUsers(); console.log(user.id); &#125;).catch((res) =&gt; &#123; this.$message.error(&apos;删除失败!&apos;); &#125;); &#125;).catch(() =&gt; &#123; this.$message.info(&apos;已取消操作!&apos;); &#125;); &#125;, //删除多个用户 removeUsers() &#123; this.$confirm(&apos;此操作将永久删除 &apos; + this.selected.length + &apos; 个用户, 是否继续?&apos;, &apos;提示&apos;, &#123; type: &apos;warning&apos; &#125;).then(() =&gt; &#123; api._removes().then(res =&gt;&#123; this.$message.success(&apos;删除了&apos; + this.selected.length + &apos;个用户!&apos;); this.getUsers(); &#125;).catch((res) =&gt; &#123; this.$message.error(&apos;删除失败!&apos;); &#125;); &#125;).catch(() =&gt; &#123; this.$message(&apos;已取消操作!&apos;); &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;ul li&#123;list-style: none&#125;.tc&#123;text-align:center; &#125;.mg&#123; margin-top:10px;&#125;.fl&#123;float:left&#125;.fr&#123;float:right&#125;h1&#123;text-align: center;&#125;&lt;/style&gt; 抽离的api以及代码的二次封装：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import axios from &apos;axios&apos;import qs from &apos;qs&apos;//延时设置axios.defaults.timeout = 5000axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;axios.defaults.params = &#123;&#125;// POST传参序列化axios.interceptors.request.use((config) =&gt; &#123; // if (config.method === &apos;post&apos;) &#123; // config.data = qs.stringify(config.data) // &#125; let URL = config.url.split(config.baseURL) return config&#125;, (error) =&gt; &#123; return Promise.reject(error)&#125;) // 返回状态判断axios.interceptors.response.use((res) =&gt; &#123; //console.log(res) return res&#125;, (error) =&gt; &#123; return Promise.reject(error)&#125;)/** * * 备注：也可以使用fetch * *///封装获取数据export const oGet = (url, params) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, params) .then(res =&gt; &#123; resolve(res.data) &#125;, err =&gt; &#123; reject(err) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;;//封装发送数据export const oPost = (url, params) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params) .then(res =&gt; &#123; resolve(res.data) &#125;, err =&gt; &#123; reject(err) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;//封装更新数据export const oUpdate = (url ,param,params) =&gt; &#123; return new Promise((resolve , reject) =&gt; &#123; axios.patch(url ,param, params) .then(res =&gt; &#123; resolve(res.data) &#125;, err =&gt; &#123; reject(err) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;//封装删除数据export const oRemove = (url , params) =&gt; &#123; return new Promise((resolve,reject) =&gt; &#123; axios.delete(url,params) .then(res =&gt; &#123; resolve(res.data) &#125;,err =&gt; &#123; reject(err) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;export default &#123; //此处是本地接口，你可在本公司局域网内使用 //获取用户数据 _get () &#123; return oGet(&apos;http://192.168.1.190/api/v1/accounts&apos;); &#125;, //新建用户 _post (params) &#123; return oPost(&apos;http://192.168.1.190/api/v1/accounts&apos;,params); &#125;, //更新用户数据 _update (param,params) &#123; return oUpdate(&apos;http://192.168.1.190/api/v1/accounts&apos;+&apos;?ids=&apos;+param, params); &#125;, //删除单个用户 _remove(user)&#123; var userid = user.id; return oRemove(&apos;http://192.168.1.190/api/v1/accounts/&apos;+ userid); &#125;, //批量删除 _removes()&#123; var ids = []; $.each(this.selected, (i, user) =&gt; &#123; ids.push(user.id); &#125;); ids = ids.join(&quot;,&quot;); return oRemove(&apos;http://192.168.1.190/api/v1/accounts/&apos;+ids); &#125;,&#125; 截图效果： 如果有帮助，请不要吝啬，给个‘star’，就是对我的鼓励！1https://github.com/sky-xsk/axios-elementui- 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性进阶（8）]]></title>
    <url>%2F2017%2F09%2F06%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%888%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Babel 到目前2017年为止，也不是所有的浏览器都支持ES6的特性。所以我们需要把ES6转换成ES5的代码，就要用到所谓的转码器。Babel就是目前使用最广泛的把ES6代码转换成ES5及以前代码的转码器。有了babel我们就可以放心的使用ES6的最新的语法，而不用担心浏览器不支持了！！！为了方便使用，我直接使用webstorm的filewatcher功能安装Babel首先要保证电脑上已经安装了npm使用如下命令就可以安装babel安装(我们这里使用的是全局安装)：1npm install -g babel-cli 安·babel-present-env1npm install babel-preset-env --save-dev 自动转换为es5代码 1js文件中的es6代码会自动转换为es5代码 MoudleJavaScript 采用 “共享一切” 的代码加载方式是该语言中最令人迷惑且容易出错的方面之一。其它语言使用包（package）的概念来定义代码的作用范围，然而在 ECMAScript 6 之前，每个 JavaScript 文件中定义的内容都由全局作用域共享。当 web 应用变得复杂并需要书写更多的 JavaScript 代码时，上述加载方式会出现命名冲突或安全方面的问题。ECMAScript 6 的目标之一就是解决作用域的问题并将 JavaScript 应用中的代码整理得更有条理，于是模块应运而生。很不幸的是：目前，所有的浏览器都还不能支持ES6的模块。只能通过第三方的工具转成ES5的代码; 什么是模块模块是指采取不同于现有加载方式的 JavaScript 文件（与 script 这种传统的加载模式相对）。这种方式很有必要，因为它和 script 使用不同的语义：模块中的代码自动运行在严格模式下，并无任何办法修改为非严格模式。模块中的顶级（top level）变量不会被添加到全局作用域中。它们只存在于各自的模块中的顶级作用域。模块顶级作用域中的 this 为 undefined 。模块不允许存在 HTML 式的注释（JavaScript 历史悠久的遗留特性）。模块必须输出可被模块外部代码使用的相关内容。一个模块可以引入另外的模块。 导出模块可以使用 export 关键字来对外暴露模块中的部分代码。​一般情况下，可以在任何变量，函数或类声明之前添加这个关键字来输出它们，看下面的代码:声明一个文件：a.js 代码如下: 12345678910111213141516171819202122232425262728// 输出变量export var color = &quot;red&quot;;export let name = &quot;Nicholas&quot;;export const magicNumber = 7;// 输出函数export function sum(num1, num2) &#123; return num1 + num1;&#125;// 输出类export class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125;&#125;// 该函数没有使用export关键字 所以该函数是模块私有的。也就是说只能在当前文件访问，出了这个文件就访问不到function subtract(num1, num2) &#123; return num1 - num2;&#125;// 定义一个函数...function multiply(num1, num2) &#123; return num1 * num2;&#125;// 可以把这个函数的引用导出。 和导出函数是一样的。export &#123; multiply &#125;; 注意：在上面的代码中，除了exprot关键字，其他和我们以前的代码没有任何不同。 引入模块一旦有了导出内容的模块，则可以在另一个模块中使用import关键字来获取他们。引入模块的语法：1import &#123; identifier1, identifier2 &#125; from &quot;./a.js&quot;; import 之后的花括号表示从模块中引入的绑定。from 关键字表示从哪个模块引入这些绑定。模块由一个包含模块路径的字符串表示（称为模块指示符，module sepcifier）; 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性进阶（7）]]></title>
    <url>%2F2017%2F09%2F06%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。ES5之前的模拟的类在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：12345678910function PersonType(name) &#123; this.name = name;&#125;PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person = new PersonType(&quot;Nicholas&quot;);person.sayName(); // 输出 &quot;Nicholas&quot;console.log(person instanceof PersonType); // trueconsole.log(person instanceof Object); // true 前面的PersonType我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。 ES6中基本的类声明在ES6直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。 123456789101112131415161718//class关键字必须是小写。 后面就是跟的类名class PersonClass &#123; // 等效于 PersonType 构造函数。 constructor(name) &#123; //这个表示类的构造函数。constuctor也是关键字必须小写。 this.name = name; //创建属性。 也叫当前类型的自有属性。 &#125; // 等效于 PersonType.prototype.sayName. 这里的sayName使用了我们前面的简写的方式。 sayName() &#123; console.log(this.name); &#125;&#125;let person = new PersonClass(&quot;Nicholas&quot;);person.sayName(); // 输出 &quot;Nicholas&quot;console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // &quot;function&quot;console.log(typeof PersonClass.prototype.sayName); // &quot;function&quot; 1.自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议 尽可能的将所有自有属性创建在构造函数中，这样当查找属性时可以做到一目了然。2.类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记 1.类声明和函数定义不同，类的声明是不会被提升的。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。2.类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。3.所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。4.所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。5.不使用 new 来调用类构造函数会抛出错误。也就是 必须使用new 类() 的方式使用6.试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的） 匿名类表达式函数有函数表达式，类也有类表达式。类表达式的功能和前面的类的声明是一样的。 12345678910111213141516let PersonClass = class &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;;let person = new PersonClass(&quot;Nicholas&quot;);person.sayName(); // 输出 &quot;Nicholas&quot;console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // &quot;function&quot;console.log(typeof PersonClass.prototype.sayName); // &quot;function&quot; 具名类表达式 1234567891011let PersonClass = class PersonClass2&#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;; 注意：具名类表达式中PersonClass2这个类名只能在类的内部访问到，在外面是访问不到的. 作为一等公民的类型在JavaScript中，函数是作为一等公民存在的。(也叫一等函数)。 类也是一等公民。类可以作为参数传递12345678910function createObject(classDef) &#123; return new classDef();&#125;let obj = createObject(class &#123; sayHi() &#123; console.log(&quot;Hi!&quot;); &#125;&#125;);obj.sayHi(); // &quot;Hi!&quot; 立即调用类构造函数，创建单例12345678910let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(&quot;Nicholas&quot;);person.sayName(); // &quot;Nicholas&quot; 动态计算类成员的命名类的成员，也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算)1234567891011let methodName = &quot;sayName&quot;;class PersonClass &#123; constructor(name) &#123; this.name = name; &#125; [methodName]() &#123; console.log(this.name); &#125;&#125;let me = new PersonClass(&quot;Nicholas&quot;);me.sayName(); // &quot;Nicholas&quot; 静态成员在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。123456789101112function PersonType(name) &#123; this.name = name;&#125;// 静态方法。 直接添加到构造方法上。 (其实是把构造函数当做一个普通的对象来用。)PersonType.create = function(name) &#123; return new PersonType(name);&#125;;// 实例方法PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person = PersonType.create(&quot;Nicholas&quot;); 在上面的create方法在其他语言中一般都是作为静态方法来使用的。下面高能，请注意：ECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的： 123456789101112131415class PersonClass &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125; // 等效于 PersonType.create。 static create(name) &#123; return new PersonClass(name); &#125;&#125;let person = PersonClass.create(&quot;Nicholas&quot;); 注意：静态成员通过实例对象不能访问，只能通过类名访问！！！通过和ES5模拟静态方法的例子你应该知道为啥了吧 ES6中的继承在ES6之前要完成继承，需要写很多的代码。看下面的继承的例子：12345678910111213141516171819function Father(name) &#123; this.name = name;&#125;Father.prototype.sayName = function () &#123; console.log(this.name);&#125;function Son(name,age) &#123; Father.call(this, name); this.age = age;&#125;Son.prototype = new Father();Son.prototype.constructor = Son;Son.prototype.sayAge = function () &#123; console.log(this.age);&#125;​var son1 = new Son(&quot;儿子&quot;, 20);son1.sayAge(); //20son1.sayName(); //儿子 继承的基本写法如果在ES6通过类的方式完成继承就简单了很多。需要用到一个新的关键字：extends 123456789101112131415161718192021222324class Father&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name); &#125; &#125; class Son extends Father&#123; //extents后面跟表示要继承的类型 constructor(name, age)&#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge()&#123; console.log(this.age); &#125; &#125; var son1 = new Son(&quot;李四&quot;, 30); son1.sayAge(); son1.sayName(); console.log(son1 instanceof Son); // true console.log(son1 instanceof Father); //true 这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。关于super的使用，有几点需要注意：你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。 在子类中屏蔽父类的方法 如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 )123456789101112131415161718192021222324252627class Father&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name); &#125; &#125; class Son extends Father&#123; //extents后面跟表示要继承的类型 constructor(name, age)&#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge()&#123; console.log(this.age); &#125; //子类中的方法会屏蔽到父类中的同名方法。 sayName()&#123; super.syaName(); //调用被覆盖的父类中的方法。 console.log(&quot;我是子类的方法，我屏蔽了父类：&quot; + name); &#125; &#125; var son1 = new Son(&quot;李四&quot;, 30); son1.sayAge(); son1.sayName(); 如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。 注意：如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法普通方法调用需要使用super.父类的方法() 来调用。 静态方法也可以继承12345678910class Father&#123; static foo()&#123; console.log(&quot;我是父类的静态方法&quot;); &#125;&#125;class Son extends Father&#123;&#125;Son.foo(); //子类也继承了父类的静态方法。 这种方式调用和直接通过父类名调用时一样的。​ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性进阶（6）]]></title>
    <url>%2F2017%2F09%2F06%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Map数据结构ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。​键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。​这和使用对象属性做为值的方法大相径庭，因为 对象的属性会被强制转换为字符串类型。创建Map对象和Map的基本的存取操作1.Map创建也是使用Map构造函数2.向Map存储键值对使用set(key, value);方法3.可以使用get(key),来获取指定key对应的value12345678var map = new Map();map.set(&quot;a&quot;, &quot;lisi&quot;);map.set(&quot;b&quot;, &quot;zhangsan&quot;);map.set(&quot;b&quot;, &quot;zhangsan222&quot;); // 第二次添加，新的value会替换掉旧的console.log(map.get(&quot;a&quot;));console.log(map.get(&quot;b&quot;)); //zhangsan222console.log(map.get(&quot;c&quot;)); //undefined.如果key不存在，则返回undefinedconsole.log(map.size); //2 Map与Set类似的3个方法has(key) - 判断给定的 key 是否在 map 中存在delete(key) - 移除 map 中的 key 及对应的值clear() - 移除 map 中所有的键值对 初始化Map创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。也就是传入的实际是一个二维数组！123456789//map接受一个二维数组var map = new Map([ //每一个数组中，第一个是是map的可以，第二个是map的value。如果只有第一个，则值是undefined [&quot;name&quot;, &quot;lisi&quot;], [&quot;age&quot;, 20], [&quot;sex&quot;, &quot;nan&quot;]]);console.log(map.size);console.log(map.get(&quot;name&quot;)) Map的forEach方法123456789101112131415var map = new Map([ [&quot;name&quot;, &quot;李四&quot;], [&quot;age&quot;, 20], [&quot;sex&quot;, &quot;nan&quot;]]);/* 回调函数有函数： 参数1：键值对的value 参数2：键值对的key 参数3：map对象本身 */map.forEach(function (value, key, ownMap) &#123; console.log(`key=$&#123;key&#125; ,vlue=$&#123;value&#125;`); console.log(this);&#125;) 迭代器(iterator)和for…of循环循环问题1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];for (var i = 0, len = colors.length; i &lt; len; i++) &#123; console.log(colors[i]);&#125; 上面的代码写起来简单，但是实际使用的过程中，我们需要自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。迭代器就是为了解决这个问题的。 什么是迭代器迭代器是一个对象迭代器提供一个方法next() 这个方式总是能够返回迭代到的对象。next返回的对象中，至少有两个属性：done 是一个boolean值(表示数据是否迭代完)。 value：具体的数据(迭代到的具体数据)​ 迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。 ​ 若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。 我们可以用ES5之前的知识手动创建一个迭代器： 123456789101112131415161718192021function createIterator(items) &#123;var i = 0;return &#123; next: function() &#123; var done = (i &gt;= items.length); var value = !done ? items[i++] : undefined; return &#123; done: done, value: value &#125;; &#125;&#125;;&#125;//创建一个可以在指定数组上面迭代的迭代器对象。var iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // &quot;&#123; value: 1, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: 2, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: 3, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot;// for all further callsconsole.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot; 从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。 幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。 生成器函数生成器函数就是返回迭代器的函数！生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。看下面代码： 123456789101112//生成器函数。 注意中间的 * 不能丢function * createIterator() &#123; //每个yield的后面的值表示我们迭代到的值。 yield也定义了我们迭代的顺序。 yield 3; yield 4; yield 2;&#125;var it = createIterator();console.log(it.next().value); // 2console.log(it.next().value); // 4console.log(it.next().value); // 2console.log(it.next().value); //undefined 迭代器函数也是函数，所以他可以像正常的函数一样调用，但是迭代器生成器函数会自动返回一个迭代器对象。每调用一次迭代器的next方法，如果碰到 yield 都会返回一个迭代到的一个对象，然后停止执行，直到下次调用next方法，会从上次停止的地方继续执行。 1234567891011121314//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。function *createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; //每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 &#123;value : items[i], done : true&#125; yield items[i]; &#125;&#125;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // &quot;&#123; value: 1, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: 2, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: 3, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot;// 进一步调用console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot; 注意：yield 关键字只能 直接用在生成器内部 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。 生成器函数表达式你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如：123456789101112let createIterator = function *(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125;&#125;;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // &quot;&#123; value: 1, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: 2, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: 3, done: false &#125;&quot;console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot;// 进一步调用console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot; 注意：无法使用箭头函数来创建生成器。 可迭代类型和for-of迭代循环迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。​与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性（方法）的对象。​该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 for-of 循环而设计的。 换句话说，默认情况下只有 数组、set、Map和字符串才可以使用迭代器去迭代。 (也就可以使用for…of了)for…of循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！使用 for…of 迭代数组： 1234var arr = [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;];for(var item of arr)&#123; console.log(item)&#125; 使用 for…of 迭代Set: 1234var set = new Set([&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;]);for(var item of set)&#123; console.log(item)&#125; 使用 for…of 迭代Map：12345var map = new Map([[&quot;name&quot;, &quot;lisi&quot;],[&quot;sex&quot;, &quot;男&quot;],[&quot;age&quot;, 20]]);map.set(&quot;aaa&quot;, &quot;bbb&quot;)for(var item of map)&#123; console.log(item); //注意：这里迭代到的是由key和value组成的数组。&#125; 使用for … of迭代字符串 1234var s = &quot;abcd&quot;;for(let c of s)&#123; console.log(c)&#125; 注意：for…of 只能迭代可以迭代的对象，对于非可迭代对象使用for…of会抛出异常 说明：以数组为例。​ for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。​ 如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。 访问可迭代类型的默认迭代器Symbol.iterator是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。123let s = &quot;abcd&quot;;let it = s[Symbol.iterator](); //调用字符串的Symbol.iterator方法console.log(it.next()); //返回迭代器迭代到的第一个对象 因为Symbol可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代12345678function isIterable(object) &#123; return typeof object[Symbol.iterator] === &quot;function&quot;;&#125;console.log(isIterable([1, 2, 3])); // trueconsole.log(isIterable(&quot;Hello&quot;)); // trueconsole.log(isIterable(new Map())); // trueconsole.log(isIterable(new Set())); // trueconsole.log(isIterable(&#123;&quot;name&quot;:&quot;李四&quot;&#125;)); // false。普通对象不可迭代 开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如：1234567891011121314let collection = &#123; items: [], *[Symbol.iterator]() &#123; for (let item of this.items) &#123; yield item; &#125; &#125;&#125;;collection.items.push(1);collection.items.push(2);collection.items.push(3);for (let x of collection) &#123; console.log(x);&#125; 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性进阶（5）]]></title>
    <url>%2F2017%2F09%2F05%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Set数据结构JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。​因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。Set是类似数组的一种结构，可以存储数据，与数组的区别主要是 Set中的元素不能重复，而数组中的元素可以重复。一句话总结：Set类型是一个包含无重复元素的有序列表创建Set和并添加元素Set本身是一个构造函数。12345678 //创建Set数据结构对象。var s = new Set();//调用set对象的add方法，向set中添加元素s.add(&quot;a&quot;);s.add(&quot;c&quot;);s.add(&quot;b&quot;);//set的size属性可以获取set中元素的个数console.log(s.size) Set中不能添加重复元素123456var s = new Set();s.add(&quot;a&quot;);s.add(&quot;c&quot;);s.add(&quot;b&quot;);s.add(&quot;a&quot;); //重复，所以添加失败。注意这个地方并不会保存。console.log(s.size); // 长度是3 看下面的代码： 1234 var s = new Set();s.add(5);s.add(&quot;5&quot;);console.log(s.size); // 长度是2 在上面的代码中，数字5和字符串5都会添加成功。为什么呢？Set是使用什么机制来判断两个元素是否相等的呢？是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。 12345678910var s = new Set();s.add(+0);s.add(-0); //重复添加不进去s.add(NaN);s.add(NaN); //重复添加不进去s.add([]);s.add([]); //两个空数组不相等，所以可以添加进去s.add(&#123;&#125;);s.add(&#123;&#125;); // 两个空对象也不重复，所以也可以添加进去console.log(s.size); // 长度是6 使用数组初始化Set 123//使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。var s = new Set([2, 3, 2, 2, 4]);console.log(s.size) 使用Set的 has() 方法可以判断一个值是否在这个set中。12345let set = new Set();set.add(5);set.add(&quot;5&quot;);console.log(set.has(5)); // trueconsole.log(set.has(6)); // false 移除Set中的元素delete(要删除的值) ：删除单个值clear()：清空所有的值12345678910let set = new Set();set.add(5);set.add(&quot;5&quot;);console.log(set.has(5)); // trueset.delete(5);console.log(set.has(5)); // falseconsole.log(set.size); // 1set.clear();console.log(set.has(&quot;5&quot;)); // falseconsole.log(set.size); // 0 遍历Set数组有个方法forEach可以遍历数组。Set也有forEach可以遍历Set。使用Set的forEach遍历时的回调函数有三个参数：123function (value, key, ownerSet)&#123;&#125; 参数1：遍历到的元素的值参数2：对set集合来说，参数2的值和参数1的值是完全一样的。参数3：这个 set 自己 1234let set = new Set([&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, 9]);set.forEach(function (v, k, s) &#123; console.log(v + &quot; &quot; + (v === k) + &quot; &quot; + (s === set)); // 永远是true&#125;) for…of也可以遍历set123for(var v of set)&#123; console.log(v)&#125; 将Set转换为数组将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。把Set转换为数组使用前面讲到的扩展运算符也很容易123let set = new Set([1, 2, 3, 3, 3, 4, 5]),arr = [...set]; //使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此处对set并没有什么影响console.log(arr); // [1,2,3,4,5] 这种情况在需要去数组中重复元素的时候非常好用。1234567function eliminateDuplicates(items) &#123; return [...new Set(items)];&#125;let numbers = [1, 2, 3, 3, 3, 4, 5, 5, 2, 1, 1], //返回的是新的没有重复元素的数组。 noDuplicates = eliminateDuplicates(numbers);console.log(noDuplicates); // [1,2,3,4,5] Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性进阶（4）]]></title>
    <url>%2F2017%2F09%2F05%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数组解构基本语法数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如： 1234let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];let [ firstColor, secondColor ] = colors;console.log(firstColor); // &quot;red&quot;console.log(secondColor); // &quot;green&quot; 如果只想取数组中的某一项，则可以不用命名。 1234let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];//只取数组中的第三项。let [ , , thirdColor ] = colors;console.log(thirdColor); // &quot;blue&quot; 解构表达式你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如：123456let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ], firstColor = &quot;black&quot;, secondColor = &quot;purple&quot;;[ firstColor, secondColor ] = colors; //可以不用加括号。当然添加也不犯法console.log(firstColor); // &quot;red&quot;console.log(secondColor); // &quot;green&quot; 数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码： 12345678 let a = 3, b = 4, temp;temp = a;a = b;b = temp;console.log(a);console.log(b) 那么在ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式 123456 let a = 3,b = 4;//左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。[a, b] = [b, a];console.log(a);console.log(b) 新的基本类型：Symbol 以前我们有5种基本数据类型：Number、String、Boolean、Null、UndefinedES6新增了一种新的数据类型：Symbol在ES5之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。 创建SymbolSymbol在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是Symbol却不可以使用字面量的是形式去创建。我们可以使用symbol全局函数来创建Symbol。1234let firstName = Symbol(); //创建一个Symbollet person = &#123;&#125;;person[firstName] = &quot;张三&quot;;console.log(person[firstName]); // &quot;张三&quot; 说明：上面的代码中，firstName 作为 symbol 类型被创建并赋值给 person 对象以作其属性。每次访问这个属性时必须使用该 symbol 。在创建Symbol的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。 123 var s1 = Symbol(&quot;abc&quot;);var s2 = Symbol(&quot;abc&quot;);console.log(s1 == s2); //false 注意：任意两个Symbol都不会相等，即使创建他们的时候使用了相同的参数。 识别Symbol既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如：12let symbol = Symbol();console.log(typeof symbol); // &quot;symbol&quot; Symbol作为属性名由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 12345678var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;;// 第二种写法var a = &#123; [mySymbol]: &apos;Hello!&apos;&#125; 以上两种写法都是相同的结果注意：symbol作为对象的属性的时候，只能使用 [ ] 去访问，不能使用点去访问。symbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of时无法遍历到这个symbol属性的。 Symbol属性名的遍历Symbol 作为属性名，该属性不会出现在for…in循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。看下面的代码: 12345678var obj = &#123;&#125;;var a = Symbol(&apos;a&apos;);var b = Symbol(&apos;b&apos;);obj[a] = &apos;Hello&apos;;obj[b] = &apos;World&apos;;// 返回obj对象所有Symbol类型的属性名组成的数组。var objectSymbols = Object.getOwnPropertySymbols(obj);console.log(objectSymbols) //[Symbol(a), Symbol(b)] 看下面的代码: 12345678var obj = &#123;&#125;;var foo = Symbol(&quot;foo&quot;);obj[foo] = &quot;lisi&quot;;for (var i in obj) &#123; console.log(i); // 无输出 。 因为遍历不到Symbol型的属性 &#125;Object.getOwnPropertyNames(obj);// [] 只能拿到非Symbol类型的属性Object.getOwnPropertySymbols(obj) //[Symbol(foo)] 还有一个新API可以拿到所有类型的属性，包括常规和Symbol型的。Reflect.ownKeys 123456let obj = &#123; [Symbol(&apos;my_key&apos;)]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj);// [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] 说明：由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)一、Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个sybol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。12345//第一次搜不到，则新创建一个返回，并在全局环境(window)中注册var a = Symbol.for(&quot;foo&quot;);//第二次搜到上次创建的var b = Symbol.for(&quot;foo&quot;);console.log(a === b); //因为两次搜到的是同一个Symbol，所以此处是true Symbol.for()和Symbol()都可以创建Symbol类型的数据。二者区别：Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。Symbol()则不会有搜索的过程，每次都是一个全新的不同的symbol，而且也不会向全局环境中注册。看下面的代码: 123var a = Symbol(&quot;foo&quot;);var b = Symbol.for(&quot;foo&quot;);console.log(a == b); //false 二、Symbol.keyFor(symbol):返回一个已经注册的symbol的”key”。1234var a = Symbol(&quot;foo&quot;);var b = Symbol.for(&quot;foo&quot;);console.log(Symbol.keyFor(a)); // undefined. 因为a没有想全局环境中登记，所以是undefindedconsole.log(Symbol.keyFor(b)); // foo 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性进阶（3）]]></title>
    <url>%2F2017%2F09%2F05%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[字符串功能的增强在以前在字符串中查找字符串的时候，都是使用indexOf方法。ES6新增了三个方法来查找字符串。includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 则是字符串搜索的结束位置。若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示： 12345678910var msg = &quot;Hello world!&quot;;console.log(msg.startsWith(&quot;Hello&quot;)); // trueconsole.log(msg.endsWith(&quot;!&quot;)); // trueconsole.log(msg.includes(&quot;o&quot;)); // trueconsole.log(msg.startsWith(&quot;o&quot;)); // falseconsole.log(msg.endsWith(&quot;world!&quot;)); // trueconsole.log(msg.includes(&quot;x&quot;)); // falseconsole.log(msg.startsWith(&quot;o&quot;, 4)); // trueconsole.log(msg.endsWith(&quot;o&quot;, 8)); // trueconsole.log(msg.includes(&quot;o&quot;, 8)); // false repeat方法ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如：123console.log(&quot;x&quot;.repeat(3)); // &quot;xxx&quot;console.log(&quot;hello&quot;.repeat(2)); // &quot;hellohello&quot;console.log(&quot;abc&quot;.repeat(4)); // &quot;abcabcabcabc&quot; 字符串模板字面量12345模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应：多行字符串 针对多行字符串的形式概念（formal concept）。基本的字符串格式化 将字符串中的变量置换为值的能力。转义 HTML 能将字符串进行转义并使其安全地插入到 HTML 的能力。模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。 基本语法使用一对反引号 ``(tab正上方的按键)来表示模板字面量。1234let message = `Hello world!`; //使用模板字面量创建了一个字符串console.log(message); // &quot;Hello world!&quot;console.log(typeof message); // &quot;string&quot;console.log(message.length); // 12 注意：如果模板字符串中使用到了反引号，则应该转义。但是单双引号不需要转义 多行字符串在ES5之前JavaScript是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是bug的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \）123 var s = &quot;abc \aaaaaa&quot;;console.log(s); //但是输出的结果中不包括换行 但是在ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法12345var s = `abcaaaaadsalfjadfadfja`;console.log(s); 但是要注意： 反引号中的所有空格和缩进都是有效字符。 字符串置换置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。语法：${变量名、表达式、任意运算、方法调用等}可以嵌入任何有效的JavaScript代码 123var name = &quot;李四&quot;;var msg = `欢迎你$&#123;name&#125;同学`;console.log(msg) 什么是模板标签?模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示： 1let message = myTag`Hello world`; 在上面的代码中，myTag就是模板标签。myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。 定义模板标签 一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下： 123456789101112131415161718let name = &apos;张三&apos;, age = 20, message = show`我来给大家介绍$&#123;name&#125;的年龄是$&#123;age&#125;.`;/* 应该定义一个函数show： 参数1：一个字符串数组。在本例中包含三个元素。 0:&quot;我来给大家介绍&quot; 1:&quot;的年龄是&quot; 2:&quot;.&quot; 参数2和参数3：表示需要置换的字符串的值。 */function show(stringArr, value1, value2) &#123; console.log(stringArr); // console.log(value1); // 张三 console.log(value2); // 20 return &quot;abc&quot;;&#125;console.log(message); //abc 为了简化书写，一般把Value1和Value2写成剩余字符串的形式 1function show(stringArr, ...values)&#123;&#125; 解构的实用在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如：1234567let options = &#123; repeat: true, save: false&#125;;// 从对象中提取数据let repeat = options.repeat,save = options.save; 这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个数据结构。这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。 对象解构的基本形式 对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。 12345678let node = &#123; type: &quot;Identifier&quot;, name: &quot;foo&quot;&#125;;//这里就相当于声明了两个变量： type = node.type; name:node.namelet &#123; type, name &#125; = node;console.log(type); // &quot;Identifier&quot;console.log(name); // &quot;foo&quot; 在上面的结构中必须要初始化。否则会出现语法错误。 123456// 语法错误！var &#123; type, name &#125;;// 语法错误！let &#123; type, name &#125;;// 语法错误！const &#123; type, name &#125;; 解构赋值表达式如果声明的变量想改变他们的值，也可以使用解构表达式。12345678910let node = &#123; type: &quot;Identifier&quot;, name: &quot;foo&quot;&#125;,type = &quot;Literal&quot;,name = 5;//注意：此处必须要在圆括号内才能使用解构表达式(&#123;type, name&#125; = node);console.log(type); // &quot;Identifier&quot;console.log(name); // &quot;foo&quot;&quot; 对象解构时的默认值如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined123456789let node = &#123; type: &quot;Identifier&quot;, name: &quot;foo&quot;&#125;;//因为node中没有叫value的属性，所以valued的值将会是undefinedlet &#123; type, name, value &#125; = node;console.log(type); // &quot;Identifier&quot;console.log(name); // &quot;foo&quot;console.log(value); // undefined 不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像）123456789let node = &#123; type: &quot;Identifier&quot;, name: &quot;foo&quot;&#125;;//手动添加value的默认值为3let &#123; type, name, value = 3&#125; = node;console.log(type); // &quot;Identifier&quot;console.log(name); // &quot;foo&quot;console.log(value); // 3 赋值给不同的变量名在前面的操作中，都是把对象的属性值，赋值给同名变量。其实也可以赋值给不同名的变量。 12345678let node = &#123; type: &quot;Identifier&quot;, name: &quot;foo&quot;&#125;;// localType才是要定义的新的变量。 type是node的属性let &#123;type: localType, name: localName&#125; = node;console.log(localType); // &quot;Identifier&quot;console.log(localName); // &quot;foo&quot; 注意：冒号后面才是要定义的新的变量，这个和我们的对象字面量不太一样！这个地方也可以使用默认值。 1234567let node = &#123; type: &quot;Identifier&quot;&#125;;let &#123; type: localType, name: localName = &quot;bar&quot; &#125; = node;console.log(localType); // &quot;Identifier&quot;console.log(localName); // &quot;bar&quot; 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性进阶（2）]]></title>
    <url>%2F2017%2F09%2F05%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对象功能的扩展在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。ECMAScript 6 给对象的各个方面，从简单的语法扩展到操作与交互，都做了改进。对象类别ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括：普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。特异对象（exotic object）的某些内部行为和默认的有所差异。标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。 简写的属性初始化 123456789function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name:name, age:age &#125;&#125;console.log(createPerson(&quot;lisi&quot;, 30)); // &#123;name:&quot;lisi&quot;, age:30&#125;//在ES6中，上面的写法可以简化成如下形式 在ES6中，上面的写法可以简化成如下的形式： 12345678function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name, //当对象属性名和本地变量名相同时，可以省略冒号和值 age &#125;&#125;console.log(createPerson(&quot;lisi&quot;, 30)); // &#123;name:&quot;lisi&quot;, age:30&#125; 当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。该项扩展使得对象字面量的初始化变得简明的同时也消除了命名错误。对象属性被同名变量赋值在 JavaScript 中是一种普遍的编程模式，所以这项扩展的添加非常受欢迎。 简写的方法声明 1234567var person = &#123; name:&apos;lisi&apos;, sayHell:function () &#123; console.log(&quot;我的名字是：&quot; + this.name); &#125;&#125;person.sayHell() 在ES6中，上面的写法可以简化成如下的形式： 1234567 var person = &#123; name:&apos;李四&apos;, sayHell() &#123; console.log(&quot;我的名字是：&quot; + this.name); &#125;&#125;person.sayHell(); 省略了冒号和function看起来更简洁; 在字面量中动态计算属性名在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 在字面量中 是无法使用的。 123456var p = &#123; name : &apos;李四&apos;, age : 20&#125;var attName = &apos;name&apos;;console.log(p[attName]) //这里 attName表示的是一个变量名。 而下面的方式使用时没有办法访问到attName这个变量的。123456var attName = &apos;name&apos;;var p = &#123; attName : &apos;李四&apos;, // 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。 age : 20&#125;console.log(p[attName]) // undefined 在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。 123456 var attName = &apos;name&apos;;var p = &#123; [attName] : &apos;李四&apos;, // 引用了变量attName。相当于添加了一个属性名为name的属性 age : 20&#125;console.log(p[attName]) // 李四 新增的方法 Object.is() ECMAScript 从第五版开始避免在 Object.prototype 上添加新的全局函数或方法，转而去考虑具体的对象类型如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。ECMAScript 6 在全局 Object 上添加了几个新的方法来轻松地完成一些特定任务。在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（）或严格比较操作符（=）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示： 123456789101112console.log(+0 == -0); // trueconsole.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN == NaN); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(5 == 5); // trueconsole.log(5 == &quot;5&quot;); // trueconsole.log(5 === 5); // trueconsole.log(5 === &quot;5&quot;); // falseconsole.log(Object.is(5, 5)); // trueconsole.log(Object.is(5, &quot;5&quot;)); // false 很多情况下 Object.is() 的表现和 = 是相同的。它们之间的区别是前者 认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 = 取决于代码的实际情况。 Object.assign()使用assign主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。assing可以把一个对象的属性和方法完整的转copy到另外一个对象中。123456789101112 var p = &#123; name : &quot;lisi&quot; age : 20, friends : [&apos;张三&apos;, &apos;李四&apos;]&#125;var p1 = &#123;&#125;;Object.assign(p1, p); //则p1中就有了与p相同的属性和方法. p1是接受者，p是提供者console.log(p1);//这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）console.log(p1.friends == p.friends); //true p1和p的friends同事指向了同一个数组。p.friends.push(&quot;王五&quot;);console.log(p1.friends); //[&apos;张三&apos;, &apos;李四&apos;, &apos;王五&apos;] assign方法可以接受任意多的提供者。意味着后面提供者的同名属性和覆盖前面提供者的属性值。 123456789101112 var p = &#123; name : &quot;lisi&quot;, age : 20, friends : [&apos;张三&apos;, &apos;李四&apos;]&#125;var p1 = &#123; name : &apos;zs&apos;,&#125;var p2 = &#123;&#125;;Object.assign(p2, p, p1); //p和p1都是提供者console.log(p2.name); // zs 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性进阶（1）]]></title>
    <url>%2F2017%2F09%2F05%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 最有意思的部分之一就是箭头函数。正如其名，箭头函数由 “箭头”（=&gt;）这种新的语法来定义。其实在别的语言中早就有了这种语法结构，不过他们叫拉姆达表达式。箭头函数语法箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。 12345678910var sum = (num1, num2) =&gt;&#123; return num1 + num2;&#125;console.log(sum(3, 4));//前面的箭头函数等同于下面的传统函数var add = function (num1, num2) &#123; return num1 + num2;&#125;console.log(add(2, 4)) 如果函数体内只有一行代码，则包裹函数体的 大括号 ({ })完全可以省略。如果有return，return关键字也可以省略。如果函数体内有多条语句，则 {} 不能省略。 12345678910 var sum = (num1, num2) =&gt; num1 + num2;console.log(sum(5, 4));//前面的箭头函数等同于下面的传统函数var add = function (num1, num2) &#123; return num1 + num2;&#125;console.log(add(2, 4));//如果这一行代码是没有返回值的，则方法的返回自也是undefinedvar foo = (num1, num2) =&gt; console.log(&quot;aaa&quot;);console.log(foo(3,4)); //这个地方的返回值就是undefined 如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。当然如果不传入参数也不可以省略 12var foo = a=&gt; a+3; //因为只有一个参数，所以()可以省略 console.log(foo(4)); // 7 如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个小括号 () 123456789 var foo = ()=&gt;(&#123;name:&quot;lisi&quot;, age:30&#125;);console.log(foo());//等同于下面的；var foo1 = ()=&gt;&#123; return &#123; name:&quot;lisi&quot;, age : 30 &#125;;&#125; 使用箭头函数实现函数自执行 12345678 var person = (name =&gt; &#123; return &#123; name: name, age: 30 &#125; &#125;)(&quot;zs&quot;);console.log(person); 箭头函数中无this绑定(No this Binding)在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。 在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式 箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。 1234567891011 var PageHandler = &#123; id: &quot;123456&quot;, init: function () &#123; document.addEventListener(&quot;click&quot;, event =&gt; this.doSomething(event.type), false); // 在此处this的和init函数内的this相同。 &#125;, doSomething: function (type) &#123; console.log(&quot;Handling &quot; + type + &quot; for &quot; + this.id); &#125;&#125;;PageHandler.init(); 看下面的一段代码： 12345 var p = &#123; foo:()=&gt;console.log(this) //此处this为window&#125;p.foo(); //输出为 window对象。 并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。 说明：1.箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。2.由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。 无arguments虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。 1234567function foo() &#123; //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。 return ()=&gt;arguments[0]; //箭头函数的返回值是foo函数的第一个参数&#125;var arrow = foo(4, 5);console.log(arrow()); // 4` 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6语法特性学习]]></title>
    <url>%2F2017%2F09%2F05%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ES6简介 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。​ 由于ES6是在2015年发布的，所以也叫ES2015。 以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、….块级作用域绑定在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：1.函数内部2.在代码块（即 { }）内部块级作用域是很多类C语言的工作机制，ECMAScript 6 引入块级声明的目的是增强 JavaScript 的灵活性，同时又能与其它编程语言保持一致。let声明使用let声明变量的语法和使用var声明的语法是一样的。但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别。1234567let a = 10;if(a &gt; 5)&#123; console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错） let b = 20; console.log(b);&#125;console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错） 注意：1.用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问2.用let声明的变量也没有声明提前这一特性。3.在同一个块中，let声明的变量也不能重复声明。4.在声明变量的时候尽量使用let，慢慢的抛弃varconst声明在 ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。123456var a = 20;if (true) &#123; const b = 20; b = 30; //错误! 常量不能重新赋值 const c; //错误！ 常量声明的同时必须赋值。&#125; 注意：1.const的特性除了声明的是常量为，其他与let一样。2.在let和const声明前的这段区域称之为暂存性死区（The Temporal Dead Zone —TDZ)。3.使用let和const声明的变量和常量不再是window的属性。 也就是说通过window.a是无法访问到的。循环中的块级绑定使用var声明的循环变量在循环结束后仍然可以访问到。 使用let声明的循环变量，在循环结束之后会立即销毁。1234for(let i = 0; i &lt; 3; i++)&#123; // 循环结束之后会立即销毁 i console.log(i); &#125;console.log(i); //此处无法访问到 i 。 循环中的函数看下面的代码，是输出10个10，而不是0，1，2，…123456789var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i); &#125;);&#125;funcs.forEach(function (func) &#123; func(); // 输出 &quot;10&quot; 共10次&#125;); 解决办法需要使用函数的自执行特性。 1234567891011var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push((function(value) &#123; return function() &#123; console.log(value); &#125; &#125;(i)));&#125;funcs.forEach(function(func) &#123; func(); // 输出 0，1，2 ... 9&#125;); 如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for … of循环中也适用; 123456789var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i); &#125;);&#125;funcs.forEach(function (func) &#123; func(); // 输出 0，1，2 ... 9&#125;) 说明：let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。 函数的新增特性 JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。1234function makeRequest(url, timeout, callback) &#123; timeout = timeout || 2000; callback = callback || function() &#123;&#125;;&#125; 其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000.ES6从语言层面面上增加了 默认值的 支持。看下面的代码：12345//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123; // 其余代码&#125; 默认参数对 arguments 对象的影响在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码： 12345678910 function foo(a, b) &#123; //非严格模式 console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true&#125;foo(1, 2); 在ES5的严格模式下，arguments只反映参数的初始值，而不再反映命名参数的变化！ 123456789101112function foo(a, b) &#123; //严格模式 &quot;use strict&quot; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 修改a的值不会影响到arguments[0]的值 console.log(arguments[1] === b); //false&#125;foo(1, 2); 当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码： 123456789 function foo(a, b = 30) &#123; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。 console.log(arguments[1] === b); //false。 b使用了默认值，所以表现的和严格模式一样。&#125;foo(1, 2); 注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。 默认参数表达式 (Default Parameter Expressions)参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码12345678function getValue() &#123; return 5;&#125;function add(first, second = getValue()) &#123; //表示使用getValue这个函数的返回值作为second的默认值。 return first + second;&#125;console.log(add(1, 1)); // 2. 调用add函数的时候，传入了第二个参数，则以传入的参数为准。console.log(add(1)); // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。 有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。 1234567891011 let value = 5;function getValue() &#123; return value++;&#125;function add(first, second = getValue()) &#123; // return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(1)); // 6console.log(add(1)); // 7console.log(add(1)); // 8 由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。 123function add(first, second = first) &#123; // 使用第一个参数作为第二个参数的默认值 return first + second;&#125; 注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。 123function add(first = second, second)) &#123; // 这种写法是错误的 return first + second;&#125; 未命名参数问题Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是略显繁琐。12345 function foo(a) &#123; console.log(a); console.log(arguments[1]) //取得传入的多余的参数。&#125;foo(2, 3); ES6，提供了一种更加优雅处理未命名参数的问题：剩余参数( Rest Parameters )语法：function a(a, … b){ }剩余参数使用三个点( … )和变量名来表示。 12345function foo(a, ...b) &#123; console.log(a); console.log(b instanceof Array); //true .多余的参数都被放入了b中。b其实就是一个数组。&#125;foo(2, 3, 4, 6); 注意：1.函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。2.虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。3.剩余参数是在函数声明的时候出现的。 函数中的扩展运算符 例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用applay方法。看下面的代码： 12let values = [25, 50, 75, 100] console.log(Math.max.apply(Math, values)); // 100 上面这种方法虽然可行，但是总是不是那么直观。使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。 123 let values = [25, 50, 75, 100]console.log(Math.max(...values)); //使用扩展运算符。相当于拆解了数组了。console.log(Math.max(...values, 200)); //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。 注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。1.剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面2.扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解js中apply和call]]></title>
    <url>%2F2017%2F08%2F05%2F%E7%90%86%E8%A7%A3js%E4%B8%ADapply%E5%92%8Ccall%2F</url>
    <content type="text"><![CDATA[call与apply的方法定义call方法:function.call(thisObj[, arg1[, arg2[, [,…argN]]]]);定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 this指定的新对象。 apply方法：function.apply(thisObj[, argArray])定义：应用某一对象的一个方法，用另一个对象替换当前对象。 apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。 call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。 12345678910function jia(a,b) &#123; alert(a+b); &#125; function jian(a,b) &#123; alert(a-b); &#125; jia.call(jian,3,1); 看最后一句代码jia.call(sub,3,1); 其实等同于 jia(3,1);结果为4;还可以这样写 jia.call(this,3,1); 结果也是一样的； 这个例子中的意思就是用 jia来替换 jian方法；如过把它用apply写的话就是jia.apply(this,[3,1]); 或者 jia.apply(jian,[3,1]);；这里要注意的是，js 中的函数其实是对象，函数名是对 Function 对象的引用。 123456789101112131415function Animal()&#123; this.name = &quot;dog&quot;; this.showName = function()&#123; alert(this.name); &#125; &#125; function Cat()&#123; this.name = &quot;Cat&quot;; &#125; var animal = new Animal(); //new新的实例var cat = new Cat(); animal.showName.call(cat,&quot;,&quot;); animal.showName.apply(cat,[]); 这段代码的意思其实就是，把 animal 的方法放到cat上执行，原来是没有showName的方法的，现在可以用了！输出的结果为‘Cat’； 1234567891011function Animal(name)&#123; this.name = name; this.showName = function()&#123; alert(this.name); &#125; &#125; function Cat(name)&#123; Animal.call(this, name); &#125; var cat = new Cat(&quot;Cat&quot;); cat.showName(); Animal.call(this) 的意思就是使用 Animal对象代替this对象，Cat对象就能够直接调用Animal的方法以及属性了,这里实现的是方法的继承；cat继承Animal里面的name； 1234567891011121314151617181920function Class10() &#123; this.showSub = function(a,b) &#123; alert(a-b); &#125; &#125; function Class11() &#123; this.showAdd = function(a,b) &#123; alert(a+b); &#125; &#125; function Class2() &#123; Class10.call(this); Class11.call(this); &#125; 很简单，使用两个 call 就实现多重继承了，当然，js的继承还有其他方法，例如使用原型链，只是在此说明call 的用法。说了call ，当然还有 apply，这两个方法基本上是一个意思，区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments; apply的一些其他巧妙用法(借鉴) （1）Math.max 可以实现得到数组中最大的一项：因为Math.max不支持Math.max([param1,param2])也就是数组，但是它支持Math.max(param1,param2…)，所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样就轻易的可以得到一个数组中的最大项（apply会将一个数组转换为一个参数接一个参数的方式传递给方法）这块在调用的时候第一个参数给了null，这是因为没有对象去调用这个方法，我只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个null过去。用这种方法也可以实现得到数组中的最小项：Math.min.apply(null,array) （2）Array.prototype.push可以实现两个数组的合并同样push方法没有提供push一个数组，但是它提供了push(param1,param2…paramN)，同样也可以用apply来转换一下这个数组，即：1231.var arr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);2.var arr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;);3.Array.prototype.push.apply(arr1,arr2); 得到合并后数组的长度，因为push就是返回一个数组的长度也可以这样理解，arr1调用了push方法，参数是通过apply将数组转换为参数列表的集合 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穷忙的人生（转自阮一峰）]]></title>
    <url>%2F2017%2F08%2F04%2F%E7%A9%B7%E5%BF%99%E7%9A%84%E4%BA%BA%E7%94%9F%EF%BC%88%E8%BD%AC%E8%87%AA%E9%98%AE%E4%B8%80%E5%B3%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[香港曾经有一档电视真人秀，叫做《穷富翁大作战》，专门邀请富人体验穷人的生活。有一期节目的主人公是田北辰。他的父亲田元灏是香港纺织界的头面人物，人称”一代裤王”。他本科毕业于康奈尔大学电子工程专业，又去读了哈佛大学 MBA，回到香港后创办了服装品牌 G2000 和 U2，是那种很努力的”富二代”。 他崇尚自由竞争和人生奋斗，座右铭是”如果你今天对自己满意，明天就会被淘汰”，一直宣扬 “如果你有斗志，弱者也可以变成强者。”但是，参加了这次电视节目以后，他的观点发生了180度转变，对着电视镜头公开说：“这个社会在极严厉地惩罚，那些没条件读书的人。穷人一輩子都不可能变有钱人。在強弱悬殊的情况下，只有弱者越弱，越來越慘！” 2、田北辰为什么改变观点，认为穷人不可能翻身呢？原来，节目组请他体验了两天清洁工的生活，薪资是每小时25港币，每天的生活费只有50港币，住在只有1.6平方米的”笼屋”，月租1350港币。所谓”笼屋”，外面看着像衣橱，门一拉开，里面只能放下一张床，关上门四面全挨着木板墙，东西都挂在墙上。就是这种条件，房产中介还称它为”豪华笼屋”，因为还有600港币的更低档，就是在马桶上放一块木板睡人。上班时间是早上五点，地铁头班车还没开，只能坐夜宵巴士，车费是13港币，田北辰惊呼：”每天生活费只有50港币，这怎么坐得起！”开始工作后，好不容易熬到中午吃饭，但只有15元的预算，大部分的饭要20元，他最后只能坐在街边的楼梯上，就着白开水嚼干粮。吃完了，还要抓紧时间躺在花坛上休息一会。做满9个小时，就可以下班了。但是，真正的清洁工为了养家户口，还要去做夜班，一天在外近17个小时，只能睡5、6个小时。田北辰说，因为只有两天，自己才有斗志坚持下去，如果要做一个月，甚至半年，那就太绝望了！“没有学历、技术的人，为了活下去，不是住笼屋就是要工作到半夜，对于他们，最重要事情是下一顿吃什么，怎么会有时间和精力去思考未来怎么发展？来来去去都在死胡同！” 3、每天忙于工作，干到累死，但还是很穷，只能租屋住，没有自己的积蓄，一旦停止工作或者生病在床，生活来源顿时就成问题。田北辰体验的这种人生，社会学家早就注意到了，起名为”穷忙族”，百度百科的定义如下。“穷忙族是指那些薪水不多，整日奔波劳动，却始终无法摆脱贫穷的人。最早出现于上世纪90年代的美国，指拼命工作仍然无法摆脱最低水准生活的人们。日本经济学家门仓贵史在《穷忙族》一书中，他对”穷忙族”下的定义是：每天繁忙地工作却依然不能过上富裕生活的人。” 不仅香港有”穷忙族”，内地也越来越多。举例来说，根据报道，2016年上海送外卖最多的送餐员，是一位叫做何文妹的中年女性，至少送出了12214单。即使全年无休，每天平均也要33单，从午饭时间一直送到深夜，一刻不停。电瓶车的电瓶，一天要准备6组。车上插着两个手机，一个导航，一个接单。这种强度的劳动，每年能有多少收入呢？每单的送餐费是8元，这就是说，何文妹一年的送餐总收入在10万元左右。扣除电瓶费、车辆维护费、通信费等等以后，净收入大概还能剩下8万多元。这是”送餐王”的收入水平，大部分送餐员的收入，应该远不如她，可能只有一半左右。上海的底层劳动者，收入基本就是这种水平。他们还要用这些钱支付房租。每天下班回到家，累得就想睡觉，睁开眼就要去上班，日复一日，人生的出路在哪里？4、将来的”穷忙族”，不仅是低技能的底层劳动者，还将包括很多受过高等教育、写字楼工作的白领。年轻人如果没有家庭支持，想要靠自己的努力出人头地，会变得越来越难。因为单靠工资收入，已经不足以积累财富了。有一项统计说：“1993年属于低等收入者的城里人，到了1995年有43%都能向上爬。而相比之下，2011年属于低等收入者的城里人，到了2013年只有20%摘掉最底层的帽子。一个不恰当的比喻，如果上世纪90年代算是城市穷人的黄金时代的话，那今天这种好日子已经结束了。”“一方面，城里穷人越来越难走出贫困；另一方面，城里富人的位置也坐得越来越稳。1993-1995年，城里的高等收入者有64%的概率能一直当富人。而到了2011-2013年，高等收入者竟然有84%的概率能保证自己不被从富人列表中除名。” 上面的数字就是说，如果你是穷人，80%的概率以后你还是穷人；如果你是富人，84%的概率是以后你还是富人。一个台湾人感叹说：“那种奴隶化的生活（长时间工作，却仅能勉强满足温饱）才是历史的常态。过去三十年社会阶层的大幅流动，是历史的不正常，现在开始回归常态。99%的我们，都面临着这种大趋势的吞噬：你的工资不变，但房价和物价却是越来越高，于是你必需花更多时间来挣钱，甚至一天做二份工，最后成为没有自己时间的奴隶。” 总的来看，下一代青年不太可能有上一代那么多机会。经济增长率已经开始放缓，还将继续放缓，人口增长高峰已经过去，老龄化越来越严重，老人的消费远不及年轻人。矿业、制造业、零售业、证券业……除了高科技，几乎所有行业都不会有以前那么高的增长率。上一代人赶上了中国经济起飞，还拥有依靠房地产翻身的机会，但是下一代人不会再有这样的机会。你现在买入一套房子，十年后价值翻上十倍，完全是零可能。越来越多的人将会发现，即使从小就努力学习，从很好的学校毕业，后来努力工作，但迎接他们的将是”长久的低薪、难升迁的职场、高昂的物价、买不起的房子……”。尽管你很努力，待人友善，有公德心，但就是挣不到钱，只能在社会的底层挣扎。5、2015年，社会工作者藤田孝典调查日本的老人问题。他发现，很多老人年轻时都拿过中产阶级的薪水（400万日元），但是现在已经沦落到社会的底层，过着非常困苦的生活。”七老八十还要在大热天当廉价劳工，因经济拮据而妻离子散，唯有独居烂屋，孤零零度过晚年。”藤田孝典将这些老人称为”下流老人”（底层老人）。他称，日本的下流老人以后可能会达到1亿人。要知道，日本现在的总人口也只有1.27亿。下流老人有三大特征。（1）收入极低，即使政府提供补助费，也难以维持健康饮食，以及一般家庭应有的生活；（2）存款不足，老人必须提心吊胆地过活，一旦碰到突发事故或慢性病，日常已经捉襟见肘的生活，就会面临崩溃危险；（3）老无所依，子女连自己都养不起，更遑论赡养老人。日本不少老人因家庭破碎而长期独居，平日缺乏与亲朋邻里的交流，关系疏离，一旦发生意外无人照应。在晚年失去可以依靠的人，是下流老人最悲苦的特征。下流老人的根源就是，钱花光了，人还没死。日本媒体还发明了一个词”老后破产”，这就是长寿的恶梦。现代科技如此发达，人的寿命越来越长，可是工作又积累不了财富，于是，”清贫青年，流沙中年，下流老人”就成了大多数人必然的命运归宿。感觉自己就是在穷忙，越穷越忙，越忙越穷！ 穷忙族测试测试，你是”穷忙族”吗？1、一周工作超过54小时，但是看不到前途2、一年内未曾加薪3、三年内未曾升职4、薪水很低，到月底总是很艰难5、积蓄少，无力置产6、工资不低，但花钱很大手笔7、收入不低，但内心没有安全感以上七项，如果你有两项或者两项以上，那么BINGO!恭喜你，你属于”穷忙族”了！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火星文-正则表达式（学习）转载]]></title>
    <url>%2F2017%2F07%2F19%2F%E7%81%AB%E6%98%9F%E6%96%87-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%AD%A6%E4%B9%A0%EF%BC%89%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个字符串是否含有某种子串、将匹配的子串做替换或者从某个字符串中取出符合某个条件的子串等。正则表达式的创建方式1234 var reg = /pattern/flags// 字面量创建方式var reg = new RegExp(pattern,flags);//实例创建方式 pattern:正则表达式flags:标识(修饰符)标识主要包括：i 忽略大小写匹配m 多行匹配，即在到达一行文本末尾时还会继续寻常下一行中是否与正则匹配的项g 全局匹配 模式应用于所有字符串，而非在找到第一个匹配项时停止 字面量创建方式和构造函数创建方式的区别 字面量创建方式不能进行字符串拼接，实例创建方式可以12345var regParam = &apos;cm&apos;;var reg1 = new RegExp(regParam+&apos;1&apos;);var reg2 = /regParam/;console.log(reg1); // /cm1/console.log(reg2); // /regParam/ 字面量创建方式特殊含义的字符不需要转义，实例创建方式需要转义123var reg1 = new RegExp(&apos;\d&apos;); // /d/ var reg2 = new RegExp(&apos;\\d&apos;) // /\d/var reg3 = /\d/; // /\d/ 元字符1234567891011121314151617\d : 0-9之间的任意一个数字 \d只占一个位置\w : 数字，字母 ，下划线 0-9 a-z A-Z _\s : 空格或者空白等\D : 除了\d\W : 除了\w\S : 除了\s . : 除了\n之外的任意一个字符 \ : 转义字符 | : 或者() : 分组\n : 匹配换行符\b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 =&gt; 不占用字符串位数 ^ : 限定开始位置 =&gt; 本身不占位置 $ : 限定结束位置 =&gt; 本身不占位置[a-z] : 任意字母 []中的表示任意一个都可以[^a-z] : 非字母 []中^代表除了[abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符 代表次数的量词元字符123456* : 0到多个+ : 1到多个? : 0次或1次 可有可无&#123;n&#125; : 正好n次；&#123;n,&#125; : n到多次&#123;n,m&#125; : n次到m次 量词出现在元字符后面 如\d+，限定出现在前面的元字符的次数123456789var str = &apos;1223334444&apos;;var reg = /\d&#123;2&#125;/g;var res = str.match(reg);console.log(res) //[&quot;12&quot;, &quot;23&quot;, &quot;33&quot;, &quot;44&quot;, &quot;44&quot;]var str =&apos; 我是空格君 &apos;;var reg = /^\s+|\s+$/g; //匹配开头结尾空格var res = str.replace(reg,&apos;&apos;);console.log(&apos;(&apos;+res+&apos;)&apos;) //(我是空格君) 一般[]中的字符没有特殊含义 如+就表示+,但是像\w这样的还是有特殊含义的;1234567var str1 = &apos;abc&apos;;var str2 = &apos;dbc&apos;;var str3 = &apos;.bc&apos;;var reg = /[ab.]bc/; //此时的.就表示.reg.test(str1) //truereg.test(str2) //falsereg.test(str3) //true []中，不会出现两位数; 12345678910[12]表示1或者2 不过[0-9]这样的表示0到9 [a-z]表示a到z例如:匹配从18到65年龄段所有的人var reg = /[18-65]/; // 这样写对么reg.test(&apos;50&apos;) //Uncaught SyntaxError: Invalid regular expression: /[18-65]/: Range out of order in character class//聪明的你想可能是8-6这里不对，于是改成[16-85]似乎可以匹配16到85的年龄段的，但实际上发现这也是不靠谱的实际上我们匹配这个18-65年龄段的正则我们要拆开来匹配我们拆成3部分来匹配 18-19 20-59 60-65 reg = /(18|19)|([2-5]\d)|(6[0-5])/; ()的提高优先级功能:凡是有|出现的时候，我们一定要注意是否有必要加上()来提高优先级；()的分组 重复子项 (两个放到一起说);分组：只要正则中出现了小括号那么就会形成一份分组只要有分组，exec(match)和replace中的结果就会发生改变(后边的正则方法中再说) 分组的引用(重复子项) :只要在正则中出现了括号就会形成一个分组，我们可以通过\n (n是数字代表的是第几个分组)来引用这个分组，第一个小分组我们可以用\1来表示例如：求出这个字符串’abAAbcBCCccdaACBDDabcccddddaab’中出现最多的字母,并求出出现多少次(忽略大小写)。123456789101112131415var str = &apos;abbbbAAbcBCCccdaACBDDabcccddddaab&apos;;str = str.toLowerCase().split(&apos;&apos;).sort(function(a,b)&#123;return a.localeCompare(b)&#125;).join(&apos;&apos;);var reg = /(\w)\1+/ig;var maxStr = &apos;&apos;;var maxLen = 0;str.replace(reg,function($0,$1)&#123; var regLen = $0.length; if(regLen&gt;maxLen)&#123; maxLen = regLen; maxStr = $1; &#125;else if(maxLen == regLen)&#123; maxStr += $1; &#125;&#125;)console.log(`出现最多的字母是$&#123;maxStr&#125;,共出现了$&#123;maxLen&#125;次`); 当我们加()只是为了提高优先级而不想捕获小分组时，可以在()中加?:来取消分组的捕获; 123456var str = &apos;aaabbb&apos;;var reg = /(a+)(?:b+)/;var res =reg.exec(str);console.log(res)//[&quot;aaabbb&quot;, &quot;aaa&quot;, index: 0, input: &quot;aaabbb&quot;]//只捕获第一个小分组的内容 正则运算符的优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。相同优先级的会从左到右进行运算，不同优先级的运算先高后低。下面是常见的运算符的优先级排列,依次从最高到最低说明各种正则表达式运算符的优先级顺序：1234567\ : 转义符(), (?:), (?=), [] =&gt; 圆括号和方括号*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125; =&gt; 量词限定符^, $, \任何元字符、任何字符 | =&gt; 替换，&quot;或&quot;操作字符具有高于替换运算符的优先级，一般用 | 的时候，为了提高 | 的优先级，我们常用()来提高优先级如： 匹配 food或者foot的时候 reg = /foo(t|d)/ 这样来匹配 正则的特性贪婪性:所谓的贪婪性就是正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。如果我们想尽可能的少的去捕获符合条件的字符串的话，可以在量词元字符后加”?”;懒惰性:懒惰性则是正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。如果想捕获目标中所有符合条件的字符串的话，我们可以用标识符g来标明是全局捕获; 123456789var str = &apos;123aaa456&apos;;var reg = /\d+/; //只捕获一次,一次尽可能多的捕获var res = str.match(reg)console.log(res)// [&quot;123&quot;, index: 0, input: &quot;123aaa456&quot;]reg = /\d+?/g; //解决贪婪性、懒惰性res = str.match(reg)console.log(res)// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;] 和正则相关的一些方法 这里我们只介绍test、exec、match和replace这四个方法;reg.test(str) 用来验证字符串是否符合正则 符合返回true 否则返回false123var str = &apos;abc&apos;;var reg = /\w+/;console.log(reg.test(str)); //true reg.exec() 用来捕获符合规则的字符串123456789101112var str = &apos;abc123cba456aaa789&apos;;var reg = /\d+/;console.log(reg.exec(str))// [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;];console.log(reg.lastIndex)// lastIndex : 0 reg.exec捕获的数组中 // [0:&quot;123&quot;,index:3,input:&quot;abc123cba456aaa789&quot;]0:&quot;123&quot; 表示我们捕获到的字符串index:3 表示捕获开始位置的索引input 表示原有的字符串 当我们用exec进行捕获时，如果正则没有加’g’标识符，则exec捕获的每次都是同一个，当正则中有’g’标识符时 捕获的结果就不一样了,我们还是来看刚刚的例子123456789101112131415161718192021222324var str = &apos;abc123cba456aaa789&apos;;var reg = /\d+/g; //此时加了标识符gconsole.log(reg.lastIndex)// lastIndex : 0 console.log(reg.exec(str))// [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]console.log(reg.lastIndex)// lastIndex : 6console.log(reg.exec(str))// [&quot;456&quot;, index: 9, input: &quot;abc123cba456aaa789&quot;]console.log(reg.lastIndex)// lastIndex : 12console.log(reg.exec(str))// [&quot;789&quot;, index: 15, input: &quot;abc123cba456aaa789&quot;]console.log(reg.lastIndex)// lastIndex : 18console.log(reg.exec(str))// nullconsole.log(reg.lastIndex)// lastIndex : 0 每次调用exec方法时,捕获到的字符串都不相同lastIndex ：这个属性记录的就是下一次捕获从哪个索引开始。当未开始捕获时，这个值为0。如果当前次捕获结果为null。那么lastIndex的值会被修改为0.下次从头开始捕获。而且这个lastIndex属性还支持人为赋值。 exec的捕获还受分组()的影响 12345var str = &apos;2017-01-05&apos;;var reg = /-(\d+)/g// [&quot;-01&quot;, &quot;01&quot;, index: 4, input: &quot;2017-01-05&quot;]&quot;-01&quot; : 正则捕获到的内容&quot;01&quot; : 捕获到的字符串中的小分组中的内容 str.match(reg) 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null 1234567//match和exec的用法差不多var str = &apos;abc123cba456aaa789&apos;;var reg = /\d+/;console.log(reg.exec(str));//[&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]console.log(str.match(reg));//[&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;] 上边两个方法console的结果有什么不同呢？二个字符串是一样滴。当我们进行全局匹配时，二者的不同就会显现出来了. 123456var str = &apos;abc123cba456aaa789&apos;;var reg = /\d+/g;console.log(reg.exec(str));// [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]console.log(str.match(reg));// [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;] 当全局匹配时，match方法会一次性把符合匹配条件的字符串全部捕获到数组中,如果想用exec来达到同样的效果需要执行多次exec方法。 我们可以尝试着用exec来简单模拟下match方法的实现。1234567891011121314151617181920212223String.prototype.myMatch = function (reg) &#123; var arr = []; var res = reg.exec(this); if (reg.global) &#123; while (res) &#123; arr.push(res[0]); res = reg.exec(this) &#125; &#125;else&#123; arr.push(res[0]); &#125; return arr;&#125;var str = &apos;abc123cba456aaa789&apos;;var reg = /\d+/;console.log(str.myMatch(reg))// [&quot;123&quot;]var str = &apos;abc123cba456aaa789&apos;;var reg = /\d+/g;console.log(str.myMatch(reg))// [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;] 此外，match和exec都可以受到分组()的影响，不过match只在没有标识符g的情况下才显示小分组的内容，如果有全局g，则match会一次性全部捕获放到数组中 123456789101112131415var str = &apos;abc&apos;;var reg = /(a)(b)(c)/;console.log( str.match(reg) );// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;]console.log( reg.exec(str) );// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;]当有全局g的情况下var str = &apos;abc&apos;;var reg = /(a)(b)(c)/g;console.log( str.match(reg) );// [&quot;abc&quot;]console.log( reg.exec(str) );// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;] str.replace() 这个方法大家肯定不陌生，现在我们要说的就是和这个方法和正则相关的东西了。 1234567891011121314151617181920212223242526272829正则去匹配字符串，匹配成功的字符去替换成新的字符串写法：str.replace(reg,newStr);var str = &apos;a111bc222de&apos;;var res = str.replace(/\d/g,&apos;Q&apos;)console.log(res)// &quot;aQQQbcQQQde&quot;replace的第二个参数也可以是一个函数str.replace(reg,fn);var str = &apos;2017-01-06&apos;;str = str.replace(/-\d+/g,function()&#123; console.log(arguments)&#125;)控制台打印结果：[&quot;-01&quot;, 4, &quot;2017-01-06&quot;][&quot;-06&quot;, 7, &quot;2017-01-06&quot;]&quot;2017undefinedundefined&quot;从打印结果我们发现每一次输出的值似乎跟exec捕获时很相似，既然与exec似乎很相似，那么似乎也可以打印出小分组中的内容喽 var str = &apos;2017-01-06&apos;;str = str.replace(/-(\d+)/g,function()&#123; console.log(arguments)&#125;)[&quot;-01&quot;, &quot;01&quot;, 4, &quot;2017-01-06&quot;][&quot;-06&quot;, &quot;06&quot;, 7, &quot;2017-01-06&quot;]&quot;2017undefinedundefined&quot; 从结果看来我们的猜测没问题。此外，我们需要注意的是，如果我们需要替换replace中正则找到的字符串，函数中需要一个返回值去替换正则捕获的内容。 通过replace方法获取url中的参数的方法 123456789101112131415(function(pro)&#123; function queryString()&#123; var obj = &#123;&#125;, reg = /([^?&amp;#+]+)=([^?&amp;#+]+)/g; this.replace(reg,function($0,$1,$2)&#123; obj[$1] = $2; &#125;) return obj; &#125; pro.queryString = queryString;&#125;(String.prototype));// 例如 url为 https://www.baidu.com?a=1&amp;b=2// window.location.href.queryString();// &#123;a:1,b:2&#125; 零宽断言 用于查找在某些内容(但并不包括这些内容)之前或之后的东西，如\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。 在使用正则表达式时，捕获的内容前后必须是特定的内容，而我们又不想捕获这些特定内容的时候，零宽断言就可以派上用场了。 零宽度正预测先行断言 (?=exp)零宽度负预测先行断言 (?!exp)零宽度正回顾后发断言 (?&lt;=exp)零宽度负回顾后发断言 (?&lt;!exp)这四胞胎看着名字好长，给人一种好复杂好难的感觉，我们还是挨个来看看它们究竟是干什么的吧。 (?=exp) 这个简单理解就是说字符出现的位置的右边必须匹配到exp这个表达式。 1234567891011var str = &quot;i&apos;m singing and dancing&quot;;var reg = /\b(\w+(?=ing\b))/gvar res = str.match(reg);console.log(res)// [&quot;sing&quot;, &quot;danc&quot;]注意一点，这里说到的是位置，不是字符。var str = &apos;abc&apos;;var reg = /a(?=b)c/;console.log(res.test(str)); // false 这个看起来似乎是正确的，实际上结果是falsereg中a(?=b)匹配字符串’abc’ 字符串a的右边是b这个匹配没问题,接下来reg中a(?=b)后边的c匹配字符串时是从字符串’abc’中a的后边b的前边的这个位置开始匹配的，这个相当于/ac/匹配’abc’,显然结果是false了; (?!exp) 这个就是说字符出现的位置的右边不能是exp这个表达式。 123var str = &apos;nodejs&apos;;var reg = /node(?!js)/;console.log(reg.test(str)) // false (?&lt;=exp) 这个就是说字符出现的位置的前边是exp这个表达式。 123var str = &apos;￥998$888&apos;;var reg = /(?&lt;=\$)\d+/;console.log(reg.exec(str)) //888 (?&lt;!exp) 这个就是说字符出现的位置的前边不能是exp这个表达式。 123var str = &apos;￥998$888&apos;;var reg = /(?&lt;!\$)\d+/;console.log(reg.exec(str)) //998 ###（感谢）转载自：http://www.cnblogs.com/chenmeng0818/p/6370819.html 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0 + Element + vue-cli + resource ,增删改查实例]]></title>
    <url>%2F2017%2F07%2F10%2Fvue2-0-Element-vue-cli-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[今天，准备写一个关于前后台数据交互，用vue2.0 + Element + vue-cli + resource开发的一个增删改查的实例！注意：项目源码：1https://github.com/sky-xsk/element-vue-resource- 还有一点注意的是：我用的是公司内部提供的api，所以不在公司内部，是看不到效果的，最主要的还是对源码的参考！放心我会附上图片效果的!这个简单实例的开发环境是vue2.0 + Element + vue-cli + resource;至于具体安装步骤和环境的搭建我这里不做过多的赘述！直接会把代码写出来，必要时做一些详细的分析！ 1.首先是模板代码，这里用到的就是ElementUI；地址http://element.eleme.io/，最近又出了react的版本！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;!-- 操作 --&gt; &lt;ul class=&quot;btn-edit fr&quot;&gt; &lt;li &gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogCreateVisible = true&quot;&gt;添加用户&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;delete&quot; :disabled=&quot;selected.length == 0&quot; @click=&quot;del_all()&quot;&gt;删除&lt;/el-button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;el-table :data=&quot;users&quot; v-loading=&quot;loading&quot; element-loading-text=&quot;拼命加载中...&quot; @sort-change=&quot;tableSortChange&quot; @selection-change=&quot;tableSelectionChange&quot; border stripe width=&quot;100%&quot; height=&quot;443&quot;&gt; &lt;el-table-column type=&quot;selection&quot; width=&quot;60&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;username&quot; sortable label=&quot;姓名&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;email&quot; label=&quot;邮箱&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;phone&quot; label=&quot;手机&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column inline-template prop=&quot;create_time&quot; sortable label=&quot;时间&quot;&gt; &lt;div&gt;&#123;&#123; row.create_time | moment(&apos;YYYY年MM月DD日 HH:mm:ss&apos;)&#125;&#125;&lt;/div&gt; &lt;/el-table-column&gt; &lt;el-table-column inline-template label=&quot;操作&quot;&gt; &lt;span&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;removed(row)&quot;&gt;删除&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&quot;small&quot; @click=&quot;setCurrent(row)&quot;&gt;编辑&lt;/el-button&gt; &lt;/span&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--分页begin--&gt; &lt;el-pagination class=&quot;tc mg&quot; :current-page=&quot;filter.page&quot; :page-sizes=&quot;[10, 20, 50]&quot; :page-size=&quot;filter.per_page&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total_rows&quot; @size-change=&quot;pageSizeChange&quot; @current-change=&quot;pageCurrentChange&quot;&gt; &lt;/el-pagination&gt; &lt;!--分页end--&gt; &lt;/div&gt; &lt;!-- 修改用户 begin--&gt; &lt;el-dialog title=&quot;修改用户信息&quot; v-model=&quot;dialogUpdateVisible&quot; :close-on-click-modal=&quot;false&quot; :close-on-press-escape=&quot;false&quot;&gt; &lt;el-form id=&quot;#update&quot; :model=&quot;update&quot; ref=&quot;update&quot; label-width=&quot;100px&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;update.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot; prop=&quot;phone&quot;&gt; &lt;el-input v-model=&quot;update.phone&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt; &lt;el-input v-model=&quot;update.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogUpdateVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; :loading=&quot;updateLoading&quot; @click=&quot;updateUser&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- 创建用户 begin--&gt; &lt;el-dialog title=&quot;创建用户&quot; v-model=&quot;dialogCreateVisible&quot; :close-on-click-modal=&quot;false&quot; :close-on-press-escape=&quot;false&quot; @close=&quot;reset&quot; &gt; &lt;el-form id=&quot;#create&quot; :model=&quot;create&quot; :rules=&quot;rules&quot; ref=&quot;create&quot; label-width=&quot;100px&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;el-input v-model=&quot;create.username&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;create.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;create.password&quot; type=&quot;password&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkpass&quot;&gt; &lt;el-input v-model=&quot;create.checkpass&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot; prop=&quot;phone&quot;&gt; &lt;el-input v-model=&quot;create.phone&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt; &lt;el-input v-model=&quot;create.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogCreateVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; :loading=&quot;createLoading&quot; @click=&quot;createUser&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt; 2.接下来是js部分，同时也是比较重要的地方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289&lt;script&gt;function getuuid()&#123; var uid = []; var hexDigits = &quot;0123456789abcdefghijklmnopqrst&quot;; for (var i = 0; i &lt; 32; i++) &#123; uid[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1); &#125; uid[6] = &quot;4&quot;; uid[15] = hexDigits.substr((uid[15] &amp; 0x3) | 0x8, 1); var uuid = uid.join(&quot;&quot;); return uuid;&#125;export default &#123; name: &apos;app&apos;, data: function() &#123; //表单验证 var validatePass = (rule, value, callback) =&gt; &#123; if (value === &apos;&apos;) &#123; callback(new Error(&apos;请再次输入密码&apos;)); &#125; else if (value !== this.create.password) &#123; callback(new Error(&apos;两次输入密码不一致!&apos;)); &#125; else &#123; callback(); &#125; &#125;; return &#123; url: &apos;&apos;, //此处是api的地址，因为此处是公司内部地址，这里就不写上了 users: [], keywords:&apos;&apos;, select:&apos;&apos;, filter:&#123; name:&apos;&apos;, username:&apos;&apos;, phone:&apos;&apos;, per_page: 10, // 页大小 page: 1, // 当前页 sorts:&apos;&apos; &#125;, loading: true, selected:[], dialogCreateVisible: false, //创建对话框的显示状态 dialogUpdateVisible: false, //编辑对话框的显示状态 createLoading: false, updateLoading: false, update:&#123; name: &apos;&apos;, phone: &apos;&apos;, email: &apos;&apos;, is_active: true &#125;, total_rows: 0, create: &#123; id: &apos;&apos;, username: &apos;&apos;, name: &apos;&apos;, password: &apos;&apos;, checkpass: &apos;&apos;, phone: &apos;&apos;, email: &apos;&apos;, is_active: true &#125;, rules: &#123; //表单验证规则 name: [ &#123; required: true, message: &apos;请输入姓名&apos;, trigger: &apos;blur&apos; &#125;, &#123; min: 3, max: 15, message: &apos;长度在 3 到 15 个字符&apos;&#125; ], username: [ &#123; required: true, message: &apos;请输入用户名&apos;, trigger: &apos;blur&apos; &#125;, &#123; min: 3, max: 25, message: &apos;长度在 3 到 25 个字符&apos;&#125;, &#123; pattern:/^[A-Za-z0-9]+$/, message: &apos;用户名只能为字母和数字&apos;&#125; ], password: [ &#123; required: true, message: &apos;请输入密码&apos;, trigger: &apos;blur&apos; &#125;, &#123; min: 6, max: 25, message: &apos;长度在 6 到 25 个字符&apos;&#125; ], checkpass: [ &#123; required: true, message: &apos;请再次输入密码&apos;, trigger: &apos;blur&apos; &#125;, &#123; validator: validatePass&#125; ], email: [ &#123; type: &apos;email&apos;, message: &apos;邮箱格式不正确&apos;&#125; ], phone:[ &#123; pattern:/^1[34578]\d&#123;9&#125;$/, message: &apos;请输入中国国内的手机号码&apos;&#125; ] &#125;, &#125;; &#125;, mounted()&#123; this.getUsers(); &#125;, methods:&#123; //分页 searchFieldChange(val) &#123; this.placeholder=placeholders[val]; console.log(`搜索字段： $&#123;val&#125; `); &#125;, pageSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); this.filter.per_page = val; this.getUsers(); &#125;, pageCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); this.filter.page = val; this.getUsers(); &#125;, //选则相关 tableSelectionChange(val) &#123; this.selected = val; //console.log(val) &#125;, //和排序相关 tableSortChange(val) &#123; //console.log(`排序属性: $&#123;val.prop&#125;`); //console.log(`排序: $&#123;val.order&#125;`); if(val.prop!=null)&#123; if(val.order==&apos;descending&apos;)&#123; this.filter.sorts = &apos;-&apos;+val.prop; &#125; else&#123; this.filter.sorts = &apos;&apos;+val.prop; &#125; &#125; else&#123; this.filter.sorts = &apos;&apos;; &#125; this.getUsers(); &#125;, // 创建用户 createUser()&#123; // 主动校验 this.$refs.create.validate((valid) =&gt; &#123; if (valid) &#123; this.create.id=getuuid(); this.createLoading=true; var resource = this.$resource(this.url); resource.save(this.create) .then((response) =&gt; &#123; this.$message.success(&apos;创建用户成功！&apos;); this.dialogCreateVisible=false; this.createLoading=false; this.reset(); this.getUsers(); &#125;) .catch((response) =&gt; &#123; var data=response.data; if(data instanceof Array)&#123; this.$message.error(data[0][&quot;message&quot;]); &#125; else if(data instanceof Object)&#123; this.$message.error(data[&quot;message&quot;]); &#125; this.createLoading=false; &#125;); &#125; else &#123; return false; &#125; &#125;); &#125;, // 重置表单 reset() &#123; this.$refs.create.resetFields(); &#125;, setCurrent(user)&#123; this.currentId=user.id; this.update.name=user.name; this.update.phone=user.phone; this.update.email=user.email; this.update.is_active=user.is_active; this.dialogUpdateVisible=true; &#125;, // 更新用户资料 updateUser() &#123; this.$refs.update.validate((valid) =&gt; &#123; if (valid) &#123; this.updateLoading=true; var actions = &#123; update: &#123;method: &apos;patch&apos;&#125; &#125; var resource = this.$resource(this.url,&#123;&#125;,actions); resource.update(&#123;&quot;ids&quot;:this.currentId&#125;,this.update) .then((response) =&gt; &#123; this.$message.success(&apos;修改用户资料成功！&apos;); this.dialogUpdateVisible=false; this.updateLoading=false; this.getUsers(); &#125;) .catch((response) =&gt; &#123; var data=response.data; console.log(data); if(data instanceof Array)&#123; this.$message.error(data[0][&quot;message&quot;]); &#125; else if(data instanceof Object)&#123; this.$message.error(data[&quot;message&quot;]); &#125; this.updateLoading=false; &#125;); &#125; else &#123; return false; &#125; &#125;); &#125;, //批量删除 del_all()&#123; this.$confirm(&apos;此操作将永久删除 &apos; + this.selected.length + &apos; 条分区信息, 是否继续?&apos;, &apos;提示&apos;, &#123; type: &apos;warning&apos; &#125;) .then(() =&gt; &#123; var ids = []; //提取选中项的id $.each(this.selected, (i, alarm) =&gt; &#123; ids.push(alarm.id); &#125;); // 向请求服务端删除 var resource = this.$resource(this.url); resource.remove(&#123; ids: ids.join(&quot;,&quot;) &#125;) .then((response) =&gt; &#123; this.$message.success(&apos;删除了&apos; + this.selected.length + &apos;条分区信息!&apos;); this.getUsers(); &#125;) .catch((response) =&gt; &#123; this.$message.error(&apos;删除失败!&apos;); &#125;); &#125;) .catch(() =&gt; &#123; this.$Message(&apos;已取消操作!&apos;); &#125;); &#125;, //删除单个用户 removed(user)&#123; this.$confirm(&apos;此操作将永久删除用户 &apos; + user.username + &apos;, 是否继续?&apos;, &apos;提示&apos;, &#123; type: &apos;warning&apos; &#125;) .then(() =&gt; &#123; // 向请求服务端删除 var resource = this.$resource(this.url + &quot;&#123;/id&#125;&quot;); resource.delete(&#123; id: user.id &#125;) .then((response) =&gt; &#123; this.$message.success(&apos;成功删除了用户&apos; + user.username + &apos;!&apos;); this.getUsers(); &#125;) .catch((response) =&gt; &#123; this.$message.error(&apos;删除失败!&apos;); &#125;); &#125;) .catch(() =&gt; &#123; this.$message.info(&apos;已取消操作!&apos;); &#125;); &#125;, //筛选 query()&#123; this.filter.name=&apos;&apos;; this.filter.username=&apos;&apos;; this.filter.phone=&apos;&apos;; this.filter[this.select]=this.keywords; this.getUsers(); &#125;, //获取用户列表 getUsers() &#123; this.loading = true; var resource = this.$resource(this.url); resource.query(this.filter) .then((response) =&gt; &#123; this.users = response.data.datas; this.total_rows = response.data.total_rows; this.loading = false; &#125;) .catch((response)=&gt; &#123; this.$message.error(&apos;错了哦，这是一条错误消息&apos;); this.loading = false; &#125;); &#125; &#125;, &#125;&lt;/script&gt; 具体解析，我就写在注释里！下面上几张效果图！注意：项目源码：1https://github.com/sky-xsk/element-vue-resource- 如果有帮助，请要吝啬，给个‘star’，就是对我的鼓励！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结几种数组去重的方法，敲一遍代码]]></title>
    <url>%2F2017%2F07%2F07%2F%E6%80%BB%E7%BB%93%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%95%B2%E4%B8%80%E9%81%8D%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[这里总结集中数组去重的方法：自己动手敲一敲，精神一整天！ 1.第一种方法：（我经常用的，好理解）1234567891011function arrAlong(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] == arr[j]) &#123; arr.splice(j, 1); j--; &#125; &#125; &#125; return arr;&#125;; 利用对数组的进行双重遍历，对数组的位置的数值进行比较，删除相同的元素，返回去重之后的数组！2.第二种方法 123456789function arrAlong(arr) &#123; var ret = []; for (var i = 0, j = arr.length; i &lt; j; i++) &#123; if (ret.indexOf(arr[i]) === -1) &#123; ret.push(arr[i]); &#125; &#125; return ret;&#125; 利用indexof的特性，进行操作！3.第三种方法123456789function arrAlong(arr) &#123; var ret = []; arr.forEach(function(e, i, arr) &#123; if (arr.indexOf(e) === i) &#123; ret.push(e); &#125; &#125;); return ret;&#125; 数组下标判断法, 遍历数组，利用indexOf判断元素的值是否与当前索引相等，如相等则加入4.第四中方法1234567891011function arrAlong(arr) &#123; var tmp = &#123;&#125;, ret = []; for (var i = 0, j = arr.length; i &lt; j; i++) &#123; if (!tmp[arr[i]]) &#123; tmp[arr[i]] = 1; ret.push(arr[i]); &#125; &#125; return ret;&#125; 遍历数组，利用object对象保存数组值，判断数组值是否已经保存在object中，未保存则push到新数组并用object[arrayItem]=1的方式记录保存 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双飞翼布局]]></title>
    <url>%2F2017%2F06%2F23%2F%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[双飞翼布局：直接上代码,不做过多解释，自己敲一遍就理解了！123456789101112131415161718192021222324252627282930313233343536&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;mainin&quot;&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;.main, .left, .right &#123; float: left; height: 200px; &#125; .main &#123; width: 100%; background: #ace; &#125; .left &#123; width: 20%; background: #eee; margin-left: -100%; &#125; .right &#123; width: 30%; background: #ddd; margin-left: -30%; &#125; .mainin &#123; margin: 0 30% 0 20%; &#125; 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css布局之--左边固定宽，右侧自适应（4种方法）]]></title>
    <url>%2F2017%2F06%2F07%2Fhtml-css%E5%B8%83%E5%B1%80%E4%B9%8B-%E5%B7%A6%E8%BE%B9%E5%9B%BA%E5%AE%9A%E5%AE%BD%EF%BC%8C%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%884%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天，在网上看到一个题目，关于布局的，左边固定宽，右侧自适应（不少于3种方法），看到问题手痒自己试了一下，想了四种方法，码一下。有好的方法，可以告诉我！html:1234567891011121314151617181920&lt;h3&gt;第一种:定位+margin-left&lt;/h3&gt; &lt;div class=&quot;cont&quot;&gt; &lt;div class=&quot;one&quot;&gt;左侧定宽200px&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;右侧自适应&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;第二种：flex&lt;/h3&gt; &lt;div class=&quot;cont1&quot;&gt; &lt;div class=&quot;a&quot;&gt;左侧定宽200px&lt;/div&gt; &lt;div class=&quot;b&quot;&gt;右侧自适应&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;第三种：定位+浮动+padding-left+ box-sizing&lt;/h3&gt; &lt;div class=&quot;cont2&quot;&gt; &lt;div class=&quot;a1&quot;&gt;左侧定宽200px&lt;/div&gt; &lt;div class=&quot;b1&quot;&gt;右侧自适应&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;第四种:浮动&lt;/h3&gt; &lt;div class=&quot;cont3&quot;&gt; &lt;div class=&quot;a2&quot;&gt;左侧定宽200px&lt;/div&gt; &lt;div class=&quot;b2&quot;&gt;右侧自适应&lt;/div&gt; &lt;/div&gt; css: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; /*****第一种******/ .cont &#123; height: 200px; overflow: hidden; border: 1px solid #000; &#125; .one &#123; width: 200px; height: 200px; background: #ccc; position: absolute; &#125; .two &#123; height: 200px; background: #f60; margin-left: 200px; &#125; /*****第二种******/ .cont1 &#123; height: 200px; overflow: hidden; border: 1px solid #000; display: flex; &#125; .a &#123; width: 200px; height: 200px; background: #ccc; &#125; .b &#123; height: 200px; background: #f60; flex: 1; &#125; /****第三种*******/ .cont2 &#123; height: 200px; border: 1px solid #000; position: relative; overflow: hidden; &#125; .a1 &#123; width: 200px; height: 200px; background: #ccc; position: absolute; left: 0; top: 0; &#125; .b1 &#123; width: 100%; height: 200px; background: #f60; position: absolute; left: 200px; top: 0; padding-right: 200px; box-sizing: border-box; &#125; /*****第四种******/ .cont3 &#123; height: 200px; border: 1px solid #000; &#125; .a2 &#123; width: 200px; height: 200px; background: #ccc; float: left; &#125; .b2 &#123; width: 100%; height: 200px; background: #f60; &#125;&lt;/style&gt; 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css布局之--圣杯布局]]></title>
    <url>%2F2017%2F06%2F07%2Fhtml-css%E5%B8%83%E5%B1%80%E4%B9%8B-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[圣杯布局，就是两边定宽，中间自适应的三栏布局！今天把这个布局代码，码一下！看代码不作过多解释！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 &lt;div id=&quot;parents&quot;&gt; &lt;div id=&quot;top&quot;&gt;这是header!&lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;left&quot;&gt;这是Left&lt;/div&gt; &lt;div id=&quot;content&quot;&gt;这是Content!&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;这是Right!&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;foot&quot;&gt;这是Footer!&lt;/div&gt;&lt;/div&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #parents &#123; width: 100%; margin: 0 auto; background: #ccc; &#125; #left, #content, #right &#123; padding-bottom: 2000px; margin-bottom: -2000px; &#125; #main &#123; padding-left: 100px; padding-right: 150px; overflow: hidden; &#125; #top &#123; background: #666; &#125; #left &#123; background: #E79F6D; float: left; width: 100px; position: relative; left: -100px; &#125; #content &#123; background: #D6D6D6; float: left; width: 100%; margin-left: -100px; &#125; #right &#123; background: #77BBDD; float: left; width: 150px; margin-left: -150px; position: relative; left: 150px; &#125; #foot &#123; background: #666; clear: both; &#125;&lt;/style&gt; 提示：自己动手试一下，效果会更好！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue怎么使用echarts]]></title>
    <url>%2F2017%2F06%2F05%2F%E5%9C%A8vue%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8echarts%2F</url>
    <content type="text"><![CDATA[现在很多的项目，对数据可视化看的越来越重要，数据可视化可以多维度的分析数据，一目了然；对项目的美观和简洁度都有不少的提升，比原来那种表格化的数据格式要好很多了！对这种问题，echarts解决了这样的问题，这里介绍一下 在vue怎么使用echarts！同样，使用的vue-cli环境！首先，通过npm安装ECharts和zrender，命令行：12npm install echarts --save npm install zrender --save ; html：123456&lt;template&gt; &lt;div class=&quot;charts&quot;&gt; &lt;h3&gt;vue2.0中使用echart&lt;/h3&gt; &lt;div id=&quot;main&quot; style=&quot; width:100%; height:350px;&quot;&gt;&lt;/div&gt; //这里的高度一定要的，不然是不会显示图标的 &lt;/div&gt;&lt;/template&gt; js部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;script&gt;import echarts from &apos;echarts&apos;; //这里是你必须的，千万不能忘记！ export default &#123; data() &#123; return &#123; // 初始化空对象 chart: null, // 初始化图表配置 opinion: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;], opinionData: [&#123; value: 26, name: &apos;A&apos; &#125;, &#123; value: 31, name: &apos;B&apos; &#125;, &#123; value: 18, name: &apos;C&apos; &#125;, &#123; value: 28, name: &apos;D&apos; &#125;, &#123; value: 21, name: &apos;E&apos; &#125;] &#125; &#125;, methods: &#123; // 绘图 drawGraph(id) &#123; // 绘图方法 this.chart = echarts.init(document.getElementById(id)) // 皮肤添加同一般使用方式 this.chart.showLoading(); // 返回到data中 var that = this // ajax 请求数据 // $.ajax(&#123; // // 方式 // type: &quot;GET&quot;, // // 是否异步 // async: true, // // 路径||API // url: &quot;xxx&quot;, // //返回数据形式为json // dataType: &quot;json&quot;, // // 加载成功 // success: function(result) &#123; // // 更新初始数据 // that.opinionData = result // &#125;, // // 加载错误 // error: function(errorMsg) &#123; // // alert(&quot;请求数据失败!&quot;); // console.log(errorMsg) // &#125; // &#125;) // set this.chart.setOption(&#123; title: &#123; text: &apos;此处为标题&apos;, subtext: &apos;副标题&apos;, x: &apos;center&apos; &#125;, tooltip: &#123; trigger: &apos;item&apos;, formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, legend: &#123; x: &apos;center&apos;, y: &apos;bottom&apos;, data: this.opinion // this &#125;, toolbox: &#123; show: true, feature: &#123; mark: &#123; show: true &#125;, dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: [&apos;pie&apos;] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, calculable: true, series: [&#123; name: &apos;种类&apos;, type: &apos;pie&apos;, // 内圆半径，外圆半径 radius: [30, 100], // 位置，左右，上下 center: [&apos;50%&apos;, &apos;50%&apos;], roseType: &apos;area&apos;, data: this.opinionData, // this &#125;] &#125;) this.chart.hideLoading() &#125; &#125;, mounted() &#123; this.$nextTick(function() &#123; this.drawGraph(&apos;main&apos;) &#125;) &#125; &#125; &lt;/script&gt; 效果如下图： 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决百度分享不支持https的问题]]></title>
    <url>%2F2017%2F06%2F01%2F%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%E4%B8%8D%E6%94%AF%E6%8C%81https%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前段时间搭博客的时候，想添加一个百度分享来引流，不了百度分享，不支持https，这个问题困扰了我好久。我呢，在网上搜索了很多资料，最后终于解决了，现在将问题的解决办法分享一下：本站左侧就可以查看效果！第一步首先,https://github.com/sky-xsk/-https-我的github上，把这个文件下载或者克隆下来，这个步骤就不做过多解释！（有用的话给个star）第二步解压压缩文件，把里面的static文件夹，放置到你网站的根目录下面，记住一定是根目录；根目录是啥？这里解释一下，打开你的浏览器，打开百度主页，在搜索框里输入：“根目录是什么？”，看到一个合理的解释即可！（开个玩笑）第三步window._bd_share_config={“common”:{“bdSnsKey”:{},”bdText”:””,”bdMini”:”2”,”bdMiniList”:false,”bdPic”:””,”bdStyle”:”0”,”bdSize”:”16”},”slide”:{“type”:”slide”,”bdImg”:”5”,”bdPos”:”left”,”bdTop”:”178.5”}};with(document)0[(getElementsByTagName(‘head’)[0]||body).appendChild(createElement(‘script’)).src=’https://sky-xsk.github.io/static/api/js/share.js?v=89860593.js?cdnversion=&#39;+~(-new Date()/36e5)];看到这个，把src后面的网址改成如上面的代码，注意在src=’https://sky-xsk.github.io/static/api/js/share.js?v=89860593.js?cdnversion=&#39;+~(-new Date()/36e5)]里面，https://sky-xsk.github.io改成自己网址即可；这里是我改好的，你按照这个修改该即可！注意这里提两个主要点：1.static文件夹，放置的路径一定是你网站的根目录；2.修改的src一定是你自己的网址； 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>百度分享</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单聊一下js闭包]]></title>
    <url>%2F2017%2F05%2F31%2F%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%80%E4%B8%8Bjs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[js闭包，阮老师说：‘闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。’ 这里可能要先去理解一下全局 变量和局部变量，这里先不做过多的解释！ 接下来通过几个例子，谈一下对比包的理解以及各种闭包的写法，下面的例子可能不够专业，但是对于闭包的理解个人认为还是有很大的帮助的! 例子1：1234567function a()&#123; var b = 1; return function c()&#123; console.log(b) &#125;&#125;a()(); //1 这个函数调用时，a()(),有两个括号，第一个是调用a函数，第二个是执行c函数。 如果单独执行a();返回的就是c函数的函数体，这里就是把c函数，缓存了一下，并没有立即执行！ 例子2：123456function a()&#123; return function()&#123; console.log(0) &#125;&#125;a()(); //0 这种写法，和上面一种写法差不多，但是缓存的时候是匿名函数，但是调用的方法是相同的！ 例子3：123456789 function a() &#123; var b = 1; function c() &#123; alert(b); &#125; return c; &#125; var d = a(); d(); // 1 分析一下例子3，应该可以看出c函数是一个闭包的形式，一个函数里面嵌套了另外一个函数，被嵌套的函数被缓存了，也就是c函数，但是此处的写法略有不同,var d = a(); d();等同于a()();这里只是进行了一次缓存，这样就好理解了；还有要注意的是：这段代码有两个特点：1、函数c嵌套在函数a内部；2、函数a返回函数c。例子4：12345678910var name = &quot;The Window&quot;; var object = &#123; name: &quot;My Object&quot;, getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //The Window 解释一下，其实这块很简单，getNameFunc()第一次执行时，如果在里面打印出this的话，这个this指向的是object,就返回了function() {return this.name;};，当getNameFunc()()执行时，就是执行function() {return this.name};这样一句话，这里的this指向的就是window了，所以最后的结果就是The Window了;例子5：1234567891011var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //My Object 这个例子的话，和上面的相比，多了var that = this;,然后返回的是that.name;;参考上面的解释，很明显可以看出，因为var that = this, 返回的that.name,改变了this的指向，that指向的就是object了，所以最后的结果就是My Object了；使用闭包的注意点：1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。如果理解这些，我觉着闭包也就八九不离十了！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js封装——封装一些小例（栗）子]]></title>
    <url>%2F2017%2F05%2F26%2Fjs%E5%B0%81%E8%A3%85%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E4%B8%80%E4%BA%9B%E5%B0%8F%E4%BE%8B%EF%BC%88%E6%A0%97%EF%BC%89%E5%AD%90%2F</url>
    <content type="text"><![CDATA[在开发过程中，经常会遇到很多相同的效果和逻辑交互，相同的代码要写很多次，代码重复，这样会导致很多问题，具体问题就不说了，大家应该都懂！今天，通过几个封装效果的几个实例，来实现代码的复用，让你的代码也变的简洁高效起来吧！请往下看： 封装，就是把一个零零散散的东西做成一个组件。实现共同调用，但又不相互影响，实现代码复用！网上的关于这类文章的介绍很多，我这里就不多介绍，直接上手写几个小栗子，我想会更直接；示例1如图：仿的百度输入法的效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263css: &lt;style&gt; body,ul, li, button &#123; margin: 0; padding: 0; &#125; body &#123; font: 12px/1.5 Tahoma; &#125; ul &#123; list-style-type: none; &#125; button &#123; cursor: pointer; &#125; #outer &#123; width: 70px; margin: 10px auto; &#125; .ime &#123; margin-top: 5px; background: #fff; border: 1px solid #9a99ff; display: none; &#125; .ime li &#123; width: 100%; line-height: 24px; display: inline-block; vertical-align: top; &#125; .close &#123; border-top: 1px solid #9a99ff; &#125; .ime li a &#123; color: #00c; padding: 0 5px; display: block; text-decoration: none; &#125; .ime li a:hover &#123; background: #d9e1f6; &#125; &lt;/style&gt; html: &lt;div id=&quot;outer&quot;&gt; &lt;button&gt;输入法&lt;/button&gt; &lt;ul class=&quot;ime&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;手写&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;拼音&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;close&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;关闭&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 重点js（未经封装的常规写法）：123456789101112window.onload = function() &#123; var oBtn = document.getElementsByTagName(&quot;button&quot;)[0]; var oIme = document.getElementById(&quot;ime&quot;); var oClose = document.getElementById(&quot;close&quot;); var style = oIme.style; oBtn.onclick = function() &#123; style.display = style.display == &quot;block&quot; ? &quot;none&quot; : &quot;block&quot; &#125;; oClose.onclick = function() &#123; style.display = &quot;none&quot; &#125;&#125;; 封装后的写法：1234567891011121314151617181920212223window.onload = function() &#123; new Writes(&quot;outer&quot;); //调用方法，直接new一下就行了&#125;function Writes(id) &#123; var oUter = document.getElementById(id); this.oBtn = oUter.getElementsByTagName(&quot;button&quot;)[0]; this.oIme = oUter.getElementsByClassName(&quot;ime&quot;)[0]; this.oClose = oUter.getElementsByClassName(&quot;close&quot;)[0]; var _this = this; this.style = this.oIme.style; this.oBtn.onclick = function() &#123; _this.shows(this); &#125;; this.oClose.onclick = function() &#123; _this.hides(this); &#125;;&#125;;Writes.prototype.shows = function() &#123; this.style.display = this.style.display == &quot;block&quot; ? &quot;none&quot; : &quot;block&quot;&#125;;Writes.prototype.hides = function() &#123; this.style.display = &quot;none&quot;&#125;; 示例2如图：弹出层效果，很常见的效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121css:&lt;style&gt; html, body &#123; height: 100%; overflow: hidden; &#125; body, div, h2 &#123; margin: 0; padding: 0; &#125; body &#123; font: 12px/1.5 Tahoma; &#125; center &#123; padding-top: 10px; &#125; button &#123; cursor: pointer; &#125; .overlay &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; opacity: 0.5; filter: alpha(opacity=50); display: none; &#125; .win &#123; position: absolute; top: 50%; left: 50%; width: 400px; height: 200px; background: #fff; border: 4px solid #f90; margin: -102px 0 0 -202px; display: none; &#125; h2 &#123; font-size: 12px; text-align: right; background: #FC0; border-bottom: 3px solid #f90; padding: 5px; &#125; h2 span &#123; color: #f90; cursor: pointer; background: #fff; border: 1px solid #f90; padding: 0 2px; &#125; &lt;/style&gt; html: &lt;div id=&quot;cont&quot;&gt; &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; &lt;div class=&quot;win&quot;&gt; &lt;h2&gt;&lt;span class=&quot;close&quot;&gt;×&lt;/span&gt;&lt;/h2&gt; &lt;/div&gt; &lt;button&gt;弹出层&lt;/button&gt; &lt;/div&gt;未封装的写法：--------------------------window.onload = function() &#123; var cont = document.getElementById(&apos;cont&apos;); var oWin = document.getElementsByClassName(&quot;win&quot;)[0]; var oLay = document.getElementsByClassName(&quot;overlay&quot;)[0]; var oBtn = document.getElementsByTagName(&quot;button&quot;)[0]; var oClose = document.getElementsByClassName(&quot;close&quot;)[0]; oBtn.onclick = function() &#123; oLay.style.display = &quot;block&quot;; oWin.style.display = &quot;block&quot; &#125;; oClose.onclick = function() &#123; oLay.style.display = &quot;none&quot;; oWin.style.display = &quot;none&quot; &#125;;&#125;;封装后的写法，对比一下--------------------------window.onload = function() &#123; new shows(&apos;cont&apos;); //调用方法，直接new一下就行了&#125;;function shows(id) &#123; var cont = document.getElementById(id); this.oWin = cont.getElementsByClassName(&quot;win&quot;)[0]; this.oLay = cont.getElementsByClassName(&quot;overlay&quot;)[0]; this.oBtn = cont.getElementsByTagName(&quot;button&quot;)[0]; this.oClose = cont.getElementsByClassName(&quot;close&quot;)[0]; var _this = this; this.oBtn.onclick = function() &#123; _this.block(); &#125;; this.oClose.onclick = function() &#123; _this.none(); &#125;&#125;;shows.prototype.block = function() &#123; this.oLay.style.display = &quot;block&quot;; this.oWin.style.display = &quot;block&quot;&#125;;shows.prototype.none = function() &#123; this.oLay.style.display = &quot;none&quot;; this.oWin.style.display = &quot;none&quot;&#125;; 简单总结：1.不能存在函数嵌套，全局变量；2.window.onload改写成构造函数的形式；3.全局变量改写成属性；4.函数改写成方法；6.最后，注意一下this,事件方法，闭包，传参这几点注意一下，就ok了？ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于跨域jsonp]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9Fjsonp%2F</url>
    <content type="text"><![CDATA[今天没什么太忙的事，准备写一个关于jsonp的文章，参考了网上不少文章，感觉自己的理解没有网上一些文章理解的透彻，所以这里选了一篇比较好的文章，当自己的笔记吧！一边以后自己的查阅！什么是JSONP？1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准。 2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力。 script、img、iframe 3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理。4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据。 5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。JSONP的客户端具体实现： 1alert(&apos;我是远程文件&apos;); 本地服务器localserver.com下有个jsonp.html页面代码如下： 12345678910&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data)&#123; alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); &#125;; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; remote.js文件代码如下： 1localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;); 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端 “我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了看jsonp.html页面的代码：12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：12345flightHandler(&#123; &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用jQuery如何实现jsonp调用？ 123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt;&lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json)&#123; alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？这里针对ajax与jsonp的异同再做一些补充说明： 1、ajax和jsonp这两种技术在调用方式上”看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装。 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！ 个人感觉，这篇文章写的还是比较全面的，挺好的！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解前端语义化（转载）]]></title>
    <url>%2F2017%2F05%2F25%2F%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.Web标准Web标准是由一系列标准组合而成。一个网页主要由三部分组成：结构层、表现层和行为层。对应的标准也分三方面：结构化标准语言主要包括XHTML和HTML以及XML，表现层标准语言主要包括CSS，行为标准主要包括对象模型，DOM、ECMAScript等。结构化标准语言，就是W3C规定的那样; ㈠标签的书写，需要开始和结束。单便签除外；㈡块级元素不能放在标签里面。li内可以包含div标签。㈢块元素里面可以放在块和内联，特殊的 p和 h1—h6里面不要放块元素，li和div可以放很多。因为这两个标签，本身就有容器的属性㈣内联里面要放内联，不要放块。㈤结构与表现分离㈥命名一定要规范表现层标准：css的书写，首先要尽可能使用外部引入的方式，因为结构层尽可能的减少表现层的代码过多出现。达到分离的目的。css的选择器有哪些，那些属性可以继承，那些不可以继承。他们之间的优先级是怎么样的。怎么用最简洁的css代码表达设计者的想法，而不只是实现设计者的想法就没事了。我们要的是代码简洁，代码过多，反而让浏览器解析很多，浪费时间。行为层标准：主要是JavaScript中的知识。比如DOM、ECMAScript。使用javascript中的标准，即可。一般对于用户的行为，或者说页面上的动态效果的一些特殊实现，我们可以会考虑到使用javascript来进行书写，但是代码的可复用性，模块化。变量，作用域。可能更多的就是javascript的规定了。自己把自己的理解程度说出来就可以了。 2.标签语义化 什么是语义化？其实简单说来就是让机器可以读懂内容。web页面的解析是由搜索引擎来进行搜索，机器来解析。所以语义化的标准是，尽可能的让机器读懂。最初的HTML中如h1~h6、thead、ul、ol等标签，通过标签的语义，最初设计的想法，来达到语义化的要求。如标题、表头、无序、有序列表，搜索引擎很好的利用了这些语义化标签抓取内容后来，最初定义的HTML语义化标签，不足以实现对Web页面各个部分的功能或位置描述，所以Web前端人员利用HTML标签的id和class属性，进一步对HTML标签进行描述，如对页脚HTML标签添加如id=”footer”或者class=”footer”的属性（值），以“无声”的方式在不同的前端程序员或者前后端程序员间实现交流。制定HTML5的W3C组织采用了诸如header、footer、section等语义化标签，来进行页面布局的设计想法，弥补了采用id=”header”或者class=”section”等。更深层次的语义化，是自己在团队合作的过程中，对于需要声明的变量和class，id。尽可能使用彼此能理解的英文。这样减少合作的成本，加快合作的效率。为什么要语义化？ 1.)为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 2.)用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 3.)有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 4.)方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 5.)便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 写HTML代码时应注意什么？ 1.)尽可能少的使用无语义的标签div和span； 2.)在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 3.)不要使用纯样式标签，如：b、font、u等，改用css设置。 4.)需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 5.)使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 6.)表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 7.)每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>html/css</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的变量提升]]></title>
    <url>%2F2017%2F05%2F24%2Fjs%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[在JavaScript 中，函数及变量的声明都将被提升到函数的最顶部，变量可以在使用后声明，也就是变量可以先使用再声明。变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。虽然，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解；但是理解变量提升还是很有用的！ 实例1 123x=5; //设置x的值为5console.log(x); //5var x; //声明变量x 注意看看，下面的例子，和实例1是相同的，但是写法是不同的；123var x; //声明变量xx=5; //设置x的值为5console.log(x) //5 从上面2个例子，就大概知道变量提升了（hoisting）;为了更好的理解，看一下面的例子；实例21234var x=5; //初始化var y=1; //初始化console.log(x); //5console.log(y); //1 换一下位置实例31234var x=5; //初始化console.log(x); //5console.log(y); //undefinedvar y=1; //初始化 实例3的代码。等同于以下写法：12345var x=5; //初始化var y //这里y提升了，初始化的var y = 1 不会提升console.log(x); //5console.log(y); //undefinedy=1; //初始化 从实例2和实例3的对比可以看出， 在js中，只有声明的变量会提升，初始化的不会。再看一下，函数声明；实例4123456function foo()&#123; var x; console.log(x) x=5;&#125;foo() //undefined 和上面的例子差不多相同，接着往下看；1234567891011function test() &#123; foo(); // TypeError &quot;foo is not a function&quot; bar(); // 0 var foo = function () &#123; // 变量指向函数表达式 alert(1); &#125; function bar() &#123; // 函数声明 函数名为bar alert(0); &#125; &#125; test(); 命名函数：12345678foo(); // TypeError &quot;foo is not a function&quot; bar(); // valid baz(); // TypeError &quot;baz is not a function&quot; spam(); // ReferenceError &quot;spam is not defined&quot; var foo = function () &#123;&#125;; // foo指向匿名函数 function bar() &#123;&#125;; // 函数声明 var baz = function spam() &#123;&#125;; // 命名函数，只有baz被提升，spam不会被提升。 上面可以看出，只有函数式的声明才会连同函数体一起被提升。foo的声明会被提升，但是它指向的函数体只会在执行的时候才被赋值。 //函数声明：像这种形式：function foo(){}； 接下来，看看函数的声明和变量的声明的优先级；12345678910111213141516171819function a()&#123; &#125; var a; alert(a);//打印出a的函数体 -------------------var a; function a()&#123; &#125; alert(a);//打印出a的函数体 -------------------var a=1; function a()&#123; &#125; alert(a);//打印出1 -------------------function a()&#123; &#125; var a=1; alert(a);//打印出1 由此可以看出来什么？函数的声明比变量的声明具有高的优先级！ ECMAScript参考文档上说 如果变量在函数体类声明，则它是函数作用域。否则，它是全局作用域（作为global的属性）。变量将会在执行进入作用域的时候被创建。块不会定义新的作用域，只有函数声明和程序才会创造新的作用域。变量在创建的时候会被初始化为undefined。如果变量声明语句里面带有赋值操作，则赋值操作只有被执行到的时候才会发生，而不是创建的时候。(方便理解) 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么用vue-cli构建自己的vue2.0的项目]]></title>
    <url>%2F2017%2F05%2F23%2F%E6%80%8E%E4%B9%88%E7%94%A8vue-cli%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84vue2-0%E7%9A%84%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[博客里的一些小示例都是在vue-cli的基础上构建的，为了方便学习，这里把vue-cli构建项目的方法说一下！怎样从零开始，构建一个简单的vue2.0项目！ 这里首先说一下，vue-cli是什么？ vue-cli是官方提供的一个脚手架，个人感觉比较适合新手同学来学习vue！ 1.首先，要安装node和npm 这里先不说这两的安装方法，可以自行到网上搜索一下，例子还是很多的； 2.开始了，这里说一下，因为npm install安装的太慢，如果你的网速还比较渣的话，那我只能对你说自求多福吧！ 这里推荐使用淘宝镜像；一下是安装方法：打开命令行工具，输入： 1npm install -g cnpm --registry= https://registry.npm.taobao.org 安装完成后，输入 1cnpm -v 如果出现版本号，就说明安装成功了！ 3.接下来，安装webpack打开命令行工具输入：1npm install webpack -g 安装完成之后输入 webpack -v，如果出现相应的版本号，则说明安装成功。因为安装了淘宝的镜像，可以直接输入：1cnpm install webpack -g 4.接下来，安装vue-cli脚手架构建工具安装vue-cli脚手架构建工具，打开命令行工具输入：1npm install vue-cli -g 安装完成之后输入 vue -V（注意这里是大写的“V”）,如果出现相应的版本号，则说明安装成功。 5.新建一个文件夹，放置你的项目cd 目录路径，然后输入命令：123vue init webpack projectName //projectName是你的工程名称，可自行输入``` 接下来出现 $ vue init webpack projectName ——————— 这个是那个安装vue脚手架的命令This will install Vue 2.x version of the template. ———————这里说明将要创建一个vue 2.x版本的项目For Vue 1.x use: vue init webpack#1.0 projectName? Project name (projectName) ———————项目名称? Project name projectName? Project description (A Vue.js project) ———————项目描述? Project description A Vue.js project? Author Datura ——————— 项目创建者? Author Datura? Vue build (Use arrow keys)? Vue build standalone? Install vue-router? (Y/n) ——————— 是否安装Vue路由，也就是以后是spa（但页面应用需要的模块）? Install vue-router? Yes? Use ESLint to lint your code? (Y/n) n ———————是否启用eslint检测规则，这里个人建议选no,血的教训? Use ESLint to lint your code? No? Setup unit tests with Karma + Mocha? (Y/n) ——————-单元测试，可选可不选? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? (Y/n) ——————-单元测试，可选可不选? Setup e2e tests with Nightwatch? Yesvue-cli · Generated “projectName”.12&lt;h3&gt;6.启动项目&lt;/h3&gt;依次输入以下命令即可： cd exprice //切换到你的工程目录npm install //安装依赖，node-modulesnpm run dev //运行项目```出现下图，你就成功了 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现一些跨浏览器的兼容事件方法]]></title>
    <url>%2F2017%2F05%2F18%2Fjs%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用JavaScript实现事件的绑定，移除，以及一些常用的事件属性的获取，时常要考虑到在不同浏览器下的兼容性，下面给出了一个跨浏览器的事件对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var EventUtil = &#123; on: function(element, type, handler) &#123;/* 添加事件 */ if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123;//IE 注意：此时事件处理程序会在全局作用域中运行，因此用attachEvent绑定的事件，此时在事件处理函数里的this 等于window，使用时要注意 element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, off: function(element, type, handler) &#123;/* 移除事件 */ if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, getEvent: function(event) &#123;/* 返回对event对象的引用 */ return event ? event : window.event; &#125;, getTarget: function(event) &#123;/* 返回事件的目标 */ return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; /* 取消事件的默认行为 */ if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123;/* 阻止事件冒泡 */ if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, /* mouseover 和mouserout 这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。*/ getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123;//IE8 mouserout事件 return event.toElement; &#125; else if (event.fromElement) &#123;//IE8 mouseover事件 return event.fromElement; &#125; else &#123; return null;//其他事件 &#125; &#125;&#125; 调用如下：1234EventUtil.on(document, &quot;click&quot;, function(event)&#123;//为document元素绑定click事件 event = EventUtil.getEvent(event);//获取event事件对象 alert(&quot;Screen coordinates: &quot; + event.screenX + &quot;,&quot; + event.screenY);&#125;); 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么理解[].forEach.call()？]]></title>
    <url>%2F2017%2F05%2F16%2F%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-forEach-call-%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[今天，在网上看到javascript的[].forEach.call()写法，刚看到的时候有点蒙，不是太明白是什么意思！后来到网上查了一下，其实这东西是个简写的写法。如下：123456789function forEach(elems, callback) &#123; if([].forEach) &#123; [].forEach.call(elems, callback); &#125; else &#123; for(var i = 0; i &lt; elems.length; i++) &#123; callback(elems[i], i); &#125; &#125;&#125; [] 就是个数组，而且是用不到的空数组,用来就是为了访问它的数组相关方法。那完整的写法是什么呢？ 其实是这样的：1Array.prototype.forEach.call(...); 很显然，简写更方便。js中的forEach 方法，它可以接受一个函数参数，如下：1[1,2,3].forEach(function (num) &#123; console.log(num); &#125;); 上面的这句代码中，我们可以访问 this 对象，也就是 [1,2,3] ，可以看出，这个 this 是个数组。 最后， .call 是一个prototype，JavaScript函数内置的。 .call 使用它的第一个参数替换掉上面说的这个 this ，也就是你要传人的数组，其它的参数就跟 forEach 方法的参数一样了。123456[1, 2, 3].forEach.call([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], function (item, i, arr) &#123; console.log(i + &quot;: &quot; + item);&#125;);// 0: &quot;a&quot;// 1: &quot;b&quot;// 2: &quot;c&quot; 因此， [].forEach.call() 是一种快速的方法访问 forEach ，并将空数组的 this 换成想要遍历的list。 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单-Vue 2.0渐进式前端解决方案（Vue.js作者尤雨溪）(转载)]]></title>
    <url>%2F2017%2F05%2F15%2F%E7%AE%80%E5%8D%95-Vue-2-0%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88Vue-js%E4%BD%9C%E8%80%85%E5%B0%A4%E9%9B%A8%E6%BA%AA%EF%BC%89-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[(转载) 本人的新博客上线了：https://sky-xsk.github.io/ 主流框架分析我们看一下现有的一些主流框架从少到多所解决的问题。这个多少并不是来评价框架的好坏，而是从设计的角度出发看它涵盖多少内容。 纯模板引擎：最少的就是纯模板引擎，只管状态到界面的映射。 React和Vue：其实这两者都是非常专注的只做状态到界面映射，以及组件。 Backbone：它会给你多一些架构上指导，比如它会让你分层。 Angular：它做的事情就更多，它有自己的路由，这些都会包含在里面。 Ember：相比Angular，Ember做得就更加彻底，Ember信奉的是约定优于配置，它会将一切都帮你设计好打包好，你就开箱用就可以了。 Meteor：Meteor只是一个极端，它是从前到后全都包含，从前端到数据层到数据库，全都帮你打包好。 通过简单的分析，我们可以感受到，做得少的框架不一定就不如做得多的框架，这体现出一种取舍。也就是说，做得少的框架可以给你更多的灵活性，但你需要做更多的选择；做得多的框架有更强的侵入性，学习成本更高，灵活性更低。一旦选择了一个侵入性强的框架，那么一些小的部分你就没有机会去切换成其他你更想用的方案。Vue的定位与其他框架的区别就是渐进式的想法，也就是“Progressive”——这个词在英文中定义是渐进，一步一步，不是说你必须一竿子把所有的东西都用上。Vue的设计接下来我们回到之前看的图： Vue从设计角度来讲，虽然能够涵盖这张图上所有的东西，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。Vue的实现接下来深入讲一讲这些具体的概念以及Vue在这些概念上具体是做怎样的实现。(1) 声明式渲染现在基本所有的框架都已经认同这个看法——DOM应尽可能是一个函数式到状态的映射状态即是唯一的真相，而Dom状态只是数据状态的一个映射，所有的逻辑应该尽量在状体的层面上去进行，当状态改变的时候，View应该是在框架帮助下自动更新到合理的状态，而不是当观察到数据变化后手动的选择元素再命令式改动它的属性下图是Vue的一个模板示例，如果没有用过Vue的话，可以大概感觉到这是一个怎样的概念声明式渲染 其实，在模板语法上，Vue跟Angular是比较相似。在Vue1.0里面，模板实现跟Angular类似，如下图所示，把模板直接做成在浏览器里面parse成DOM树，然后去遍历这个树，提取其中的各种绑定。aa.png 在Vue2.0中，渲染层的实现做了根本性改动，引入了虚拟DOM从架构上讲，2.0依然写同样的模板，在最左边，Vue2.0跟1.0的模板语法绝大部分是兼容的。Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个虚拟DOM的树。这个树非常轻量，它的职责就是描述当前界面所应处的状态。当我们有了这个虚拟的树之后，再交给一个patch函数，负责把这些虚拟DOM真正施加到真实的DOM上。在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到的数据来源之后，之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新树与旧树进行对比，就可以最终得出应施加到真实DOM上的改动。最后再通过patch函数施加改动。这样做的主要原因是，在浏览器当中，JavaScript的运算在现代的引擎中非常快，但DOM本身是非常缓慢的东西。当你调用原生DOM API的时候，浏览器需要在JavaScript引擎的语境下去接触原生的DOM的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实DOM的操作是最少的。下面看渲染函数。用过React的开发者可能知道，React是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树。JSX实际就是一套用于让我们更简单地去描述树状结构的语法糖如下图所示，在Vue2.0当中，可以看到就是说当比如左侧的模板，经过Vue的编译之后就会变成右侧的东西。 此函数类似于创建一个虚拟元素的函数，我们可以给它一个名字，给它描述应该有的属性特性和可能其他的数据。然后后面这个最后这个参数是个数组，包含了该虚拟元素的子元素。总的来说2.0的编译器做的就是这个活。同时，在Vue2.0里，用户可以选择直接跳过模板这一层去手写渲染函数，同时也有可选JSX支持。从开发者的偏好以及开发者的效益的角度来考量，模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。JSX和直接渲染函数，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。所以在Vue2.0里，两个都是可以选择的。在绝大部分情况下使用模板，但是在需要复杂逻辑的情况下，使用渲染函数。在Vue2.0的路由和内部的一些实践上，都大量地应用渲染函数做复杂的抽象组件，比如过渡动画组件以及路由里面的link组件，都是用渲染函数实现的，同时还保留了它本身的依赖追踪系统。举例在渲染函数里面用到A.B的时候，这个就会触发对应的 getter。整个渲染流程具体要点如下：当某个数据属性被用到时，触发 getter，这个属性就会被作为依赖被 watcher 记录下来。整个函数被渲染完的时候，每一个被用到的数据属性都会被记录。相应的数据变动时，例如给它一个新的值，就会触发 setter，通知数据对象对应数据有变化。此时会通知对应的组件，其数据依赖有所改动，需要重新渲染。对应的组件再次调动渲染函数，生成 Virtual DOM，实现 DOM 更新。 这样一个流程跟主流的一些框架，例如React是有较大区别的。在React中，当组件复杂的时候需要用 shouldComponentUpdate 做优化。但是，它也有自己的各种坑，比如要确保该组件下面的组件不依赖外部的状态。虽说这在大部分情况下是够用的，但遇到极大复杂度的应用，遇到性能瓶颈的时候，这个流程优化起来也是相当复杂的一个话题。如下图所示，在Vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要手动优化。用Vue渲染这些组件的时候，数据变了，对应的组件基本上去除了手动优化的必要性。2.png （2）组件系统相信基本上所有的现代框架都已经走向了组件化道路，Web Components 从规范层面做这个实践。主流框架都有各有不同的封装，但核心思想都是一样，把UI结构映射到恰当的组件树。在Vue中，父子组件之间的通信是通过 props 传递。从父向子单向传递；而如果子组件想要在父组件作用里面产生副作用，就需要去派发事件。这样就形成一个基本的父子通信模式，在涉及大规模状态管理的时候会有额外的方案，这个后面会提到Vue的组件引入构建工具之后有一个单文件组件概念，如下图所示，就是这个Vue文件。在同一个Vue文件里，可以同时写 template、script 和 style，三个东西放在一个里面。同时，Vue的单文件组件和 Web Components 有一个本质不同，它是基于构建工具实现。这样的好处是有了一个构建的机会，可以对这些单文件组件做更多的分析处，在每一个语言块里可以单独使用不同的处理器，这点后面还会讲到。单文件组件 （3）客户端路由在做一个界面复杂度非常的高应用时，它会有很多的状态，这样的应用显然不可能在每做一次操作后都刷新一个页面作为用户反馈。这就要这个应用有多个复杂的状态，同时这些状态还要对应到URL。有一个重要的功能叫做 deep-linking，也就是当用户浏览到一个URL，然后把它传给另外的人或者复制重新打开，应用需要直接渲染出这个URL对应的状态。这就意味着应用的URL和组件树的状态之间有一个映射关系，客户端路由的职责就是让这个映射关系声明式地对应起来。 可能同一层的路由有多个不同的出口，还有着复杂的URL匹配规则，等等。这些问题如果都由自己去一一实现，那么复杂度是非常高的。而Vue基本都有对应的解决方案（router.vuejs.org）。配合Webpack还可以实现基于路由的懒加载，一条路径所对应的组件在打包的时候，会分离成另外一块，只有当该路由被访问的时候，才会被加载出来。这有相应的解决方案，同时也有实例。（4）状态管理说到状态管理，本质上就是把整个应用抽象为下图中的循环。脸书最早提出 Flux 这个概念的时，也是一个很松散的概念，而且官方的实现本身做得很难用。所以，社区就做了各种各样的探索。图中的这三个东西是一个单向数据流，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使State产生变化，从而导致 View 重新渲染。 一个单独的Vue的组件，其实就已经是这样的结构。但是当多个这样的组件来配套的时候，就会遇到一个问题。每个组件都有它自己的状态，但整个应用的状态，跟组件之间并不一定存在一一对应的关系。这个状态可能是一个全局状态。那么状态到底放在哪里？大部分解决方案是把这个状态从组件树中提取出来，放在一个全局的 Store 里面。Vuex 也是这样做的，但是它是针对 Vue 做了特化我们看到最左边就是Vue的组件，这些组件在大部分情况下，就不再有私有的状态，而是从全局的 Store 里面获取状态。Actions 和 Mutations 比较难用一两句话说清楚，大致就是当应用状态进行改变的时候，需要通过 Mutations 去显式地触发，而 Actions 则是负责异步和其他副作用。由于 Mutations 会被记录下来，我们可以把这些记录发到工具里面去做分析，甚至进行回滚。当发现bug的时候，这使得我们可以更好地理解大型应用中的状态变化。更多的细节，还请看官方文档（vuex.vuejs.org）。6.png （5）构建工具构建工具方面，Vue有一个官方的，全局安装的 vue-cli。这里有一个笔误。全局安装之后，我们就可以用 vue 命令创建一个新的项目，Vue 的 CLI 跟其他 CLI 不同之处在于，有多个可选模板，有简单的也有复杂的。极简的配置，更快的安装，可以更快的上手。它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。所有的模板在创建之后，构建脚本都是通过 npm 脚本来执行，在国内安装 npm 依赖的时候有点卡，可以用 yarn 或者推荐用淘宝的 npm 镜象源，可以很大地提升安装速度。之前提到了单文件组件，如下图所示，支持任意的处理器，开箱即用的热重载，所以组件都支持热重载 (hot-reload)。当你做了修改，不会刷新页面，只是对组件本身进行立刻重载，不会影响整个应用当前的状态。CSS也支持热重载。我们看下左下角，在使用这个预处理器的同时，我们只需要添加一个 scoped 特性，Vue 会通过对模板和CSS代码的解析改写，来模拟CSS的效果。同时单文件组件也支持懒加载，一个懒加载的组件和它的依赖会被打包成一个额外的包，只有被用到的时候才加载，这对首屏的加载速度也是很有帮助的。1.png 如下图所示，这个开发者工具本身也是用Vue写的2.png 使用它的话可以看到我们当前应用的组件树结构。3.png 点击组件，就可以观察这个组件当前的状态。也可以把这个组件发送到控制台里。同时这个开发者工具还有一个 Vuex 面板，如果你用了 Vuex，那么每次操作都会被记录下来，记录下来的状态之间可以进行跳转。除此之外，还支持把当前应用的状态快照发送给另外一个人，这个人可以在他的控制台里导入你发送的状态，就可以立刻跳转到你之前所在的状态。这对于重现一些 bug，或要描述当前状态都很有帮助。Vue2.0Vue2.0在不久之前刚刚发布（具体报道参见http://t.cn/RVC0foZ），之前一些技术细节在前文中已有所涉及。Vue2.0相对于1.0的改进有以下几点。1、更轻对Vue1.0大小压缩，Vue2.0它有一个只包含运行时的版本，所有的模板在编译的时候已经完成了。基于这个版本，下图中Vue、vue-router和vuex三个（都是 2.0 版本）加一起，跟Vue1.0的核心库大小一样。2、更快Vue2.0可以说是当前最快的框架之一。这个是基于第三方独立测试的结果。有兴趣的话，可以移步链接进行查看。这个测试是一个比较综合的测试，它对于各种操作，以及在大列表里面更新移除等，都有相当完整的覆盖。可以看出，Vue2.0，不仅仅是在Vue1.0的基础上有很大提升，相比其他框架，也有相当明显的性能优势。3、Vue2.0 架构下图是Vue2.0的架构图，这里不深入讲整个架构的实现。 Vue2.0同时支持服务端，服务端渲染支持流式渲染。因为HTTP请求也是流式，Vue 的服务端渲染结果可以直接 pipe 到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。除了服务端渲染还有原生渲染，这里的原生渲染是指阿里巴巴的项目Weex。在架构层面，通过编译一个 Weex 源文件（类似于 Vue 单文件组建的格式）然后运行。界面节点的操作都是抽象的，这些抽象操作会派发到不同的目标引擎做实际的渲染，同时支持 iOS, Android 和 Web。Vue和Weex现在有一个合作，Vue 2.0 将会正式成为 Weex 的 JavaScript 运行时。这样的合作可以使得符合功能交集的Vue组件可以跨平台使用。(转载)12本人的github，里面有vue2.0的小项目练习，包括仿饿了么的客户端，vue2.0写的，基本功能已经实现，部分bug在修改中;如果觉得有用的话，请给个“star”；https://github.com/sky-xsk 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
        <tag>转载</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0,自己开发一个全局定义的公用组件（插件）]]></title>
    <url>%2F2017%2F05%2F11%2Fvue2-0-%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%AC%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%88%E6%8F%92%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天，在群里看到有朋友问这样一个问题：“我在项目里，怎么能做一个全局调用的组件，不用每一次都import，注册组件？”看到这个问题，我思考了一下，讲一下我的思路！ 这个问题里，所说的组件，在我看来也可以叫做“插件”，为什么这么说呢？因为这个和vue-resource之类的插件开发的思路是一样的？只是一个放到的是本地，一个是通过“npm install vue-resource ”下载下来的？换一个思路，如果我把自己开发的组件放到网上，是不是别人可以直接用我开发的插件呢？回答是：“必须的”！ 所以我就来做一个公共的组件：同样的开发环境vue-cli;这个就不说了！！！ 新建alerts.vue和alerts.js文件alerts.vue123456789101112131415161718&lt;template&gt; &lt;div class=&quot;alerts&quot;&gt; &lt;h2&gt;开发自定义组件//公共组件可直接在任意地方调用&lt;/h2&gt; &lt;button @click=&quot;clicks()&quot;&gt;点击我试一下&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, methods:&#123; clicks()&#123; alert(&quot;我是公共的组件！（插件）&quot;) &#125; &#125;, &#125;&lt;/script&gt; 这个很简单！接下来是重头戏了！alerts.js1234567const alertsComponent = require(&apos;./alerts.vue&apos;); //引入const alerts = &#123; install: function(Vue) &#123; Vue.component(&apos;alerts&apos;, alertsComponent) &#125;&#125;;module.exports = alerts; 此处注意文件的路径，不要弄错了； 在main.js里引用，和调其他插件的方法一样main.js12import alerts from &apos;./components/alerts/alerts&apos; //注意路径Vue.use(alerts); 调用方法1&lt;alerts&gt;&lt;/alerts&gt; 在任意组件里调用，均可！ 我的github，如果有用，不要吝啬，请给个star；在里面可以找到此例子的源码哦！1https://github.com/sky-xsk/vue2.0-start- 如有错误，请指正！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>vue2.0</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单聊聊javascript的继承]]></title>
    <url>%2F2017%2F05%2F09%2F%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8Ajavascript%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9B%2F</url>
    <content type="text"><![CDATA[在JS中继承是一个非常复杂的话题，比其他任何面向对象语言中的继承都复杂得多。在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可。在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，且JS是基于对象来继承的。（这话是比较官方的说法，看着都很专业） 在说继承之前，首先得先回答一个问题，什么是继承？我理解的继承，简单来说就是，–1.在原有类的基础上，进行可操作的修改，得到一个崭新的类，这个类有原来类的功能，同时也有自己的功能；–2.这个新的类，不会影响原有类的功能，不会相互干预； 这里肯定有人要问了，什么是‘可操作的修改呢？’说白了就是在不影响整个类的功能的前提下，进行的修改！这点和第二点略有重复，仔细想想，还是有所区别的！！！下面开始说说常用的集中继承方式： ###1.代码：12345678910111213141516171819202122function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;Person.prototype.showName = function() &#123; console.log(this.name);&#125;Person.prototype.showSex = function() &#123; console.log(this.sex);&#125;function work(name, sex, job) &#123; //构造函数伪装调用父级的构造函数——为了继承属性 Person.call(this, name, sex); //Person.apply(this, [name, sex]); //此处的call与apply是有区别的，往下看 this.job = job;&#125;work.prototype = Person.prototype; //通过prototype继承父级的属性work.prototype.showJob = function() &#123; console.log(this.job);&#125;var s = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;);s.showJob() //developer 简单的解释一下上面的代码：首先写了一个很简单的构造函数，在函数的原型上分别添加了showName和showSex的方法；紧接着写了一个work（）函数，这里注意work（）里面的参数，多了一个job参数，这个参数就是要继承的参数， Person.call(this, name, sex);有人问这里的this指的是啥？看下图：答案就是 new出来的work对象！work.prototype = Person.prototype;这句话就是通过prototype继承父级的属性，name和sex；然后就是在work的基础上添加showJob方法；最后就是new一个work对象，执行方法！最后work继承了Person的name和sex属性；是不是很好懂！ ###2.代码：123456789101112131415161718192021222324252627282930313233function Person(name, sex) &#123; this.name = name; this.sex = sex; &#125; Person.prototype.showName = function() &#123; alert(this.name); &#125;; Person.prototype.showSex = function() &#123; alert(this.sex); &#125;; function work(name, sex, job) &#123; Person.call(this, name, sex); this.job = job; &#125; //1.原型链 通过原型来继承父级的方法 //work.prototype=Person.prototype; // 2.原型链 通过原型来继承父级的方法(循环方法) // Person.prototype类型是object； for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; Worker.prototype.showJob = function() &#123; alert(this.job); &#125;; var p = new Person(&apos;xue&apos;, &apos;nan&apos;); var w = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;); // p.showName(); // p.showSex(); // w.showName(); // w.showSex(); // w.showJob(); 简单解释一下：1234``` for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; 这里只是用不同方法，通过原型链来继承父级的方法，原理是一样的！ call与apply的区别js中call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。说简单一点，这两函数的作用其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。如有错误请私信本人！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度复用的弹出框组件的写法 vue2.0]]></title>
    <url>%2F2017%2F05%2F09%2F%E9%AB%98%E5%BA%A6%E5%A4%8D%E7%94%A8%E7%9A%84%E5%BC%B9%E5%87%BA%E6%A1%86%E7%BB%84%E4%BB%B6%E7%9A%84%E5%86%99%E6%B3%95-vue2.0%2F</url>
    <content type="text"><![CDATA[和以前的文章一样用的vue-cli;具体的 安装步骤这里不做详细的解释了；直接开始了；一定要存在其他的组件 新建一个alertip.vue组件；组件代码如下123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;tip&quot;&gt; &lt;p&gt;&#123;&#123;alertText&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;button @click=&quot;closeTip&quot;&gt;关闭&lt;/button&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;tip&apos;, components: &#123; &#125;, data() &#123; return &#123; &#125; &#125;, props: [&apos;alertText&apos;], //接收传的值 methods:&#123; closeTip()&#123; this.$emit(&apos;closeTip&apos;)；//分发事件 &#125; &#125;, &#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;!-- 此处的样式只是添加了效果，没有进行准确的排版，这里主要将vue的写法！--&gt;&lt;style scoped&gt;.tip&#123; width: 400px;height: 200px; overflow: hidden; position: fixed; left:38%;top:20%; background: #fff; border: 1px solid #ccc; padding:20px;&#125; &lt;/style&gt; 在其他组件里调用123456789101112131415161718192021222324252627&lt;/template&gt;&lt;div&gt; &lt;alertip v-show=&quot;alertipShow&quot; @closeTip=&quot;alertipShow = false&quot; :alertText=&quot;alertText&quot;&gt;&lt;/alertip&gt; //此处传值，点击事件 &lt;el-button type=&quot;primary&quot; @click=&quot;alerts()&quot;&gt;点击此按钮，出现浮动窗口&lt;/el-button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import alertip from &apos;./components/alertip.vue&apos;; //此处注意组件的路径 export default &#123; name: &apos;app&apos;, components: &#123; alertip &#125;, data() &#123; return &#123; alertipShow:false, alertText:&apos;&apos; &#125; &#125;, methods: &#123; alerts()&#123; this.alertText=&quot;此处的值为传过去的值，不同的页面用的同一个组件，但是弹出的内容是不同的！,这个信息在app组件里&quot;; this.alertipShow = true; &#125;, &#125;&#125; &lt;/script&gt; 其他页面同样的方法可以调用！展示的效果是一样的，但是不同组件可以传入的值可以是不同的，展示的内容也是不同的，但是效果弹窗是一样的！1源码见：https://github.com/sky-xsk/vue2.0-start- 给加个“star”哦！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0/Webpack 一个简单的todolist实例]]></title>
    <url>%2F2017%2F04%2F17%2Fvue2-0-Webpack-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84todolist%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[用的vue-cli,这里就不写过程了，直接上代码吧！同样自己用webpack自己搭一个项目实例！ 1234github地址：https://github.com/sky-xsk/vue2.0-start-vue2.0写的项目：https://github.com/sky-xsk/elem如果有帮助，请给个star； 首先是html12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;todo&quot;&gt; &lt;h2&gt;todolist&lt;/h2&gt; &lt;div class=&quot;t_input&quot;&gt; &lt;span&gt;&lt;input type=&quot;text&quot; class=&quot;t_titles&quot; placeholder=&quot;请输入。。。&quot; v-model=&quot;text&quot; @keyup.13=&quot;add()&quot;&gt;&lt;/span&gt; &lt;span&gt;&lt;button class=&quot;t_add&quot; @click=&quot;add()&quot;&gt;添加&lt;/button&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;t-cont&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in todolist&quot; track-by = &quot;$index&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;item.state&quot; class=&quot;checkbox&quot;/&gt; &#123;&#123;`$&#123;index+1&#125;. `&#125;&#125; &#123;&#123;item.value&#125;&#125; &lt;span @click = &quot;del(index)&quot;&gt;删除&lt;/span&gt; &lt;span @click = &quot;edit(index)&quot;&gt;编辑&lt;/span&gt; &lt;/li&gt; &lt;div class=&quot;check_che&quot; @click=&quot;remove()&quot; v-show=&quot;select.length &gt; 0&quot; &gt;删除选中&lt;/div&gt; &lt;p v-show=&quot;todolist.length == 0&quot;&gt;暂无数据！&lt;/p&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; export default &#123; name: &apos;todo&apos;, data() &#123; return &#123; todolist:[], text:&apos;&apos;, state: false, &#125; &#125;, methods:&#123; //添加 add()&#123; if(this.text == &apos;&apos;)&#123; return &#125;else&#123; this.todolist.push (&#123; value:this.text, state: false, &#125;) &#125; this.text=&apos;&apos;; &#125;, //删除 del(index)&#123; this.todolist.splice(index,1); &#125;, //删除选中 remove()&#123; this.todolist = this.todolist.filter((index) =&gt; !index.state) &#125;, //编辑 edit(index)&#123; this.text = this.todolist[index].value; this.todolist.splice(index,1); &#125; &#125;, //计算属性 computed: &#123; select() &#123; return this.todolist.filter((index) =&gt; index.state == true) &#125; &#125; &#125;&lt;/script&gt; css123456789101112131415&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.t_titles&#123; width: 400px; height: 35px; font-size: 16px; padding-left: 10px;&#125;.t_add&#123; width: 60px; height:40px; font-size: 16px; vertical-align: middle;&#125;.t-cont&#123; width:100%; margin-top: 20px; margin: 0 auto;&#125;.t-cont ul li&#123;list-style: none; height: 30px; border: 1px solid #ccc; line-height: 30px; text-align: left; padding-left: 10px;&#125;.t-cont ul li span&#123;float: right; cursor: pointer; padding-right: 10px;&#125;.t-cont ul li input&#123;padding-top: 5px;&#125;.checks&#123; width: 15px; height: 15px; border-radius:50%; border: 1px solid #ccc; display: inline-block;margin-top: 5px; cursor: pointer; &#125;.checkbox &#123; width: 18px; height: 18px;border: 1px solid #ccc; border-radius: 100%; position: relative; margin-right: 6px; vertical-align: middle; &#125;.checkbox:checked &#123;border-color: deepskyblue;&#125;.checkbox:checked:before &#123; content: &apos;&apos;; display: block; width: 80%; height: 80%; position: absolute; left: 50%; top: 50%;transform: translate(-50%, -50%); background: deepskyblue; border-radius: 100%;&#125;.check_che&#123;border: 1px solid #ccc; padding:10px;&#125;&lt;/style&gt; 效果如截图： 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用sourceTree，将自己的代码上传到github上去]]></title>
    <url>%2F2017%2F04%2F15%2F%E7%94%A8sourceTree%EF%BC%8C%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0github%E4%B8%8A%E5%8E%BB%2F</url>
    <content type="text"><![CDATA[GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 sourceTree是一个工具；接下来我就教大家怎么把自己的代码传到github上面去； 首先你注册一个sourceTree的账号和github的账号，我这边就不写怎么去注册了注册好账号后，在github上点击如图； 点击后，会弹出如下页面； 输入项目名称后，点击绿色按钮，即可； 打开新建的项目，点击绿色按钮，将地址复制下来 在本地新建一个文件夹，作为本地的仓库，接下来，打开sourceTree客户端，单击新建/克隆如图； 源路径填写刚才复制的地址，目标路径就会刚才新建的文件夹的路径；填好后，点击确定即可，这样你的仓库就克隆到本地了； 克隆到本地的仓库有个.git文件千万不要删掉；然后自己的代码复制到本地的仓库中去，然后点击Stage All后单击提交 接下来点击‘推送’ 到github上面看一下，代码推送成功！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>sourceTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0，jsonp的一个小案例 请求百度搜索的接口]]></title>
    <url>%2F2017%2F03%2F10%2Fvue2-0%EF%BC%8Cjsonp%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%A1%88%E4%BE%8B-%E8%AF%B7%E6%B1%82%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[我用的是vue-cli，可以自己去下一个试试看！JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的script 元素是一个例外。利用 script 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。 这里用的”vue-resource”里的示例；下面开始了： #html:123456789101112131415&lt;template&gt; &lt;div class=&quot;bar&quot;&gt; &lt;div id=&quot;box&quot;&gt; &lt;h1&gt;jsonp请求百度接口&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;t1&quot; @keyup=&quot;get($event)&quot; placeholder=&quot;请输入您要搜索的关键词&quot; class=&quot;input_s&quot; @keydown.down=&quot;changeDown()&quot; @keydown.up.prevent=&quot;changeUp()&quot;&gt; &lt;ul class=&quot;ul_se&quot;&gt; &lt;li v-for=&quot;(value,$index) in myData&quot; :class=&quot;&#123;gray:$index==now&#125;&quot; @click=&quot;clickChose($index)&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p v-show=&quot;myData.length==0&quot;&gt;暂无数据...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; #js:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; export default &#123; data() &#123; return &#123; myData:[], t1:&apos;&apos;, now:-1, &#125; &#125;, methods:&#123; get(ev)&#123; //键盘操作 if(ev.keyCode==38 || ev.keyCode==40) return; if(ev.keyCode==13)&#123; window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1); this.t1=&apos;&apos;; &#125; this.$http.jsonp(&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;, //跨域请求接口 &#123; params: &#123; wd:this.t1, &#125;, jsonp:&apos;cb&apos; &#125;).then(function(res)&#123; this.myData = JSON.parse(res.bodyText).s &#125;,function()&#123; console.log(&quot;请求失败！！！&quot;) &#125;); &#125;, changeDown()&#123; //下键选择 this.now++; if(this.now==this.myData.length)this.now=-1; this.t1=this.myData[this.now]; &#125;, changeUp()&#123; //上键选择 this.now--; if(this.now==-2)this.now=this.myData.length-1; this.t1=this.myData[this.now]; &#125;, clickChose($index)&#123; //鼠标选择搜索关键词事件 this.now = $index; this.t1=this.myData[this.now]; window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1); &#125;, &#125;, &#125;&lt;/script&gt; #css:1234567&lt;style scoped&gt;.ul_se&#123; background: #fff; border: 1px solid #ccc; width: 100%;&#125;.ul_se li&#123;list-style: none; height: 30px; line-height: 30px; cursor: pointer;&#125;.input_s&#123;width: 400px; height: 30px; padding-left: 10px;&#125;.gray&#123;background: deepskyblue; color: #fff;&#125;.ul_se li:hover&#123;background: deepskyblue; color: #fff;&#125;&lt;/style&gt; 最终效果：当你在输入框里输入搜索的关键词的时候，就会自动将联想的词汇显示在下方，按一下“enter”键，即可跳转到搜索结果 的页面，同是按“上”，“下”键可以进行选择搜索的关键词，鼠标也可以进行操作选择，跳转！ 以后搜索，直接打开就可以了！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于es6的部分语法介绍]]></title>
    <url>%2F2017%2F03%2F02%2F%E5%85%B3%E4%BA%8Ees6%E7%9A%84%E9%83%A8%E5%88%86%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[#es6的介绍ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准,组件分为：ECMA/DOM/BOMECMAscript简写是ECMA或者叫ES； #在线编译e6转换es5如果不是太熟悉的话，可以用用这个转换的小工具，对比一下es6语法的差别；1http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;code=%20const%20A%20%3D%20&apos;static%20A&apos;%3B%0D%0A%09%20%20%20%09%20console.log(A)%3B%0D%0A%09%20%20%20%09%20let%20b%20%3D&apos;b&apos;%3B%0D%0A%09%20%20%20%09%20console.log(b)%3B%0D%0A%0D%0A%09%20%20%20%09%20alert(A) #变量let1.let的使用范围有限，只能在代码里面使用，在代码外面的还就会弹出未定义,不能重复声明，也就是用同一个变量不能用两次2.如果是var的话，只有在函数里才有作用域 ###eg:12345678910111213141516#html:&lt;ul&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt;&lt;/ul&gt;#js:window.onload = function()&#123; var ali = document.getElementsByTagName(&apos;li&apos;); for(let i = 0;i&lt;ali.length;i++)&#123; ali[i].onclick = function()&#123; alert(i) &#125; &#125; &#125; #constconst的用法比较好理解，它一旦被赋值的话就不能被修改，常量必须在声明的同时赋值，否则会报错，而且通常常量用大写字母规范；和es5一样的一点是，不能重复的去声明，否则是会有问题的； ###eg:12const TEST1 = 0;const TEST2 = 1; #字符串的连接在es6中，字符串的连接变得更简单了，1###eg： var a = “我是字符串1”;var b = “我是字符串2”;var c = 把他们连起来$(a)把他们连起来$(b);console.log(c);123#给变量赋值现在的赋值更简单，更灵活，同时也减少的不少的代码量；###eg: var [a,b,c] = [1,2,3];打印一个：console.log(a);打印多个：console.log(a,b,c);1对，就是这个样！ var { a, c ,b } = { a:1, b:2 , c:3 }打印一个：console.log(a);打印多个：console.log(a,b,c);123```var [a,[b,c],d] = [1,[2,3],4];console.log(a,b,c,d); 12var [&#123;a,e&#125;&#125;,[b,c],d] = [&#123;e:&apos;eeee&apos;,a:&apos;aaaaa&apos;&#125;,[1,2],5] //这个有点变化，注意了console.log(a,b,c,d) 自己会一一对应的，不会因为顺序不同导致值的变化！ #数组数组的操作基本相同，这里介绍一个‘from’方法；‘复制数组’12345var arr = [1,2,3];var arr2 = Array.from(arr);arr2.pop();console.log(arr,arr2);Array.from(arr); 1234var arr = [1,2,3];var arr2 = [...arr];arr2.pop();console.log(arr,arr2); 这两种方法是相同的； #遍历es6用的是for…of..;有点变化！1234var arr = [1,2,2,2,2,2,2,3,4]; for(var i of arr)&#123; console.log(i)&#125; 值得注意的是:可以循环数组，但是不能循环json，他主要是循环map对象用的; #map12345var map = new Map();map.set(&apos;a&apos;,&apos;apple&apos;);map.set(&apos;b&apos;,&apos;banbana&apos;);alert(map.get(&apos;b&apos;)); //获取map.delete(‘a’); //删除 12345678var map = new Map();map.set(&apos;a&apos;,&apos;apple&apos;); map.set(&apos;b&apos;,&apos;banbana&apos;); map.set(&apos;c&apos;,&apos;orange&apos;); map.set(&apos;d&apos;,&apos;pear&apos;); for( var [key,value] of map)&#123; //循环了一下 console.log(value); &#125;; 12345var arr = [&apos;q&apos;,&apos;w&apos;,&apos;e&apos;,&apos;a&apos;,&apos;d&apos;,&apos;f&apos;,&apos;r&apos;] //一套带走，lol //entries循环key和value for(var name of arr.keys())&#123; console.log(name) &#125; #箭头函数（经常会遇到的，刚开始会很懵逼）这里做个对比，就一目了然了； ###es6 eg:123456789101112131415#html&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;#css#box&#123; width:200px; height:200px; border:1px solid #000; &#125;#jswindow.onload = function()&#123; var oBox = document.getElementById(&apos;box&apos;); oBox.onclick = () =&gt;&#123; oBox.style.background = &apos;red&apos;； &#125;&#125; ###es5 eg:123456789101112131415#html&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;#css#box&#123; width:200px; height:200px; border:1px solid #000; &#125;#jswindow.onload = function()&#123; var oBox = document.getElementById(&apos;box&apos;); oBox.onclick=function()&#123; oBox.style.background = &apos;red&apos;； &#125;&#125; #面向对象这个写法，感觉和java里的类有点像；1234567891011121314class Person&#123; constructor(name,age)&#123; this.name = name this.age = age &#125; showName()&#123; return this.name; &#125; showAge()&#123; return this.age; &#125; &#125; var p1 = new Person(&apos;aaa&apos;,10); alert(p1.showName()); 小提示：在es6的语法当中，私有作用域的代码块：{ } 包起来的就是代码块，就形成了一个作用域，称为块级作用域,这个的话和es5就有很大差别； ~~~后期会继续更新的; 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来来来，通俗的理解一下原型，原型链......]]></title>
    <url>%2F2016%2F12%2F26%2F%E6%9D%A5%E6%9D%A5%E6%9D%A5%EF%BC%8C%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[今天，在网上看到这个讲原型和原型链的通俗的分析，感觉对理解还是有帮助的，特此分享： 原型链理解起来有点绕了，网上资料也是很多，每次晚上睡不着的时候总喜欢在网上找点原型链和闭包的文章看，效果极好。不要纠结于那一堆术语了，那除了让你脑筋拧成麻花，真的不能帮你什么。简单粗暴点看原型链吧，想点与代码无关的事，比如人、妖以及人妖。 1）人是人他妈生的，妖是妖他妈生的。人和妖都是对象实例，而人他妈和妖他妈就是原型。原型也是对象，叫原型对象。 2）人他妈和人他爸啪啪啪能生出一堆人宝宝、妖他妈和妖他爸啪啪啪能生出一堆妖宝宝，啪啪啪就是构造函数，俗称造人。 3）人他妈会记录啪啪啪的信息，所以可以通过人他妈找到啪啪啪的信息，也就是说能通过原型对象找到构造函数。 4）人他妈可以生很多宝宝，但这些宝宝只有一个妈妈，这就是原型的唯一性。 5）人他妈也是由人他妈他妈生的，通过人他妈找到人他妈他妈，再通过人他妈他妈找到人他妈他妈……，这个关系叫做原型链。 6）原型链并不是无限的，当你通过人他妈一直往上找，最后发现你会发现人他妈他妈他妈……的他妈都不是人，也就是原型链最终指向null。 7）人他妈生的人会有人的样子，妖他妈生的妖会有妖的丑陋，这叫继承。 8）你继承了你妈的肤色，你妈继承了你妈他妈的肤色，你妈他妈……，这就是原型链的继承。 9）你谈对象了，她妈让你带上房产证去提货，你若没有，那她妈会问你妈有没有，你妈没有那她妈会问你妈她妈有没有……这就是原型链的向上搜索。 10）你会继承你妈的样子，但是你也可以去染发洗剪吹，就是说对象的属性可以自定义，会覆盖继承得到的属性。 11）虽然你洗剪吹了染成黄毛了，但你不能改变你妈的样子，你妈生的弟弟妹妹跟你的黄毛洗剪吹没一点关系，就是说对象实例不能改动原型的属性。 12）但是你家被你玩火烧了的话，那就是说你家你妈家你弟们家都被烧了，这就是原型属性的共享。 13）你妈外号阿珍，邻居大娘都叫你阿珍儿，但你妈头发从飘柔做成了金毛狮王后，隔壁大婶都改口叫你包租仔，这叫原型的动态性。 14）你妈爱美，又跑到韩国整形，整到你妈他妈都认不出来，即使你妈头发换回飘柔了，但隔壁邻居还是叫你金毛狮王子。因为没人认出你妈，整形后的你妈已经回炉再造了，这就是原型的整体重写。(转载！) 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js如何判断一个对象是不是Array？]]></title>
    <url>%2F2016%2F12%2F26%2Fjs%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AFArray%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[当听到这个问题的时候，肯定有人第一个想法就是用“typeof”来判断，实则，并不能实现；很忧伤！下面咱先来说一说“typeof”，在js中，对于Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任​，大家都懂的！ typeof​12var arr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);​​alert(typeof(arr)); 你会收到一个object ；什么破玩意；是不是这个时候想把键盘摔了，摔了没关系，再买吧！往下看： instanceof咱不能一条道走到黑，咱们得找其他的路子啊，对不对？JavaScript中instanceof运算符会返回一个 Boolean 类型的值，指出对象是否是特定类的一个实例。 使用方法：result = object instanceof class,还是刚刚的数组，成功的返回 true。​请看下面，看实际代码：12var arrayStr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);alert(arrayStr instanceof Array); 啊，成功了！高兴吧！这样真的可以了吗？是吗？其实​instanceof还是有一定的局限性的，一想到这，不是验证正确了吗？没毛病啊！事实上在多个frame中穿梭就会产生大问题了​？？？123456var iframe = document.createElement_x(&apos;iframe&apos;); document.body.appendChild(iframe); xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);//这个写法老古董IE下是不支持的，FF下才有;alert(arr instanceof Array); // falsealert(arr.constructor === Array); // false 返回结果为两个False，让人大失所望。为毛？ ​Object.prototype.toString( ) ECMA-262 写道1234Object.prototype.toString( ) When the toString method is called, the following steps are taken:Get the [[Class]] property of this object.Compute a string value by concatenating the three strings “[object “, Result (1), and “]”.Return Result (2) 上面的规范定义了Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。还是先来看看在ECMA标准中Array的描述吧。12new Array([ item0[, item1 [,…]]])The [[Class]] property of the newly constructed object is set to “Array”. 于是利用这点，第三种方法登场了。call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是’[object Array]’，以判断其是否是Array的实例。也许你要问了，为什么不直接o.toString()？嗯，虽然Array继承自Object，也会有toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：） 与前面几个方案不同，这个方法很好的解决了跨frame对象构建的问题，经过测试，各大浏览器兼容性也很好，可以放心使用。一个好消息是，很多框架，比如jQuery、Base2等等，都计划借鉴此方法以实现某些特殊的，比如数组、正则表达式等对象的类型判定，不用我们自己写了。另外Ext3 也已经换成这样的写法了;12isArray : function (v)&#123; return toString.apply(v) === &apos;[object Array]&apos;;&#125; 4.JQ中$isArray();话不多说，直接上代码吧！1234$(document).ready(function()&#123; var Arr = [&quot;4&quot;,&quot;8&quot;,&quot;1&quot;,&quot;3&quot;]; alert($.isArray(Arr));​&#125;)​ 返回的值为​Boolean 类型的值，是数组则返回一个“true”，反之“false”成了！​行就到这吧！希望大家多多支持！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈，实例mttq；]]></title>
    <url>%2F2016%2F12%2F20%2F%E6%B5%85%E8%B0%88%EF%BC%8C%E5%AE%9E%E4%BE%8Bmttq%EF%BC%9B%2F</url>
    <content type="text"><![CDATA[MQTT - MQ Telemetry TransportMQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。​ 早在1999年，IBM的Andy Stanford-Clark博士以及Arcom公司ArlenNipper博士发明了MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）技术[1] 。据Andy Stanford-Clark博士称，MQTT将在今年和明年呈现爆炸式增长。MQTT的话题是我俩谈论开源物联网平台Pachube时提到的。Stanford-Clark认为Pachube很酷，其不足之处是不具备真正的推送功能。你需要不断轮询才能得到即时数据。这正是MQTT能够实现的，他提到了使用推送通信系统的石油管道检测系统。轻量级的 machine-to-machine 通信协议。publish/subscribe模式。基于TCP/IP。支持QoS。适合于低带宽、不可靠连接、嵌入式设备、CPU内存资源紧张。是一种比较不错的Android消息推送方案。FacebookMessenger采用了MQTT。MQTT有可能成为物联网的重要协议。 下面一个实例，直接看代码：我放到云盘了，可以下载！1https://pan.baidu.com/s/1skZADJZ 例子有问题的话可以私信我！123这里说一下例子的使用方法：1.先去config去配置服务器的地址，前提是在服务器上已经配置好了MQTT协议，2.配置好后，将index.html在浏览器中打开，打开两份，这样你在一个页面发送信息，另一个页面就可以收到了！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>mttq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap VS jQuery Mobile 对比！]]></title>
    <url>%2F2016%2F12%2F08%2FBootstrap-VS-jQuery-Mobile-%E5%AF%B9%E6%AF%94%EF%BC%81%2F</url>
    <content type="text"><![CDATA[很多新手纠结这个问题？两个框架都能够支持做手机网页，那么它们的区别是什么呢，适用场景是什么呢？下面我们从这几个方面比较这两个框架：解决问题、功能、适用场景。 解决问题 ###Bootstrap是一个css框架，针对解决的问题有：1.跨设备的网页响应式布局问题。随着手机、平板、各分辨率屏幕的出现，如何能够一套前端在所有设备上自由适应？2.多人合作的前端布局和样式的规范问题3.常用前端css组件，如按钮、连接、表单、表格、分页组件、下拉菜单、导航栏、ICON等等4.常用JS前端组件（需要扩展js支持），如表单验证、Tips、Popup等等 jQuery Mobile是移动前端框架jQuery Mobile是移动前端框架，包含js、html、css，提供一套完整的移动前端开发组件，可以比喻成Android开发框架，尽可能提供移动APP所具有的所有功能，针对解决的问题有：1.移动网页APP所常用的组件，例如：手机导航栏、选项卡、底部菜单、列表、表单等各种组件，而这些与Bootstrap提供的组件有很大区别，jQuery Mobile提供的是类似手机APP的组件，只用于移动网页，而Bootstrap提供的是面向所有设备的组件，并没有对移动设备专门考虑，与移动APP的组件体验不一样。2.网页页面之间转换效果3.异步数据加载 功能 Bootstrap其核心主要是一个css样式框架，基于css 的Media Query功能实现了响应式布局，能够帮助前端开发人员快速布局、快速开发、合作开发。它必须借助jQuery类似的js框架来实现Ajax数据交互。 jQuery Mobile其核心是一个完整的WebAPP框架，加入了一个轻量级的jQuery可以实现Dom操作，在jQuery的基础上提供了一系列类似移动APP的Widget（视图组件），提供了一套不错的页面转场效果，可通过Ajax实现与后端数据交互。 适用场景 Bootstrap通常用于：展示网站的响应式布局开发，使得网站可以在不同设备上方便浏览；以及网站后台管理系统的前端CSS框架。 jQuery Mobile通常用于：期望接近移动APP体验的WebAPP，项目只运行在手机端，不用于电脑设备展示（虽然是可以展示的，但是效果不好）。 总结 如果做跨设备响应式前端，选择Boostrap；如果仅作移动端，期望得到近似APP的WebAPP，使用jQuery Mobile。 如果做一个产品级的WebAPP，当前jQuery Mobile的能力并不能让你满意，自己开发响应式布局框架和WebApp组件是必然要走的路。 最后希望初学者可以掌握这两种框架，还有推荐一个js库，zepto.js,这个框架在开发移动端的时候，很便利，和jQ很像，但又有所不同，但是zepto.js更小，更便捷，zepto.js还提供了手机端的touch的api，真心很棒！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>Bootstrap</category>
        <category>jQuery Mobile</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
        <tag>jQuery Mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 CSS3 怎么绘制需要的几何图形]]></title>
    <url>%2F2016%2F08%2F13%2F%E7%94%A8-CSS3-%E6%80%8E%E4%B9%88%E7%BB%98%E5%88%B6%E9%9C%80%E8%A6%81%E7%9A%84%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[圆形思路：给任何正方形元素设置一个足够大的 border-radius ，就可以把它变成一个圆形.代码如下： 12345html:&lt;div class=&quot;size example1&quot;&gt;&lt;/div&gt;css:​​ .size&#123;width:200px; heigh: 200px;background​:#8BC34A;&#125;​.example1&#123;border-radius:100px;&#125; 自适应椭圆1234html:&lt;div class=&quot;example3&quot;&gt;&lt;/div&gt;css:.example3&#123; width:200px; height:150px; border-radius:50%; background:#8BC34A;&#125; 自适应的半椭圆:沿横轴劈开的半椭圆1234html:&lt;div class=&quot;example4&quot;&gt;&lt;/div&gt;css:.example4&#123;width:200px;height:150px; border-radius:50%/100%100%00; background:#8BC34A;&#125; 自适应的半椭圆:沿纵轴劈开的半椭圆1234html:&lt;div class=&quot;example5&quot;&gt;&lt;/div&gt;css：.example5&#123;width:200px; height:150px; border-radius:100%00100%/50%; background:#8BC34A;&#125; 四分之一椭圆1234html:&lt;div class=&quot;example６&quot;&gt;&lt;/div&gt;css：.example6&#123; width:160px; height:100px;border-radius:100% 0 0 0;background:#8BC34A;&#125; 用椭圆绘制opera浏览器的logo（示例借鉴）思路：绘制opera浏览器的logo,分析起来不难，就只有两个图层，一个是最底部的椭圆，一个是最上面那层的椭圆。先确定一下最底层的椭圆宽高，量了一下，水平宽度为258px，垂直高度为275px，因为其是一个对称的椭圆，没有倾斜度，故4个角均为水平半径为258px，垂直半径为275px的4个相等椭圆，用同样的办法确定最里面的椭圆的半径，因此，四个角均为水平半径120px，垂直半径为229px的椭圆，代码如下：12345678910111213141516171819202122232425html:&lt;div class=&quot;opera&quot;&gt; &lt;div ​class=&quot;opera-top&quot;&gt;&lt;/div&gt;&lt;/div&gt;css:.opera&#123; width:258px; height:275px; background:#F22629; border-radius:258px258px258px258px/275px275px275px275px; position:relative;&#125;.opera-top&#123; width:112px; height:231px; background:#FFFFFF; border-radius:112px112px112px112px/231px231px231px231px; position:absolute; left:50%; right:50%; top:50%; bottom:50%; margin-left:-56px; margin-top:-115px;&#125; 如有错误，请大家多多指教！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>css3.0</tag>
      </tags>
  </entry>
</search>