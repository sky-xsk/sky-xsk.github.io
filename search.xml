<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解前端语义化（转载）]]></title>
    <url>%2F2017%2F05%2F25%2F%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.Web标准 Web标准是由一系列标准组合而成。一个网页主要由三部分组成：结构层、表现层和行为层。对应的标准也分三方面：结构化标准语言主要包括XHTML和HTML以及XML，表现层标准语言主要包括CSS，行为标准主要包括对象模型，DOM、ECMAScript等。结构化标准语言，就是W3C规定的那样; ㈠标签的书写，需要开始和结束。单便签除外；㈡块级元素不能放在标签里面。li内可以包含div标签。㈢块元素里面可以放在块和内联，特殊的 p和 h1—h6里面不要放块元素，li和div可以放很多。因为这两个标签，本身就有容器的属性㈣内联里面要放内联，不要放块。㈤结构与表现分离㈥命名一定要规范表现层标准：css的书写，首先要尽可能使用外部引入的方式，因为结构层尽可能的减少表现层的代码过多出现。达到分离的目的。css的选择器有哪些，那些属性可以继承，那些不可以继承。他们之间的优先级是怎么样的。怎么用最简洁的css代码表达设计者的想法，而不只是实现设计者的想法就没事了。我们要的是代码简洁，代码过多，反而让浏览器解析很多，浪费时间。行为层标准：主要是JavaScript中的知识。比如DOM、ECMAScript。使用javascript中的标准，即可。一般对于用户的行为，或者说页面上的动态效果的一些特殊实现，我们可以会考虑到使用javascript来进行书写，但是代码的可复用性，模块化。变量，作用域。可能更多的就是javascript的规定了。自己把自己的理解程度说出来就可以了。 2.标签语义化 什么是语义化？其实简单说来就是让机器可以读懂内容。web页面的解析是由搜索引擎来进行搜索，机器来解析。所以语义化的标准是，尽可能的让机器读懂。最初的HTML中如h1~h6、thead、ul、ol等标签，通过标签的语义，最初设计的想法，来达到语义化的要求。如标题、表头、无序、有序列表，搜索引擎很好的利用了这些语义化标签抓取内容后来，最初定义的HTML语义化标签，不足以实现对Web页面各个部分的功能或位置描述，所以Web前端人员利用HTML标签的id和class属性，进一步对HTML标签进行描述，如对页脚HTML标签添加如id=”footer”或者class=”footer”的属性（值），以“无声”的方式在不同的前端程序员或者前后端程序员间实现交流。制定HTML5的W3C组织采用了诸如header、footer、section等语义化标签，来进行页面布局的设计想法，弥补了采用id=”header”或者class=”section”等。更深层次的语义化，是自己在团队合作的过程中，对于需要声明的变量和class，id。尽可能使用彼此能理解的英文。这样减少合作的成本，加快合作的效率。 为什么要语义化？ 1.)为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 2.)用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 3.)有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 4.)方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 5.)便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 写HTML代码时应注意什么？ 1.)尽可能少的使用无语义的标签div和span； 2.)在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 3.)不要使用纯样式标签，如：b、font、u等，改用css设置。 4.)需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 5.)使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 6.)表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 7.)每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 3.布局和页面架构 布局方面，分为两种：代码上的，视觉上的。代码就是最典型的DIV+CSS布局，表格布局（table），iframe框架(特殊地方使用)布局，具体的使用。可以对应的看一下。目前最流行的是，div+css布局的方式。当然布局的概念比较广泛，因为在css中也存在很多布局的方法，比如float和position。具体理解的程度，需要自己去详细的阐述。视觉的布局：比如单页面的，九宫格的，瀑布流布局，tab切换布局，手风琴布局等。—————————————–以上是主题，一下就是更高级的东西（可看可不看）————————————————-页面架构： 在谈前端架构之前，需要先探讨一下不同人群对前端产生的困惑。前端这个职业最近几年才逐渐被认可，之前一直是低端的代名词，所以多数高手很不屑搞这个。之前的很多项目，人们对前端这块的要求也只是能用就行，所以很少会在上面去细致、深入地建立一套完善体系。而多数产品的技术经理也会是后端出身的，往往对前端的认识还停留在Java Struts那个原始的MVC模型上，或者首先想到的就是GWT和JSF，这是从后端角度出发的一种视角。用这类思维方式做出来的产品，一般用户体验都不会很好。另一方面，从界面层上手的人群，他对用户体验这方面会把控得比较好，但通常缺架构意识，或者说是软件工程的意识。在界面层比较复杂的情况下，很可能会有失控的趋势。对整个系统结构的认知程度通常不够深入，也缺乏设计模式等方面的知识。 架构的本质是什么？其实也是一种管理。通常我们所说的管理，都是指对于任务和人员的管理，而架构管的是机器和代码。比如说，机器的部署属于运维的物理架构，SOA属于服务架构，那么，前端的架构指什么呢？ 长期以来，前端所处的位置是比较偏应用层，而且是很薄的一层，而架构又要求深度和广度，所以之前在前端里面做架构，好比在小水塘里游泳，稍微扑腾两下就到处碰壁。但最近这几年来，前端的范围被大大拓展了，所以这一层逐渐变得大有可为。 怎样去理解架构呢？在早期的文字MUD游戏里，有这么一句话：“你感觉哪里不对，但是又说不上来。”在我们开发和使用软件系统的过程中，或多或少会遇到这样的感觉，有这种感觉就说明架构方面可能有些问题。 在狭义的前端领域，架构要处理的很重要的事情是组件的集成。由于JavaScript本身缺乏命名空间这样的机制，多数框架都倾向于自己搞一套，所以这方面的碎片化是很严重的。如果一个公司的实力不足以自研所有用到的组件，就会一直面临这方面的问题。 比如说，在做某个功能的过程中，发现需要一个组件，时间来不及做，就到网上搜了个，加到代码里面，先运行起来再说。一不小心，等功能做完的时候，已经引入了无数种组件了，有很多代码是重叠的，可能有的还有冲突，外观也不一致。 环顾四周的大型互联网公司，基本上都有自己的前端框架，比如阿里的Kissy和Arale，腾讯的JX，百度的Tangram，360的QWrap等，为什么？因为要整合别的框架，并且在此基础上发展适合自己的组件库，代价非常大，初期没办法的时候只能凑合，长期来说，所有代码都可控的意义非常重要。 那么，是不是一套框架可以包打天下呢，这个真的很难。对于不同的产品形态，如果想要用一套框架去适应，有的会偏轻，有的又偏重，有的要兼容低端浏览器，有的又不要，很难取舍。 常见的前端产品形态包括： 内容型Web站点 侧重渲染方面的优化，前端逻辑比重小 操作型B/S系统 以数据和逻辑为中心，界面较规整 内嵌Web的本地应用 要处理缓存和一些本地接口，包括PC客户端和移动端 另外有Web游戏，因为跟我们的企业形态关系不大，而且也比较独特，所以不包含在内。这三种产品的前端框架要处理的事情显然是不太一样的，所以可以细分成2-3种项目模板，整理出对应的种子项目，供同类产品初始化用。 最近我们经常在前端领域听说两个词：全端、全栈。 全端的意思是，原来的只做在浏览器中运行的Web程序不够，还要做各种终端，包括iOS，Android等本地应用，甚至PC桌面应用。 为什么广义的前端应当包含本地应用呢？因为现在的本地应用，基于很多考虑，都变成了混合应用，也就是说，开发这个应用的技术，既包含原生的代码，也包含了嵌入的HTML5代码。这么一来，就造成了开发本地应用的人技能要求较广，能够根据产品的场景，合理选择每个功能应当使用的技术。 现在有一些PC端的混合应用开发技术，比如node-webkit和hex，前者的典型应用是Intel® XDK，后者的典型应用是有道词典，此外，豌豆荚的PC客户端也是采用类似技术的，也有一些产品是用的qt-webkit。这类技术可以方便做跨平台，极大减少开发工作量。 所以，我们可以看到，在很多公司，开发安卓、iOS应用的人员跟Web前端的处于同一个团队中，这很大程度上就是考虑到这种情况。 全栈的意思是，除了只做在浏览器中运行的代码，还写一些服务端的代码，这个需求又是从哪里来的呢？ 这个需求其实来自优化。我们要优化一个系统的前端部分，有这么一些事情可以做： HTML结构的优化，减少DOM树的层次等等 CSS渲染性能的优化，批量写入DOM变更之类 资源文件的优化，比如小图片的合并，图像格式的处理，图标字体的使用等 JavaScript逻辑的优化，模块化，异步加载，性能优化 加载字节量的优化，主要是分摊的策略 HTTP请求的优化 这里面，除了前三条，其他都可能跟后端有些关系，尤其是最后一条。但是前端的人没法去优化后端的东西，这是不同的协作环节，所以就很麻烦。 那么，如果有了全栈，这个问题可以怎么解决呢？ 比如说，我们要做最原始的小文件合并，可以在服务器做一些配置，把多个合并成一个请求，比如天猫的某个url： http://g.tbcdn.cn/kissy/k/1.4.1/??dom/base-min.js,event-min.js,event/dom/base-min.js,event/base-min.js,event/dom/touch-min.js,event/dom/shake-min.js,event/dom/focusin-min.js,event/custom-min.js,cookie-min.js?t=1.js 这个就很明显是多个文件合并而成的，9个小文件的请求，合并成了一个64k的文件请求。 这种简单的事情可以在静态代理服务器上配置出来，更复杂的就比较难了，需要一定的服务端逻辑。比如说，我们有多个ajax请求，请求不同的服务，每个请求的数据量都非常少，但因为请求数很多，可能会影响加载性能，如果能把它们在服务端就合并成一个就好了。但这个优化是前端发起的，传统模式下，他的职责范围有限，优化不到服务端去，而这多个服务很可能是跨产品模块的，想要合并，放在哪个后端团队都很怪异。 这可真难办，就像老虎追猴子，猴子上了树，老虎只能在下面干瞪眼。但是如果我们能让老虎上树，这就不是个问题了。如果有这么一层NodeJS，这一层完全由前端程序员控制，他就可以在这个地方做这种合并，非常的合理。 除此之外，我们常常会用到HTML模板，但使用它的最佳位置是随着产品的场景而不同的，可能某个地方在前端更好，可能某个地方在后端好些。到底放在哪合适，只有前端开发人员才会知道，如果前端开发人员不能参与一部分后端代码的开发，优化工作也还是做不彻底。有NodeJS之后会怎样呢，因为不管前端模板还是后端模板，都是JavaScript的，可以使用同一套库，这样在做调整的时候不会有代码迁移的烦恼，直接把模板换地方即可。 现在，也有很多业务场景有实时通信的需求，目前来说最合适的方案是Socket.io，它默认使用NodeJS来当服务端，这也是NodeJS的一个重要使用场景。 这样，前端开发人员也部分参与了运行在服务端的代码，他的工作范围从原先客户端浏览器，向后拓展了一个薄层，所以就有了全栈的称呼。至于说这个称呼还继续扩展，一个前端开发人员从视觉到交互到静态HTML到JavaScript包办的情况，这个就有些过头了。 以上这些，主要解决的都是代码层面的事情。另外有一个方面，也是需要关注，但却常常不能引起重视的，那就是前端的工程化问题。 早期为什么没有这些问题？因为那时候前端很简单，复杂度不高，现在整个很复杂了，就带来了很多管理问题。比如说整个系统的前端都组件化了之后，HTML会拆分成各种模板，JavaScript会拆分成各种模块，而CSS也通过LESS或者SASS这种方式，变成了一种编译式的语言。 这时候，我们考虑一个所谓的组件，它就比较麻烦了。它可能是一个或者多个HTML模板，加上一个或者多个JavaScript模块，再包含CSS中的一部分构成的，而前两者都可能有依赖项，三个部分也都要避免与其他组件的冲突。 这些东西都需要管理，并且提供一种比较好的方案去维护。在JavaScript被模块化之后，也可以通过单元测试来控制它们的质量，并且把这个过程自动化，每次版本有变更之前，保证它们最基本的正确性。最终，需要有一种自动化的发布机制，把这几类代码提取，打包合并，压缩，发布。 这个主题展开可以讲很多，所以我们不在本次分享中涉及。在我之前的几篇文章中，也阐述过观点。 目前这方面研究最深入的是之前百度FIS团队的张云龙，他的几篇文章在这里，强烈推荐阅读。 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>html/css</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的变量提升]]></title>
    <url>%2F2017%2F05%2F24%2Fjs%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[在JavaScript 中，函数及变量的声明都将被提升到函数的最顶部，变量可以在使用后声明，也就是变量可以先使用再声明。变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。虽然，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解；但是理解变量提升还是很有用的！ 实例1 123x=5; //设置x的值为5console.log(x); //5var x; //声明变量x 注意看看，下面的例子，和实例1是相同的，但是写法是不同的；123var x; //声明变量xx=5; //设置x的值为5console.log(x) //5 从上面2个例子，就大概知道变量提升了（hoisting）;为了更好的理解，看一下面的例子；实例21234var x=5; //初始化var y=1; //初始化console.log(x); //5console.log(y); //1 换一下位置实例31234var x=5; //初始化console.log(x); //5console.log(y); //undefinedvar y=1; //初始化 实例3的代码。等同于以下写法：12345var x=5; //初始化var y //这里y提升了，初始化的var y = 1 不会提升console.log(x); //5console.log(y); //undefinedy=1; //初始化 从实例2和实例3的对比可以看出， 在js中，只有声明的变量会提升，初始化的不会。再看一下，函数声明；实例4123456function foo()&#123; var x; console.log(x) x=5;&#125;foo() //undefined 和上面的例子差不多相同，接着往下看；1234567891011function test() &#123; foo(); // TypeError &quot;foo is not a function&quot; bar(); // 0 var foo = function () &#123; // 变量指向函数表达式 alert(1); &#125; function bar() &#123; // 函数声明 函数名为bar alert(0); &#125; &#125; test(); 命名函数：12345678foo(); // TypeError &quot;foo is not a function&quot; bar(); // valid baz(); // TypeError &quot;baz is not a function&quot; spam(); // ReferenceError &quot;spam is not defined&quot; var foo = function () &#123;&#125;; // foo指向匿名函数 function bar() &#123;&#125;; // 函数声明 var baz = function spam() &#123;&#125;; // 命名函数，只有baz被提升，spam不会被提升。 上面可以看出，只有函数式的声明才会连同函数体一起被提升。foo的声明会被提升，但是它指向的函数体只会在执行的时候才被赋值。 //函数声明：像这种形式：function foo(){}； 接下来，看看函数的声明和变量的声明的优先级；12345678910111213141516171819function a()&#123; &#125; var a; alert(a);//打印出a的函数体 -------------------var a; function a()&#123; &#125; alert(a);//打印出a的函数体 -------------------var a=1; function a()&#123; &#125; alert(a);//打印出1 -------------------function a()&#123; &#125; var a=1; alert(a);//打印出1 由此可以看出来什么？函数的声明比变量的声明具有高的优先级！ ECMAScript参考文档上说 如果变量在函数体类声明，则它是函数作用域。否则，它是全局作用域（作为global的属性）。变量将会在执行进入作用域的时候被创建。块不会定义新的作用域，只有函数声明和程序才会创造新的作用域。变量在创建的时候会被初始化为undefined。如果变量声明语句里面带有赋值操作，则赋值操作只有被执行到的时候才会发生，而不是创建的时候。(方便理解) 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么用vue-cli构建自己的vue2.0的项目]]></title>
    <url>%2F2017%2F05%2F23%2F%E6%80%8E%E4%B9%88%E7%94%A8vue-cli%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84vue2-0%E7%9A%84%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[博客里的一些小示例都是在vue-cli的基础上构建的，为了方便学习，这里把vue-cli构建项目的方法说一下！怎样从零开始，构建一个简单的vue2.0项目！ 这里首先说一下，vue-cli是什么？ vue-cli是官方提供的一个脚手架，个人感觉比较适合新手同学来学习vue！ 1.首先，要安装node和npm 这里先不说这两的安装方法，可以自行到网上搜索一下，例子还是很多的； 2.开始了，这里说一下，因为npm install安装的太慢，如果你的网速还比较渣的话，那我只能对你说自求多福吧！ 这里推荐使用淘宝镜像；一下是安装方法：打开命令行工具，输入： 1npm install -g cnpm --registry= https://registry.npm.taobao.org 安装完成后，输入 1cnpm -v 如果出现版本号，就说明安装成功了！ 3.接下来，安装webpack打开命令行工具输入：1npm install webpack -g 安装完成之后输入 webpack -v，如果出现相应的版本号，则说明安装成功。因为安装了淘宝的镜像，可以直接输入：1cnpm install webpack -g 4.接下来，安装vue-cli脚手架构建工具安装vue-cli脚手架构建工具，打开命令行工具输入：1npm install vue-cli -g 安装完成之后输入 vue -V（注意这里是大写的“V”）,如果出现相应的版本号，则说明安装成功。 5.新建一个文件夹，放置你的项目cd 目录路径，然后输入命令：123vue init webpack projectName //projectName是你的工程名称，可自行输入``` 接下来出现 $ vue init webpack projectName ——————— 这个是那个安装vue脚手架的命令This will install Vue 2.x version of the template. ———————这里说明将要创建一个vue 2.x版本的项目For Vue 1.x use: vue init webpack#1.0 projectName? Project name (projectName) ———————项目名称? Project name projectName? Project description (A Vue.js project) ———————项目描述? Project description A Vue.js project? Author Datura ——————— 项目创建者? Author Datura? Vue build (Use arrow keys)? Vue build standalone? Install vue-router? (Y/n) ——————— 是否安装Vue路由，也就是以后是spa（但页面应用需要的模块）? Install vue-router? Yes? Use ESLint to lint your code? (Y/n) n ———————是否启用eslint检测规则，这里个人建议选no,血的教训? Use ESLint to lint your code? No? Setup unit tests with Karma + Mocha? (Y/n) ——————-单元测试，可选可不选? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? (Y/n) ——————-单元测试，可选可不选? Setup e2e tests with Nightwatch? Yesvue-cli · Generated “projectName”.12&lt;h3&gt;6.启动项目&lt;/h3&gt;依次输入以下命令即可： cd exprice //切换到你的工程目录npm install //安装依赖，node-modulesnpm run dev //运行项目```出现下图，你就成功了 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现一些跨浏览器的兼容事件方法]]></title>
    <url>%2F2017%2F05%2F18%2Fjs%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用JavaScript实现事件的绑定，移除，以及一些常用的事件属性的获取，时常要考虑到在不同浏览器下的兼容性，下面给出了一个跨浏览器的事件对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var EventUtil = &#123; on: function(element, type, handler) &#123;/* 添加事件 */ if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123;//IE 注意：此时事件处理程序会在全局作用域中运行，因此用attachEvent绑定的事件，此时在事件处理函数里的this 等于window，使用时要注意 element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, off: function(element, type, handler) &#123;/* 移除事件 */ if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, getEvent: function(event) &#123;/* 返回对event对象的引用 */ return event ? event : window.event; &#125;, getTarget: function(event) &#123;/* 返回事件的目标 */ return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; /* 取消事件的默认行为 */ if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123;/* 阻止事件冒泡 */ if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, /* mouseover 和mouserout 这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。*/ getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123;//IE8 mouserout事件 return event.toElement; &#125; else if (event.fromElement) &#123;//IE8 mouseover事件 return event.fromElement; &#125; else &#123; return null;//其他事件 &#125; &#125;&#125; 调用如下：1234EventUtil.on(document, &quot;click&quot;, function(event)&#123;//为document元素绑定click事件 event = EventUtil.getEvent(event);//获取event事件对象 alert(&quot;Screen coordinates: &quot; + event.screenX + &quot;,&quot; + event.screenY);&#125;); 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么理解[].forEach.call()？]]></title>
    <url>%2F2017%2F05%2F16%2F%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-forEach-call-%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[今天，在网上看到javascript的[].forEach.call()写法，刚看到的时候有点蒙，不是太明白是什么意思！后来到网上查了一下，其实这东西是个简写的写法。如下：123456789function forEach(elems, callback) &#123; if([].forEach) &#123; [].forEach.call(elems, callback); &#125; else &#123; for(var i = 0; i &lt; elems.length; i++) &#123; callback(elems[i], i); &#125; &#125;&#125; [] 就是个数组，而且是用不到的空数组,用来就是为了访问它的数组相关方法。那完整的写法是什么呢？ 其实是这样的：1Array.prototype.forEach.call(...); 很显然，简写更方便。js中的forEach 方法，它可以接受一个函数参数，如下：1[1,2,3].forEach(function (num) &#123; console.log(num); &#125;); 上面的这句代码中，我们可以访问 this 对象，也就是 [1,2,3] ，可以看出，这个 this 是个数组。 最后， .call 是一个prototype，JavaScript函数内置的。 .call 使用它的第一个参数替换掉上面说的这个 this ，也就是你要传人的数组，其它的参数就跟 forEach 方法的参数一样了。123456[1, 2, 3].forEach.call([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], function (item, i, arr) &#123; console.log(i + &quot;: &quot; + item);&#125;);// 0: &quot;a&quot;// 1: &quot;b&quot;// 2: &quot;c&quot; 因此， [].forEach.call() 是一种快速的方法访问 forEach ，并将空数组的 this 换成想要遍历的list。 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单-Vue 2.0渐进式前端解决方案（Vue.js作者尤雨溪）(转载)]]></title>
    <url>%2F2017%2F05%2F15%2F%E7%AE%80%E5%8D%95-Vue-2-0%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88Vue-js%E4%BD%9C%E8%80%85%E5%B0%A4%E9%9B%A8%E6%BA%AA%EF%BC%89-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[(转载) 本人的新博客上线了：https://sky-xsk.github.io/ 主流框架分析我们看一下现有的一些主流框架从少到多所解决的问题。这个多少并不是来评价框架的好坏，而是从设计的角度出发看它涵盖多少内容。 纯模板引擎：最少的就是纯模板引擎，只管状态到界面的映射。 React和Vue：其实这两者都是非常专注的只做状态到界面映射，以及组件。 Backbone：它会给你多一些架构上指导，比如它会让你分层。 Angular：它做的事情就更多，它有自己的路由，这些都会包含在里面。 Ember：相比Angular，Ember做得就更加彻底，Ember信奉的是约定优于配置，它会将一切都帮你设计好打包好，你就开箱用就可以了。 Meteor：Meteor只是一个极端，它是从前到后全都包含，从前端到数据层到数据库，全都帮你打包好。 通过简单的分析，我们可以感受到，做得少的框架不一定就不如做得多的框架，这体现出一种取舍。也就是说，做得少的框架可以给你更多的灵活性，但你需要做更多的选择；做得多的框架有更强的侵入性，学习成本更高，灵活性更低。一旦选择了一个侵入性强的框架，那么一些小的部分你就没有机会去切换成其他你更想用的方案。Vue的定位与其他框架的区别就是渐进式的想法，也就是“Progressive”——这个词在英文中定义是渐进，一步一步，不是说你必须一竿子把所有的东西都用上。Vue的设计接下来我们回到之前看的图： Vue从设计角度来讲，虽然能够涵盖这张图上所有的东西，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。Vue的实现接下来深入讲一讲这些具体的概念以及Vue在这些概念上具体是做怎样的实现。(1) 声明式渲染现在基本所有的框架都已经认同这个看法——DOM应尽可能是一个函数式到状态的映射状态即是唯一的真相，而Dom状态只是数据状态的一个映射，所有的逻辑应该尽量在状体的层面上去进行，当状态改变的时候，View应该是在框架帮助下自动更新到合理的状态，而不是当观察到数据变化后手动的选择元素再命令式改动它的属性下图是Vue的一个模板示例，如果没有用过Vue的话，可以大概感觉到这是一个怎样的概念声明式渲染 其实，在模板语法上，Vue跟Angular是比较相似。在Vue1.0里面，模板实现跟Angular类似，如下图所示，把模板直接做成在浏览器里面parse成DOM树，然后去遍历这个树，提取其中的各种绑定。aa.png 在Vue2.0中，渲染层的实现做了根本性改动，引入了虚拟DOM从架构上讲，2.0依然写同样的模板，在最左边，Vue2.0跟1.0的模板语法绝大部分是兼容的。Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个虚拟DOM的树。这个树非常轻量，它的职责就是描述当前界面所应处的状态。当我们有了这个虚拟的树之后，再交给一个patch函数，负责把这些虚拟DOM真正施加到真实的DOM上。在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到的数据来源之后，之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新树与旧树进行对比，就可以最终得出应施加到真实DOM上的改动。最后再通过patch函数施加改动。这样做的主要原因是，在浏览器当中，JavaScript的运算在现代的引擎中非常快，但DOM本身是非常缓慢的东西。当你调用原生DOM API的时候，浏览器需要在JavaScript引擎的语境下去接触原生的DOM的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实DOM的操作是最少的。下面看渲染函数。用过React的开发者可能知道，React是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树。JSX实际就是一套用于让我们更简单地去描述树状结构的语法糖如下图所示，在Vue2.0当中，可以看到就是说当比如左侧的模板，经过Vue的编译之后就会变成右侧的东西。 此函数类似于创建一个虚拟元素的函数，我们可以给它一个名字，给它描述应该有的属性特性和可能其他的数据。然后后面这个最后这个参数是个数组，包含了该虚拟元素的子元素。总的来说2.0的编译器做的就是这个活。同时，在Vue2.0里，用户可以选择直接跳过模板这一层去手写渲染函数，同时也有可选JSX支持。从开发者的偏好以及开发者的效益的角度来考量，模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。JSX和直接渲染函数，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。所以在Vue2.0里，两个都是可以选择的。在绝大部分情况下使用模板，但是在需要复杂逻辑的情况下，使用渲染函数。在Vue2.0的路由和内部的一些实践上，都大量地应用渲染函数做复杂的抽象组件，比如过渡动画组件以及路由里面的link组件，都是用渲染函数实现的，同时还保留了它本身的依赖追踪系统。举例在渲染函数里面用到A.B的时候，这个就会触发对应的 getter。整个渲染流程具体要点如下：当某个数据属性被用到时，触发 getter，这个属性就会被作为依赖被 watcher 记录下来。整个函数被渲染完的时候，每一个被用到的数据属性都会被记录。相应的数据变动时，例如给它一个新的值，就会触发 setter，通知数据对象对应数据有变化。此时会通知对应的组件，其数据依赖有所改动，需要重新渲染。对应的组件再次调动渲染函数，生成 Virtual DOM，实现 DOM 更新。 这样一个流程跟主流的一些框架，例如React是有较大区别的。在React中，当组件复杂的时候需要用 shouldComponentUpdate 做优化。但是，它也有自己的各种坑，比如要确保该组件下面的组件不依赖外部的状态。虽说这在大部分情况下是够用的，但遇到极大复杂度的应用，遇到性能瓶颈的时候，这个流程优化起来也是相当复杂的一个话题。如下图所示，在Vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要手动优化。用Vue渲染这些组件的时候，数据变了，对应的组件基本上去除了手动优化的必要性。2.png （2）组件系统相信基本上所有的现代框架都已经走向了组件化道路，Web Components 从规范层面做这个实践。主流框架都有各有不同的封装，但核心思想都是一样，把UI结构映射到恰当的组件树。在Vue中，父子组件之间的通信是通过 props 传递。从父向子单向传递；而如果子组件想要在父组件作用里面产生副作用，就需要去派发事件。这样就形成一个基本的父子通信模式，在涉及大规模状态管理的时候会有额外的方案，这个后面会提到Vue的组件引入构建工具之后有一个单文件组件概念，如下图所示，就是这个Vue文件。在同一个Vue文件里，可以同时写 template、script 和 style，三个东西放在一个里面。同时，Vue的单文件组件和 Web Components 有一个本质不同，它是基于构建工具实现。这样的好处是有了一个构建的机会，可以对这些单文件组件做更多的分析处，在每一个语言块里可以单独使用不同的处理器，这点后面还会讲到。单文件组件 （3）客户端路由在做一个界面复杂度非常的高应用时，它会有很多的状态，这样的应用显然不可能在每做一次操作后都刷新一个页面作为用户反馈。这就要这个应用有多个复杂的状态，同时这些状态还要对应到URL。有一个重要的功能叫做 deep-linking，也就是当用户浏览到一个URL，然后把它传给另外的人或者复制重新打开，应用需要直接渲染出这个URL对应的状态。这就意味着应用的URL和组件树的状态之间有一个映射关系，客户端路由的职责就是让这个映射关系声明式地对应起来。 可能同一层的路由有多个不同的出口，还有着复杂的URL匹配规则，等等。这些问题如果都由自己去一一实现，那么复杂度是非常高的。而Vue基本都有对应的解决方案（router.vuejs.org）。配合Webpack还可以实现基于路由的懒加载，一条路径所对应的组件在打包的时候，会分离成另外一块，只有当该路由被访问的时候，才会被加载出来。这有相应的解决方案，同时也有实例。（4）状态管理说到状态管理，本质上就是把整个应用抽象为下图中的循环。脸书最早提出 Flux 这个概念的时，也是一个很松散的概念，而且官方的实现本身做得很难用。所以，社区就做了各种各样的探索。图中的这三个东西是一个单向数据流，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使State产生变化，从而导致 View 重新渲染。 一个单独的Vue的组件，其实就已经是这样的结构。但是当多个这样的组件来配套的时候，就会遇到一个问题。每个组件都有它自己的状态，但整个应用的状态，跟组件之间并不一定存在一一对应的关系。这个状态可能是一个全局状态。那么状态到底放在哪里？大部分解决方案是把这个状态从组件树中提取出来，放在一个全局的 Store 里面。Vuex 也是这样做的，但是它是针对 Vue 做了特化我们看到最左边就是Vue的组件，这些组件在大部分情况下，就不再有私有的状态，而是从全局的 Store 里面获取状态。Actions 和 Mutations 比较难用一两句话说清楚，大致就是当应用状态进行改变的时候，需要通过 Mutations 去显式地触发，而 Actions 则是负责异步和其他副作用。由于 Mutations 会被记录下来，我们可以把这些记录发到工具里面去做分析，甚至进行回滚。当发现bug的时候，这使得我们可以更好地理解大型应用中的状态变化。更多的细节，还请看官方文档（vuex.vuejs.org）。6.png （5）构建工具构建工具方面，Vue有一个官方的，全局安装的 vue-cli。这里有一个笔误。全局安装之后，我们就可以用 vue 命令创建一个新的项目，Vue 的 CLI 跟其他 CLI 不同之处在于，有多个可选模板，有简单的也有复杂的。极简的配置，更快的安装，可以更快的上手。它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。所有的模板在创建之后，构建脚本都是通过 npm 脚本来执行，在国内安装 npm 依赖的时候有点卡，可以用 yarn 或者推荐用淘宝的 npm 镜象源，可以很大地提升安装速度。之前提到了单文件组件，如下图所示，支持任意的处理器，开箱即用的热重载，所以组件都支持热重载 (hot-reload)。当你做了修改，不会刷新页面，只是对组件本身进行立刻重载，不会影响整个应用当前的状态。CSS也支持热重载。我们看下左下角，在使用这个预处理器的同时，我们只需要添加一个 scoped 特性，Vue 会通过对模板和CSS代码的解析改写，来模拟CSS的效果。同时单文件组件也支持懒加载，一个懒加载的组件和它的依赖会被打包成一个额外的包，只有被用到的时候才加载，这对首屏的加载速度也是很有帮助的。1.png 如下图所示，这个开发者工具本身也是用Vue写的2.png 使用它的话可以看到我们当前应用的组件树结构。3.png 点击组件，就可以观察这个组件当前的状态。也可以把这个组件发送到控制台里。同时这个开发者工具还有一个 Vuex 面板，如果你用了 Vuex，那么每次操作都会被记录下来，记录下来的状态之间可以进行跳转。除此之外，还支持把当前应用的状态快照发送给另外一个人，这个人可以在他的控制台里导入你发送的状态，就可以立刻跳转到你之前所在的状态。这对于重现一些 bug，或要描述当前状态都很有帮助。Vue2.0Vue2.0在不久之前刚刚发布（具体报道参见http://t.cn/RVC0foZ），之前一些技术细节在前文中已有所涉及。Vue2.0相对于1.0的改进有以下几点。1、更轻对Vue1.0大小压缩，Vue2.0它有一个只包含运行时的版本，所有的模板在编译的时候已经完成了。基于这个版本，下图中Vue、vue-router和vuex三个（都是 2.0 版本）加一起，跟Vue1.0的核心库大小一样。2、更快Vue2.0可以说是当前最快的框架之一。这个是基于第三方独立测试的结果。有兴趣的话，可以移步链接进行查看。这个测试是一个比较综合的测试，它对于各种操作，以及在大列表里面更新移除等，都有相当完整的覆盖。可以看出，Vue2.0，不仅仅是在Vue1.0的基础上有很大提升，相比其他框架，也有相当明显的性能优势。3、Vue2.0 架构下图是Vue2.0的架构图，这里不深入讲整个架构的实现。 Vue2.0同时支持服务端，服务端渲染支持流式渲染。因为HTTP请求也是流式，Vue 的服务端渲染结果可以直接 pipe 到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。除了服务端渲染还有原生渲染，这里的原生渲染是指阿里巴巴的项目Weex。在架构层面，通过编译一个 Weex 源文件（类似于 Vue 单文件组建的格式）然后运行。界面节点的操作都是抽象的，这些抽象操作会派发到不同的目标引擎做实际的渲染，同时支持 iOS, Android 和 Web。Vue和Weex现在有一个合作，Vue 2.0 将会正式成为 Weex 的 JavaScript 运行时。这样的合作可以使得符合功能交集的Vue组件可以跨平台使用。(转载)12本人的github，里面有vue2.0的小项目练习，包括仿饿了么的客户端，vue2.0写的，基本功能已经实现，部分bug在修改中;如果觉得有用的话，请给个“star”；https://github.com/sky-xsk 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
        <tag>es6</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0,自己开发一个全局定义的公用组件（插件）]]></title>
    <url>%2F2017%2F05%2F11%2Fvue2-0-%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%AC%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%88%E6%8F%92%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天，在群里看到有朋友问这样一个问题：“我在项目里，怎么能做一个全局调用的组件，不用每一次都import，注册组件？”看到这个问题，我思考了一下，讲一下我的思路！ 这个问题里，所说的组件，在我看来也可以叫做“插件”，为什么这么说呢？因为这个和vue-resource之类的插件开发的思路是一样的？只是一个放到的是本地，一个是通过“npm install vue-resource ”下载下来的？换一个思路，如果我把自己开发的组件放到网上，是不是别人可以直接用我开发的插件呢？回答是：“必须的”！ 所以我就来做一个公共的组件：同样的开发环境vue-cli;这个就不说了！！！ 新建alerts.vue和alerts.js文件alerts.vue123456789101112131415161718&lt;template&gt; &lt;div class=&quot;alerts&quot;&gt; &lt;h2&gt;开发自定义组件//公共组件可直接在任意地方调用&lt;/h2&gt; &lt;button @click=&quot;clicks()&quot;&gt;点击我试一下&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, methods:&#123; clicks()&#123; alert(&quot;我是公共的组件！（插件）&quot;) &#125; &#125;, &#125;&lt;/script&gt; 这个很简单！接下来是重头戏了！alerts.js1234567const alertsComponent = require(&apos;./alerts.vue&apos;); //引入const alerts = &#123; install: function(Vue) &#123; Vue.component(&apos;alerts&apos;, alertsComponent) &#125;&#125;;module.exports = alerts; 此处注意文件的路径，不要弄错了； 在main.js里引用，和调其他插件的方法一样main.js12import alerts from &apos;./components/alerts/alerts&apos; //注意路径Vue.use(alerts); 调用方法1&lt;alerts&gt;&lt;/alerts&gt; 在任意组件里调用，均可！ 我的github，如果有用，不要吝啬，请给个star；在里面可以找到此例子的源码哦！1https://github.com/sky-xsk/vue2.0-start- 如有错误，请指正！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>vue2.0</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单聊聊javascript的继承]]></title>
    <url>%2F2017%2F05%2F09%2F%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8Ajavascript%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9B%2F</url>
    <content type="text"><![CDATA[在JS中继承是一个非常复杂的话题，比其他任何面向对象语言中的继承都复杂得多。在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可。在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，且JS是基于对象来继承的。（这话是比较官方的说法，看着都很专业） 在说继承之前，首先得先回答一个问题，什么是继承？我理解的继承，简单来说就是，–1.在原有类的基础上，进行可操作的修改，得到一个崭新的类，这个类有原来类的功能，同时也有自己的功能；–2.这个新的类，不会影响原有类的功能，不会相互干预； 这里肯定有人要问了，什么是‘可操作的修改呢？’说白了就是在不影响整个类的功能的前提下，进行的修改！这点和第二点略有重复，仔细想想，还是有所区别的！！！下面开始说说常用的集中继承方式： ###1.代码：12345678910111213141516171819202122function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;Person.prototype.showName = function() &#123; console.log(this.name);&#125;Person.prototype.showSex = function() &#123; console.log(this.sex);&#125;function work(name, sex, job) &#123; //构造函数伪装调用父级的构造函数——为了继承属性 Person.call(this, name, sex); //Person.apply(this, [name, sex]); //此处的call与apply是有区别的，往下看 this.job = job;&#125;work.prototype = Person.prototype; //通过prototype继承父级的属性work.prototype.showJob = function() &#123; console.log(this.job);&#125;var s = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;);s.showJob() //developer 简单的解释一下上面的代码：首先写了一个很简单的构造函数，在函数的原型上分别添加了showName和showSex的方法；紧接着写了一个work（）函数，这里注意work（）里面的参数，多了一个job参数，这个参数就是要继承的参数， Person.call(this, name, sex);有人问这里的this指的是啥？看下图：答案就是 new出来的work对象！work.prototype = Person.prototype;这句话就是通过prototype继承父级的属性，name和sex；然后就是在work的基础上添加showJob方法；最后就是new一个work对象，执行方法！最后work继承了Person的name和sex属性；是不是很好懂！ ###2.代码：123456789101112131415161718192021222324252627282930313233function Person(name, sex) &#123; this.name = name; this.sex = sex; &#125; Person.prototype.showName = function() &#123; alert(this.name); &#125;; Person.prototype.showSex = function() &#123; alert(this.sex); &#125;; function work(name, sex, job) &#123; Person.call(this, name, sex); this.job = job; &#125; //1.原型链 通过原型来继承父级的方法 //work.prototype=Person.prototype; // 2.原型链 通过原型来继承父级的方法(循环方法) // Person.prototype类型是object； for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; Worker.prototype.showJob = function() &#123; alert(this.job); &#125;; var p = new Person(&apos;xue&apos;, &apos;nan&apos;); var w = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;); // p.showName(); // p.showSex(); // w.showName(); // w.showSex(); // w.showJob(); 简单解释一下：1234``` for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; 这里只是用不同方法，通过原型链来继承父级的方法，原理是一样的！ call与apply的区别js中call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。说简单一点，这两函数的作用其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。如有错误请私信本人！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度复用的弹出框组件的写法 vue2.0]]></title>
    <url>%2F2017%2F05%2F09%2F%E9%AB%98%E5%BA%A6%E5%A4%8D%E7%94%A8%E7%9A%84%E5%BC%B9%E5%87%BA%E6%A1%86%E7%BB%84%E4%BB%B6%E7%9A%84%E5%86%99%E6%B3%95-vue2.0%2F</url>
    <content type="text"><![CDATA[和以前的文章一样用的vue-cli;具体的 安装步骤这里不做详细的解释了；直接开始了；一定要存在其他的组件 新建一个alertip.vue组件；组件代码如下123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;tip&quot;&gt; &lt;p&gt;&#123;&#123;alertText&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;button @click=&quot;closeTip&quot;&gt;关闭&lt;/button&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;tip&apos;, components: &#123; &#125;, data() &#123; return &#123; &#125; &#125;, props: [&apos;alertText&apos;], //接收传的值 methods:&#123; closeTip()&#123; this.$emit(&apos;closeTip&apos;)；//分发事件 &#125; &#125;, &#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;!-- 此处的样式只是添加了效果，没有进行准确的排版，这里主要将vue的写法！--&gt;&lt;style scoped&gt;.tip&#123; width: 400px;height: 200px; overflow: hidden; position: fixed; left:38%;top:20%; background: #fff; border: 1px solid #ccc; padding:20px;&#125; &lt;/style&gt; 在其他组件里调用123456789101112131415161718192021222324252627&lt;/template&gt;&lt;div&gt; &lt;alertip v-show=&quot;alertipShow&quot; @closeTip=&quot;alertipShow = false&quot; :alertText=&quot;alertText&quot;&gt;&lt;/alertip&gt; //此处传值，点击事件 &lt;el-button type=&quot;primary&quot; @click=&quot;alerts()&quot;&gt;点击此按钮，出现浮动窗口&lt;/el-button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import alertip from &apos;./components/alertip.vue&apos;; //此处注意组件的路径 export default &#123; name: &apos;app&apos;, components: &#123; alertip &#125;, data() &#123; return &#123; alertipShow:false, alertText:&apos;&apos; &#125; &#125;, methods: &#123; alerts()&#123; this.alertText=&quot;此处的值为传过去的值，不同的页面用的同一个组件，但是弹出的内容是不同的！,这个信息在app组件里&quot;; this.alertipShow = true; &#125;, &#125;&#125; &lt;/script&gt; 其他页面同样的方法可以调用！展示的效果是一样的，但是不同组件可以传入的值可以是不同的，展示的内容也是不同的，但是效果弹窗是一样的！1源码见：https://github.com/sky-xsk/vue2.0-start- 给加个“star”哦！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0/Webpack 一个简单的todolist实例]]></title>
    <url>%2F2017%2F04%2F17%2Fvue2-0-Webpack-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84todolist%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[用的vue-cli,这里就不写过程了，直接上代码吧！同样自己用webpack自己搭一个项目实例！ 1234github地址：https://github.com/sky-xsk/vue2.0-start-vue2.0写的项目：https://github.com/sky-xsk/elem如果有帮助，请给个star； 首先是html12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;todo&quot;&gt; &lt;h2&gt;todolist&lt;/h2&gt; &lt;div class=&quot;t_input&quot;&gt; &lt;span&gt;&lt;input type=&quot;text&quot; class=&quot;t_titles&quot; placeholder=&quot;请输入。。。&quot; v-model=&quot;text&quot; @keyup.13=&quot;add()&quot;&gt;&lt;/span&gt; &lt;span&gt;&lt;button class=&quot;t_add&quot; @click=&quot;add()&quot;&gt;添加&lt;/button&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;t-cont&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in todolist&quot; track-by = &quot;$index&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;item.state&quot; class=&quot;checkbox&quot;/&gt; &#123;&#123;`$&#123;index+1&#125;. `&#125;&#125; &#123;&#123;item.value&#125;&#125; &lt;span @click = &quot;del(index)&quot;&gt;删除&lt;/span&gt; &lt;span @click = &quot;edit(index)&quot;&gt;编辑&lt;/span&gt; &lt;/li&gt; &lt;div class=&quot;check_che&quot; @click=&quot;remove()&quot; v-show=&quot;select.length &gt; 0&quot; &gt;删除选中&lt;/div&gt; &lt;p v-show=&quot;todolist.length == 0&quot;&gt;暂无数据！&lt;/p&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; export default &#123; name: &apos;todo&apos;, data() &#123; return &#123; todolist:[], text:&apos;&apos;, state: false, &#125; &#125;, methods:&#123; //添加 add()&#123; if(this.text == &apos;&apos;)&#123; return &#125;else&#123; this.todolist.push (&#123; value:this.text, state: false, &#125;) &#125; this.text=&apos;&apos;; &#125;, //删除 del(index)&#123; this.todolist.splice(index,1); &#125;, //删除选中 remove()&#123; this.todolist = this.todolist.filter((index) =&gt; !index.state) &#125;, //编辑 edit(index)&#123; this.text = this.todolist[index].value; this.todolist.splice(index,1); &#125; &#125;, //计算属性 computed: &#123; select() &#123; return this.todolist.filter((index) =&gt; index.state == true) &#125; &#125; &#125;&lt;/script&gt; css123456789101112131415&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.t_titles&#123; width: 400px; height: 35px; font-size: 16px; padding-left: 10px;&#125;.t_add&#123; width: 60px; height:40px; font-size: 16px; vertical-align: middle;&#125;.t-cont&#123; width:100%; margin-top: 20px; margin: 0 auto;&#125;.t-cont ul li&#123;list-style: none; height: 30px; border: 1px solid #ccc; line-height: 30px; text-align: left; padding-left: 10px;&#125;.t-cont ul li span&#123;float: right; cursor: pointer; padding-right: 10px;&#125;.t-cont ul li input&#123;padding-top: 5px;&#125;.checks&#123; width: 15px; height: 15px; border-radius:50%; border: 1px solid #ccc; display: inline-block;margin-top: 5px; cursor: pointer; &#125;.checkbox &#123; width: 18px; height: 18px;border: 1px solid #ccc; border-radius: 100%; position: relative; margin-right: 6px; vertical-align: middle; &#125;.checkbox:checked &#123;border-color: deepskyblue;&#125;.checkbox:checked:before &#123; content: &apos;&apos;; display: block; width: 80%; height: 80%; position: absolute; left: 50%; top: 50%;transform: translate(-50%, -50%); background: deepskyblue; border-radius: 100%;&#125;.check_che&#123;border: 1px solid #ccc; padding:10px;&#125;&lt;/style&gt; 效果如截图： 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用sourceTree，将自己的代码上传到github上去]]></title>
    <url>%2F2017%2F04%2F15%2F%E7%94%A8sourceTree%EF%BC%8C%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0github%E4%B8%8A%E5%8E%BB%2F</url>
    <content type="text"><![CDATA[GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 sourceTree是一个工具；接下来我就教大家怎么把自己的代码传到github上面去； 首先你注册一个sourceTree的账号和github的账号，我这边就不写怎么去注册了注册好账号后，在github上点击如图； 点击后，会弹出如下页面； 输入项目名称后，点击绿色按钮，即可； 打开新建的项目，点击绿色按钮，将地址复制下来 在本地新建一个文件夹，作为本地的仓库，接下来，打开sourceTree客户端，单击新建/克隆如图； 源路径填写刚才复制的地址，目标路径就会刚才新建的文件夹的路径；填好后，点击确定即可，这样你的仓库就克隆到本地了； 克隆到本地的仓库有个.git文件千万不要删掉；然后自己的代码复制到本地的仓库中去，然后点击Stage All后单击提交 接下来点击‘推送’ 到github上面看一下，代码推送成功！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>sourceTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0，jsonp的一个小案例 请求百度搜索的接口]]></title>
    <url>%2F2017%2F03%2F10%2Fvue2-0%EF%BC%8Cjsonp%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%A1%88%E4%BE%8B-%E8%AF%B7%E6%B1%82%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[我用的是vue-cli，可以自己去下一个试试看！JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的script 元素是一个例外。利用 script 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。 这里用的”vue-resource”里的示例；下面开始了： #html:123456789101112131415&lt;template&gt; &lt;div class=&quot;bar&quot;&gt; &lt;div id=&quot;box&quot;&gt; &lt;h1&gt;jsonp请求百度接口&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;t1&quot; @keyup=&quot;get($event)&quot; placeholder=&quot;请输入您要搜索的关键词&quot; class=&quot;input_s&quot; @keydown.down=&quot;changeDown()&quot; @keydown.up.prevent=&quot;changeUp()&quot;&gt; &lt;ul class=&quot;ul_se&quot;&gt; &lt;li v-for=&quot;(value,$index) in myData&quot; :class=&quot;&#123;gray:$index==now&#125;&quot; @click=&quot;clickChose($index)&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p v-show=&quot;myData.length==0&quot;&gt;暂无数据...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; #js:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; export default &#123; data() &#123; return &#123; myData:[], t1:&apos;&apos;, now:-1, &#125; &#125;, methods:&#123; get(ev)&#123; //键盘操作 if(ev.keyCode==38 || ev.keyCode==40) return; if(ev.keyCode==13)&#123; window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1); this.t1=&apos;&apos;; &#125; this.$http.jsonp(&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;, //跨域请求接口 &#123; params: &#123; wd:this.t1, &#125;, jsonp:&apos;cb&apos; &#125;).then(function(res)&#123; this.myData = JSON.parse(res.bodyText).s &#125;,function()&#123; console.log(&quot;请求失败！！！&quot;) &#125;); &#125;, changeDown()&#123; //下键选择 this.now++; if(this.now==this.myData.length)this.now=-1; this.t1=this.myData[this.now]; &#125;, changeUp()&#123; //上键选择 this.now--; if(this.now==-2)this.now=this.myData.length-1; this.t1=this.myData[this.now]; &#125;, clickChose($index)&#123; //鼠标选择搜索关键词事件 this.now = $index; this.t1=this.myData[this.now]; window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1); &#125;, &#125;, &#125;&lt;/script&gt; #css:1234567&lt;style scoped&gt;.ul_se&#123; background: #fff; border: 1px solid #ccc; width: 100%;&#125;.ul_se li&#123;list-style: none; height: 30px; line-height: 30px; cursor: pointer;&#125;.input_s&#123;width: 400px; height: 30px; padding-left: 10px;&#125;.gray&#123;background: deepskyblue; color: #fff;&#125;.ul_se li:hover&#123;background: deepskyblue; color: #fff;&#125;&lt;/style&gt; 最终效果：当你在输入框里输入搜索的关键词的时候，就会自动将联想的词汇显示在下方，按一下“enter”键，即可跳转到搜索结果 的页面，同是按“上”，“下”键可以进行选择搜索的关键词，鼠标也可以进行操作选择，跳转！ 以后搜索，直接打开就可以了！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于es6的部分语法介绍]]></title>
    <url>%2F2017%2F03%2F02%2F%E5%85%B3%E4%BA%8Ees6%E7%9A%84%E9%83%A8%E5%88%86%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[#es6的介绍ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准,组件分为：ECMA/DOM/BOMECMAscript简写是ECMA或者叫ES； #在线编译e6转换es5如果不是太熟悉的话，可以用用这个转换的小工具，对比一下es6语法的差别；1http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;code=%20const%20A%20%3D%20&apos;static%20A&apos;%3B%0D%0A%09%20%20%20%09%20console.log(A)%3B%0D%0A%09%20%20%20%09%20let%20b%20%3D&apos;b&apos;%3B%0D%0A%09%20%20%20%09%20console.log(b)%3B%0D%0A%0D%0A%09%20%20%20%09%20alert(A) #变量let1.let的使用范围有限，只能在代码里面使用，在代码外面的还就会弹出未定义,不能重复声明，也就是用同一个变量不能用两次2.如果是var的话，只有在函数里才有作用域 ###eg:12345678910111213141516#html:&lt;ul&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt;&lt;/ul&gt;#js:window.onload = function()&#123; var ali = document.getElementsByTagName(&apos;li&apos;); for(let i = 0;i&lt;ali.length;i++)&#123; ali[i].onclick = function()&#123; alert(i) &#125; &#125; &#125; #constconst的用法比较好理解，它一旦被赋值的话就不能被修改，常量必须在声明的同时赋值，否则会报错，而且通常常量用大写字母规范；和es5一样的一点是，不能重复的去声明，否则是会有问题的； ###eg:12const TEST1 = 0;const TEST2 = 1; #字符串的连接在es6中，字符串的连接变得更简单了，1###eg： var a = “我是字符串1”;var b = “我是字符串2”;var c = 把他们连起来$(a)把他们连起来$(b);console.log(c);123#给变量赋值现在的赋值更简单，更灵活，同时也减少的不少的代码量；###eg: var [a,b,c] = [1,2,3];打印一个：console.log(a);打印多个：console.log(a,b,c);1对，就是这个样！ var { a, c ,b } = { a:1, b:2 , c:3 }打印一个：console.log(a);打印多个：console.log(a,b,c);123```var [a,[b,c],d] = [1,[2,3],4];console.log(a,b,c,d); 12var [&#123;a,e&#125;&#125;,[b,c],d] = [&#123;e:&apos;eeee&apos;,a:&apos;aaaaa&apos;&#125;,[1,2],5] //这个有点变化，注意了console.log(a,b,c,d) 自己会一一对应的，不会因为顺序不同导致值的变化！ #数组数组的操作基本相同，这里介绍一个‘from’方法；‘复制数组’12345var arr = [1,2,3];var arr2 = Array.from(arr);arr2.pop();console.log(arr,arr2);Array.from(arr); 1234var arr = [1,2,3];var arr2 = [...arr];arr2.pop();console.log(arr,arr2); 这两种方法是相同的； #遍历es6用的是for…of..;有点变化！1234var arr = [1,2,2,2,2,2,2,3,4]; for(var i of arr)&#123; console.log(i)&#125; 值得注意的是:可以循环数组，但是不能循环json，他主要是循环map对象用的; #map12345var map = new Map();map.set(&apos;a&apos;,&apos;apple&apos;);map.set(&apos;b&apos;,&apos;banbana&apos;);alert(map.get(&apos;b&apos;)); //获取map.delete(‘a’); //删除 12345678var map = new Map();map.set(&apos;a&apos;,&apos;apple&apos;); map.set(&apos;b&apos;,&apos;banbana&apos;); map.set(&apos;c&apos;,&apos;orange&apos;); map.set(&apos;d&apos;,&apos;pear&apos;); for( var [key,value] of map)&#123; //循环了一下 console.log(value); &#125;; 12345var arr = [&apos;q&apos;,&apos;w&apos;,&apos;e&apos;,&apos;a&apos;,&apos;d&apos;,&apos;f&apos;,&apos;r&apos;] //一套带走，lol //entries循环key和value for(var name of arr.keys())&#123; console.log(name) &#125; #箭头函数（经常会遇到的，刚开始会很懵逼）这里做个对比，就一目了然了； ###es6 eg:123456789101112131415#html&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;#css#box&#123; width:200px; height:200px; border:1px solid #000; &#125;#jswindow.onload = function()&#123; var oBox = document.getElementById(&apos;box&apos;); oBox.onclick = () =&gt;&#123; oBox.style.background = &apos;red&apos;； &#125;&#125; ###es5 eg:123456789101112131415#html&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;#css#box&#123; width:200px; height:200px; border:1px solid #000; &#125;#jswindow.onload = function()&#123; var oBox = document.getElementById(&apos;box&apos;); oBox.onclick=function()&#123; oBox.style.background = &apos;red&apos;； &#125;&#125; #面向对象这个写法，感觉和java里的类有点像；1234567891011121314class Person&#123; constructor(name,age)&#123; this.name = name this.age = age &#125; showName()&#123; return this.name; &#125; showAge()&#123; return this.age; &#125; &#125; var p1 = new Person(&apos;aaa&apos;,10); alert(p1.showName()); 小提示：在es6的语法当中，私有作用域的代码块：{ } 包起来的就是代码块，就形成了一个作用域，称为块级作用域,这个的话和es5就有很大差别； ~~~后期会继续更新的; 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来来来，通俗的理解一下原型，原型链......]]></title>
    <url>%2F2016%2F12%2F26%2F%E6%9D%A5%E6%9D%A5%E6%9D%A5%EF%BC%8C%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[今天，在网上看到这个讲原型和原型链的通俗的分析，感觉对理解还是有帮助的，特此分享： 原型链理解起来有点绕了，网上资料也是很多，每次晚上睡不着的时候总喜欢在网上找点原型链和闭包的文章看，效果极好。不要纠结于那一堆术语了，那除了让你脑筋拧成麻花，真的不能帮你什么。简单粗暴点看原型链吧，想点与代码无关的事，比如人、妖以及人妖。 1）人是人他妈生的，妖是妖他妈生的。人和妖都是对象实例，而人他妈和妖他妈就是原型。原型也是对象，叫原型对象。 2）人他妈和人他爸啪啪啪能生出一堆人宝宝、妖他妈和妖他爸啪啪啪能生出一堆妖宝宝，啪啪啪就是构造函数，俗称造人。 3）人他妈会记录啪啪啪的信息，所以可以通过人他妈找到啪啪啪的信息，也就是说能通过原型对象找到构造函数。 4）人他妈可以生很多宝宝，但这些宝宝只有一个妈妈，这就是原型的唯一性。 5）人他妈也是由人他妈他妈生的，通过人他妈找到人他妈他妈，再通过人他妈他妈找到人他妈他妈……，这个关系叫做原型链。 6）原型链并不是无限的，当你通过人他妈一直往上找，最后发现你会发现人他妈他妈他妈……的他妈都不是人，也就是原型链最终指向null。 7）人他妈生的人会有人的样子，妖他妈生的妖会有妖的丑陋，这叫继承。 8）你继承了你妈的肤色，你妈继承了你妈他妈的肤色，你妈他妈……，这就是原型链的继承。 9）你谈对象了，她妈让你带上房产证去提货，你若没有，那她妈会问你妈有没有，你妈没有那她妈会问你妈她妈有没有……这就是原型链的向上搜索。 10）你会继承你妈的样子，但是你也可以去染发洗剪吹，就是说对象的属性可以自定义，会覆盖继承得到的属性。 11）虽然你洗剪吹了染成黄毛了，但你不能改变你妈的样子，你妈生的弟弟妹妹跟你的黄毛洗剪吹没一点关系，就是说对象实例不能改动原型的属性。 12）但是你家被你玩火烧了的话，那就是说你家你妈家你弟们家都被烧了，这就是原型属性的共享。 13）你妈外号阿珍，邻居大娘都叫你阿珍儿，但你妈头发从飘柔做成了金毛狮王后，隔壁大婶都改口叫你包租仔，这叫原型的动态性。 14）你妈爱美，又跑到韩国整形，整到你妈他妈都认不出来，即使你妈头发换回飘柔了，但隔壁邻居还是叫你金毛狮王子。因为没人认出你妈，整形后的你妈已经回炉再造了，这就是原型的整体重写。(转载！) 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js如何判断一个对象是不是Array？]]></title>
    <url>%2F2016%2F12%2F26%2Fjs%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AFArray%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[当听到这个问题的时候，肯定有人第一个想法就是用“typeof”来判断，实则，并不能实现；很忧伤！下面咱先来说一说“typeof”，在js中，对于Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任​，大家都懂的！ typeof​12var arr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);​​alert(typeof(arr)); 你会收到一个object ；什么破玩意；是不是这个时候想把键盘摔了，摔了没关系，再买吧！往下看： instanceof咱不能一条道走到黑，咱们得找其他的路子啊，对不对？JavaScript中instanceof运算符会返回一个 Boolean 类型的值，指出对象是否是特定类的一个实例。 使用方法：result = object instanceof class,还是刚刚的数组，成功的返回 true。​请看下面，看实际代码：12var arrayStr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);alert(arrayStr instanceof Array); 啊，成功了！高兴吧！这样真的可以了吗？是吗？其实​instanceof还是有一定的局限性的，一想到这，不是验证正确了吗？没毛病啊！事实上在多个frame中穿梭就会产生大问题了​？？？123456var iframe = document.createElement_x(&apos;iframe&apos;); document.body.appendChild(iframe); xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);//这个写法老古董IE下是不支持的，FF下才有;alert(arr instanceof Array); // falsealert(arr.constructor === Array); // false 返回结果为两个False，让人大失所望。为毛？ ​Object.prototype.toString( ) ECMA-262 写道1234Object.prototype.toString( ) When the toString method is called, the following steps are taken:Get the [[Class]] property of this object.Compute a string value by concatenating the three strings “[object “, Result (1), and “]”.Return Result (2) 上面的规范定义了Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。还是先来看看在ECMA标准中Array的描述吧。12new Array([ item0[, item1 [,…]]])The [[Class]] property of the newly constructed object is set to “Array”. 于是利用这点，第三种方法登场了。call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是’[object Array]’，以判断其是否是Array的实例。也许你要问了，为什么不直接o.toString()？嗯，虽然Array继承自Object，也会有toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：） 与前面几个方案不同，这个方法很好的解决了跨frame对象构建的问题，经过测试，各大浏览器兼容性也很好，可以放心使用。一个好消息是，很多框架，比如jQuery、Base2等等，都计划借鉴此方法以实现某些特殊的，比如数组、正则表达式等对象的类型判定，不用我们自己写了。另外Ext3 也已经换成这样的写法了;12isArray : function (v)&#123; return toString.apply(v) === &apos;[object Array]&apos;;&#125; 4.JQ中$isArray();话不多说，直接上代码吧！1234$(document).ready(function()&#123; var Arr = [&quot;4&quot;,&quot;8&quot;,&quot;1&quot;,&quot;3&quot;]; alert($.isArray(Arr));​&#125;)​ 返回的值为​Boolean 类型的值，是数组则返回一个“true”，反之“false”成了！​行就到这吧！希望大家多多支持！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈，实例mttq；]]></title>
    <url>%2F2016%2F12%2F20%2F%E6%B5%85%E8%B0%88%EF%BC%8C%E5%AE%9E%E4%BE%8Bmttq%EF%BC%9B%2F</url>
    <content type="text"><![CDATA[MQTT - MQ Telemetry TransportMQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。​ 早在1999年，IBM的Andy Stanford-Clark博士以及Arcom公司ArlenNipper博士发明了MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）技术[1] 。据Andy Stanford-Clark博士称，MQTT将在今年和明年呈现爆炸式增长。MQTT的话题是我俩谈论开源物联网平台Pachube时提到的。Stanford-Clark认为Pachube很酷，其不足之处是不具备真正的推送功能。你需要不断轮询才能得到即时数据。这正是MQTT能够实现的，他提到了使用推送通信系统的石油管道检测系统。轻量级的 machine-to-machine 通信协议。publish/subscribe模式。基于TCP/IP。支持QoS。适合于低带宽、不可靠连接、嵌入式设备、CPU内存资源紧张。是一种比较不错的Android消息推送方案。FacebookMessenger采用了MQTT。MQTT有可能成为物联网的重要协议。 下面一个实例，直接看代码：我放到云盘了，可以下载！1https://pan.baidu.com/s/1skZADJZ 例子有问题的话可以私信我！123这里说一下例子的使用方法：1.先去config去配置服务器的地址，前提是在服务器上已经配置好了MQTT协议，2.配置好后，将index.html在浏览器中打开，打开两份，这样你在一个页面发送信息，另一个页面就可以收到了！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>mttq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap VS jQuery Mobile 对比！]]></title>
    <url>%2F2016%2F12%2F08%2FBootstrap-VS-jQuery-Mobile-%E5%AF%B9%E6%AF%94%EF%BC%81%2F</url>
    <content type="text"><![CDATA[很多新手纠结这个问题？两个框架都能够支持做手机网页，那么它们的区别是什么呢，适用场景是什么呢？下面我们从这几个方面比较这两个框架：解决问题、功能、适用场景。 解决问题 ###Bootstrap是一个css框架，针对解决的问题有：1.跨设备的网页响应式布局问题。随着手机、平板、各分辨率屏幕的出现，如何能够一套前端在所有设备上自由适应？2.多人合作的前端布局和样式的规范问题3.常用前端css组件，如按钮、连接、表单、表格、分页组件、下拉菜单、导航栏、ICON等等4.常用JS前端组件（需要扩展js支持），如表单验证、Tips、Popup等等 jQuery Mobile是移动前端框架jQuery Mobile是移动前端框架，包含js、html、css，提供一套完整的移动前端开发组件，可以比喻成Android开发框架，尽可能提供移动APP所具有的所有功能，针对解决的问题有：1.移动网页APP所常用的组件，例如：手机导航栏、选项卡、底部菜单、列表、表单等各种组件，而这些与Bootstrap提供的组件有很大区别，jQuery Mobile提供的是类似手机APP的组件，只用于移动网页，而Bootstrap提供的是面向所有设备的组件，并没有对移动设备专门考虑，与移动APP的组件体验不一样。2.网页页面之间转换效果3.异步数据加载 功能 Bootstrap其核心主要是一个css样式框架，基于css 的Media Query功能实现了响应式布局，能够帮助前端开发人员快速布局、快速开发、合作开发。它必须借助jQuery类似的js框架来实现Ajax数据交互。 jQuery Mobile其核心是一个完整的WebAPP框架，加入了一个轻量级的jQuery可以实现Dom操作，在jQuery的基础上提供了一系列类似移动APP的Widget（视图组件），提供了一套不错的页面转场效果，可通过Ajax实现与后端数据交互。 适用场景 Bootstrap通常用于：展示网站的响应式布局开发，使得网站可以在不同设备上方便浏览；以及网站后台管理系统的前端CSS框架。 jQuery Mobile通常用于：期望接近移动APP体验的WebAPP，项目只运行在手机端，不用于电脑设备展示（虽然是可以展示的，但是效果不好）。 总结 如果做跨设备响应式前端，选择Boostrap；如果仅作移动端，期望得到近似APP的WebAPP，使用jQuery Mobile。 如果做一个产品级的WebAPP，当前jQuery Mobile的能力并不能让你满意，自己开发响应式布局框架和WebApp组件是必然要走的路。 最后希望初学者可以掌握这两种框架，还有推荐一个js库，zepto.js,这个框架在开发移动端的时候，很便利，和jQ很像，但又有所不同，但是zepto.js更小，更便捷，zepto.js还提供了手机端的touch的api，真心很棒！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>Bootstrap</category>
        <category>jQuery Mobile</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
        <tag>jQuery Mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 CSS3 怎么绘制需要的几何图形]]></title>
    <url>%2F2016%2F08%2F13%2F%E7%94%A8-CSS3-%E6%80%8E%E4%B9%88%E7%BB%98%E5%88%B6%E9%9C%80%E8%A6%81%E7%9A%84%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[圆形思路：给任何正方形元素设置一个足够大的 border-radius ，就可以把它变成一个圆形.代码如下： 12345html:&lt;div class=&quot;size example1&quot;&gt;&lt;/div&gt;css:​​ .size&#123;width:200px; heigh: 200px;background​:#8BC34A;&#125;​.example1&#123;border-radius:100px;&#125; 自适应椭圆1234html:&lt;div class=&quot;example3&quot;&gt;&lt;/div&gt;css:.example3&#123; width:200px; height:150px; border-radius:50%; background:#8BC34A;&#125; 自适应的半椭圆:沿横轴劈开的半椭圆1234html:&lt;div class=&quot;example4&quot;&gt;&lt;/div&gt;css:.example4&#123;width:200px;height:150px; border-radius:50%/100%100%00; background:#8BC34A;&#125; 自适应的半椭圆:沿纵轴劈开的半椭圆1234html:&lt;div class=&quot;example5&quot;&gt;&lt;/div&gt;css：.example5&#123;width:200px; height:150px; border-radius:100%00100%/50%; background:#8BC34A;&#125; 四分之一椭圆1234html:&lt;div class=&quot;example６&quot;&gt;&lt;/div&gt;css：.example6&#123; width:160px; height:100px;border-radius:100% 0 0 0;background:#8BC34A;&#125; 用椭圆绘制opera浏览器的logo（示例借鉴）思路：绘制opera浏览器的logo,分析起来不难，就只有两个图层，一个是最底部的椭圆，一个是最上面那层的椭圆。先确定一下最底层的椭圆宽高，量了一下，水平宽度为258px，垂直高度为275px，因为其是一个对称的椭圆，没有倾斜度，故4个角均为水平半径为258px，垂直半径为275px的4个相等椭圆，用同样的办法确定最里面的椭圆的半径，因此，四个角均为水平半径120px，垂直半径为229px的椭圆，代码如下：12345678910111213141516171819202122232425html:&lt;div class=&quot;opera&quot;&gt; &lt;div ​class=&quot;opera-top&quot;&gt;&lt;/div&gt;&lt;/div&gt;css:.opera&#123; width:258px; height:275px; background:#F22629; border-radius:258px258px258px258px/275px275px275px275px; position:relative;&#125;.opera-top&#123; width:112px; height:231px; background:#FFFFFF; border-radius:112px112px112px112px/231px231px231px231px; position:absolute; left:50%; right:50%; top:50%; bottom:50%; margin-left:-56px; margin-top:-115px;&#125; 如有错误，请大家多多指教！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>css3.0</tag>
      </tags>
  </entry>
</search>