<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单聊一下js闭包]]></title>
    <url>%2F2017%2F05%2F31%2F%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%80%E4%B8%8Bjs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[js闭包，阮老师说：‘闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。’ 这里可能要先去理解一下全局 变量和局部变量，这里先不做过多的解释！ 接下来通过几个例子，谈一下对比包的理解以及各种闭包的写法，下面的例子可能不够专业，但是对于闭包的理解个人认为还是有很大的帮助的! 例子1：1234567function a()&#123; var b = 1; return function c()&#123; console.log(b) &#125;&#125;a()(); //1 这个函数调用时，a()(),有两个括号，第一个是调用a函数，第二个是执行c函数。 如果单独执行a();返回的就是c函数的函数体，这里就是把c函数，缓存了一下，并没有立即执行！ 例子2：123456function a()&#123; return function()&#123; console.log(0) &#125;&#125;a()(); //0 这种写法，和上面一种写法差不多，但是缓存的时候是匿名函数，但是调用的方法是相同的！ 例子3：123456789 function a() &#123; var b = 1; function c() &#123; alert(b); &#125; return c; &#125; var d = a(); d(); // 1 分析一下例子3，应该可以看出c函数是一个闭包的形式，一个函数里面嵌套了另外一个函数，被嵌套的函数被缓存了，也就是c函数，但是此处的写法略有不同,var d = a(); d();等同于a()();这里只是进行了一次缓存，这样就好理解了；还有要注意的是：这段代码有两个特点：1、函数c嵌套在函数a内部；2、函数a返回函数c。例子4：12345678910var name = &quot;The Window&quot;; var object = &#123; name: &quot;My Object&quot;, getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //The Window 解释一下，其实这块很简单，getNameFunc()第一次执行时，如果在里面打印出this的话，这个this指向的是object,就返回了function() {return this.name;};，当getNameFunc()()执行时，就是执行function() {return this.name};这样一句话，这里的this指向的就是window了，所以最后的结果就是The Window了;例子5：1234567891011var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //My Object 这个例子的话，和上面的相比，多了var that = this;,然后返回的是that.name;;参考上面的解释，很明显可以看出，因为var that = this, 返回的that.name,改变了this的指向，that指向的就是object了，所以最后的结果就是My Object了；使用闭包的注意点：1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。如果理解这些，我觉着闭包也就八九不离十了！]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js封装——封装一些小例（栗）子]]></title>
    <url>%2F2017%2F05%2F26%2Fjs%E5%B0%81%E8%A3%85%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E4%B8%80%E4%BA%9B%E5%B0%8F%E4%BE%8B%EF%BC%88%E6%A0%97%EF%BC%89%E5%AD%90%2F</url>
    <content type="text"><![CDATA[在开发过程中，经常会遇到很多相同的效果和逻辑交互，相同的代码要写很多次，代码重复，这样会导致很多问题，具体问题就不说了，大家应该都懂！今天，通过几个封装效果的几个实例，来实现代码的复用，让你的代码也变的简洁高效起来吧！请往下看： 封装，就是把一个零零散散的东西做成一个组件。实现共同调用，但又不相互影响，实现代码复用！网上的关于这类文章的介绍很多，我这里就不多介绍，直接上手写几个小栗子，我想会更直接；示例1如图：仿的百度输入法的效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263css: &lt;style&gt; body,ul, li, button &#123; margin: 0; padding: 0; &#125; body &#123; font: 12px/1.5 Tahoma; &#125; ul &#123; list-style-type: none; &#125; button &#123; cursor: pointer; &#125; #outer &#123; width: 70px; margin: 10px auto; &#125; .ime &#123; margin-top: 5px; background: #fff; border: 1px solid #9a99ff; display: none; &#125; .ime li &#123; width: 100%; line-height: 24px; display: inline-block; vertical-align: top; &#125; .close &#123; border-top: 1px solid #9a99ff; &#125; .ime li a &#123; color: #00c; padding: 0 5px; display: block; text-decoration: none; &#125; .ime li a:hover &#123; background: #d9e1f6; &#125; &lt;/style&gt; html: &lt;div id=&quot;outer&quot;&gt; &lt;button&gt;输入法&lt;/button&gt; &lt;ul class=&quot;ime&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;手写&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;拼音&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;close&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;关闭&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 重点js（未经封装的常规写法）：123456789101112window.onload = function() &#123; var oBtn = document.getElementsByTagName(&quot;button&quot;)[0]; var oIme = document.getElementById(&quot;ime&quot;); var oClose = document.getElementById(&quot;close&quot;); var style = oIme.style; oBtn.onclick = function() &#123; style.display = style.display == &quot;block&quot; ? &quot;none&quot; : &quot;block&quot; &#125;; oClose.onclick = function() &#123; style.display = &quot;none&quot; &#125;&#125;; 封装后的写法：1234567891011121314151617181920212223window.onload = function() &#123; new Writes(&quot;outer&quot;); //调用方法，直接new一下就行了&#125;function Writes(id) &#123; var oUter = document.getElementById(id); this.oBtn = oUter.getElementsByTagName(&quot;button&quot;)[0]; this.oIme = oUter.getElementsByClassName(&quot;ime&quot;)[0]; this.oClose = oUter.getElementsByClassName(&quot;close&quot;)[0]; var _this = this; this.style = this.oIme.style; this.oBtn.onclick = function() &#123; _this.shows(this); &#125;; this.oClose.onclick = function() &#123; _this.hides(this); &#125;;&#125;;Writes.prototype.shows = function() &#123; this.style.display = this.style.display == &quot;block&quot; ? &quot;none&quot; : &quot;block&quot;&#125;;Writes.prototype.hides = function() &#123; this.style.display = &quot;none&quot;&#125;; 示例2如图：弹出层效果，很常见的效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121css:&lt;style&gt; html, body &#123; height: 100%; overflow: hidden; &#125; body, div, h2 &#123; margin: 0; padding: 0; &#125; body &#123; font: 12px/1.5 Tahoma; &#125; center &#123; padding-top: 10px; &#125; button &#123; cursor: pointer; &#125; .overlay &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; opacity: 0.5; filter: alpha(opacity=50); display: none; &#125; .win &#123; position: absolute; top: 50%; left: 50%; width: 400px; height: 200px; background: #fff; border: 4px solid #f90; margin: -102px 0 0 -202px; display: none; &#125; h2 &#123; font-size: 12px; text-align: right; background: #FC0; border-bottom: 3px solid #f90; padding: 5px; &#125; h2 span &#123; color: #f90; cursor: pointer; background: #fff; border: 1px solid #f90; padding: 0 2px; &#125; &lt;/style&gt; html: &lt;div id=&quot;cont&quot;&gt; &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; &lt;div class=&quot;win&quot;&gt; &lt;h2&gt;&lt;span class=&quot;close&quot;&gt;×&lt;/span&gt;&lt;/h2&gt; &lt;/div&gt; &lt;button&gt;弹出层&lt;/button&gt; &lt;/div&gt;未封装的写法：--------------------------window.onload = function() &#123; var cont = document.getElementById(&apos;cont&apos;); var oWin = document.getElementsByClassName(&quot;win&quot;)[0]; var oLay = document.getElementsByClassName(&quot;overlay&quot;)[0]; var oBtn = document.getElementsByTagName(&quot;button&quot;)[0]; var oClose = document.getElementsByClassName(&quot;close&quot;)[0]; oBtn.onclick = function() &#123; oLay.style.display = &quot;block&quot;; oWin.style.display = &quot;block&quot; &#125;; oClose.onclick = function() &#123; oLay.style.display = &quot;none&quot;; oWin.style.display = &quot;none&quot; &#125;;&#125;;封装后的写法，对比一下--------------------------window.onload = function() &#123; new shows(&apos;cont&apos;); //调用方法，直接new一下就行了&#125;;function shows(id) &#123; var cont = document.getElementById(id); this.oWin = cont.getElementsByClassName(&quot;win&quot;)[0]; this.oLay = cont.getElementsByClassName(&quot;overlay&quot;)[0]; this.oBtn = cont.getElementsByTagName(&quot;button&quot;)[0]; this.oClose = cont.getElementsByClassName(&quot;close&quot;)[0]; var _this = this; this.oBtn.onclick = function() &#123; _this.block(); &#125;; this.oClose.onclick = function() &#123; _this.none(); &#125;&#125;;shows.prototype.block = function() &#123; this.oLay.style.display = &quot;block&quot;; this.oWin.style.display = &quot;block&quot;&#125;;shows.prototype.none = function() &#123; this.oLay.style.display = &quot;none&quot;; this.oWin.style.display = &quot;none&quot;&#125;; 简单总结：1.不能存在函数嵌套，全局变量；2.window.onload改写成构造函数的形式；3.全局变量改写成属性；4.函数改写成方法；6.最后，注意一下this,事件方法，闭包，传参这几点注意一下，就ok了？ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于跨域jsonp]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9Fjsonp%2F</url>
    <content type="text"><![CDATA[今天没什么太忙的事，准备写一个关于jsonp的文章，参考了网上不少文章，感觉自己的理解没有网上一些文章理解的透彻，所以这里选了一篇比较好的文章，当自己的笔记吧！一边以后自己的查阅！什么是JSONP？1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准。 2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力。 script、img、iframe 3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理。4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据。 5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。JSONP的客户端具体实现： 1alert(&apos;我是远程文件&apos;); 本地服务器localserver.com下有个jsonp.html页面代码如下： 12345678910&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data)&#123; alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); &#125;; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; remote.js文件代码如下： 1localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;); 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端 “我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了看jsonp.html页面的代码：12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：12345flightHandler(&#123; &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用jQuery如何实现jsonp调用？ 123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt;&lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json)&#123; alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？这里针对ajax与jsonp的异同再做一些补充说明： 1、ajax和jsonp这两种技术在调用方式上”看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装。 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！ 个人感觉，这篇文章写的还是比较全面的，挺好的！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解前端语义化（转载）]]></title>
    <url>%2F2017%2F05%2F25%2F%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.Web标准Web标准是由一系列标准组合而成。一个网页主要由三部分组成：结构层、表现层和行为层。对应的标准也分三方面：结构化标准语言主要包括XHTML和HTML以及XML，表现层标准语言主要包括CSS，行为标准主要包括对象模型，DOM、ECMAScript等。结构化标准语言，就是W3C规定的那样; ㈠标签的书写，需要开始和结束。单便签除外；㈡块级元素不能放在标签里面。li内可以包含div标签。㈢块元素里面可以放在块和内联，特殊的 p和 h1—h6里面不要放块元素，li和div可以放很多。因为这两个标签，本身就有容器的属性㈣内联里面要放内联，不要放块。㈤结构与表现分离㈥命名一定要规范表现层标准：css的书写，首先要尽可能使用外部引入的方式，因为结构层尽可能的减少表现层的代码过多出现。达到分离的目的。css的选择器有哪些，那些属性可以继承，那些不可以继承。他们之间的优先级是怎么样的。怎么用最简洁的css代码表达设计者的想法，而不只是实现设计者的想法就没事了。我们要的是代码简洁，代码过多，反而让浏览器解析很多，浪费时间。行为层标准：主要是JavaScript中的知识。比如DOM、ECMAScript。使用javascript中的标准，即可。一般对于用户的行为，或者说页面上的动态效果的一些特殊实现，我们可以会考虑到使用javascript来进行书写，但是代码的可复用性，模块化。变量，作用域。可能更多的就是javascript的规定了。自己把自己的理解程度说出来就可以了。 2.标签语义化 什么是语义化？其实简单说来就是让机器可以读懂内容。web页面的解析是由搜索引擎来进行搜索，机器来解析。所以语义化的标准是，尽可能的让机器读懂。最初的HTML中如h1~h6、thead、ul、ol等标签，通过标签的语义，最初设计的想法，来达到语义化的要求。如标题、表头、无序、有序列表，搜索引擎很好的利用了这些语义化标签抓取内容后来，最初定义的HTML语义化标签，不足以实现对Web页面各个部分的功能或位置描述，所以Web前端人员利用HTML标签的id和class属性，进一步对HTML标签进行描述，如对页脚HTML标签添加如id=”footer”或者class=”footer”的属性（值），以“无声”的方式在不同的前端程序员或者前后端程序员间实现交流。制定HTML5的W3C组织采用了诸如header、footer、section等语义化标签，来进行页面布局的设计想法，弥补了采用id=”header”或者class=”section”等。更深层次的语义化，是自己在团队合作的过程中，对于需要声明的变量和class，id。尽可能使用彼此能理解的英文。这样减少合作的成本，加快合作的效率。为什么要语义化？ 1.)为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 2.)用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 3.)有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 4.)方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 5.)便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 写HTML代码时应注意什么？ 1.)尽可能少的使用无语义的标签div和span； 2.)在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 3.)不要使用纯样式标签，如：b、font、u等，改用css设置。 4.)需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 5.)使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 6.)表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 7.)每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>转载</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的变量提升]]></title>
    <url>%2F2017%2F05%2F24%2Fjs%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[在JavaScript 中，函数及变量的声明都将被提升到函数的最顶部，变量可以在使用后声明，也就是变量可以先使用再声明。变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。虽然，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解；但是理解变量提升还是很有用的！ 实例1 123x=5; //设置x的值为5console.log(x); //5var x; //声明变量x 注意看看，下面的例子，和实例1是相同的，但是写法是不同的；123var x; //声明变量xx=5; //设置x的值为5console.log(x) //5 从上面2个例子，就大概知道变量提升了（hoisting）;为了更好的理解，看一下面的例子；实例21234var x=5; //初始化var y=1; //初始化console.log(x); //5console.log(y); //1 换一下位置实例31234var x=5; //初始化console.log(x); //5console.log(y); //undefinedvar y=1; //初始化 实例3的代码。等同于以下写法：12345var x=5; //初始化var y //这里y提升了，初始化的var y = 1 不会提升console.log(x); //5console.log(y); //undefinedy=1; //初始化 从实例2和实例3的对比可以看出， 在js中，只有声明的变量会提升，初始化的不会。再看一下，函数声明；实例4123456function foo()&#123; var x; console.log(x) x=5;&#125;foo() //undefined 和上面的例子差不多相同，接着往下看；1234567891011function test() &#123; foo(); // TypeError &quot;foo is not a function&quot; bar(); // 0 var foo = function () &#123; // 变量指向函数表达式 alert(1); &#125; function bar() &#123; // 函数声明 函数名为bar alert(0); &#125; &#125; test(); 命名函数：12345678foo(); // TypeError &quot;foo is not a function&quot; bar(); // valid baz(); // TypeError &quot;baz is not a function&quot; spam(); // ReferenceError &quot;spam is not defined&quot; var foo = function () &#123;&#125;; // foo指向匿名函数 function bar() &#123;&#125;; // 函数声明 var baz = function spam() &#123;&#125;; // 命名函数，只有baz被提升，spam不会被提升。 上面可以看出，只有函数式的声明才会连同函数体一起被提升。foo的声明会被提升，但是它指向的函数体只会在执行的时候才被赋值。 //函数声明：像这种形式：function foo(){}； 接下来，看看函数的声明和变量的声明的优先级；12345678910111213141516171819function a()&#123; &#125; var a; alert(a);//打印出a的函数体 -------------------var a; function a()&#123; &#125; alert(a);//打印出a的函数体 -------------------var a=1; function a()&#123; &#125; alert(a);//打印出1 -------------------function a()&#123; &#125; var a=1; alert(a);//打印出1 由此可以看出来什么？函数的声明比变量的声明具有高的优先级！ ECMAScript参考文档上说 如果变量在函数体类声明，则它是函数作用域。否则，它是全局作用域（作为global的属性）。变量将会在执行进入作用域的时候被创建。块不会定义新的作用域，只有函数声明和程序才会创造新的作用域。变量在创建的时候会被初始化为undefined。如果变量声明语句里面带有赋值操作，则赋值操作只有被执行到的时候才会发生，而不是创建的时候。(方便理解) 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么用vue-cli构建自己的vue2.0的项目]]></title>
    <url>%2F2017%2F05%2F23%2F%E6%80%8E%E4%B9%88%E7%94%A8vue-cli%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84vue2-0%E7%9A%84%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[博客里的一些小示例都是在vue-cli的基础上构建的，为了方便学习，这里把vue-cli构建项目的方法说一下！怎样从零开始，构建一个简单的vue2.0项目！ 这里首先说一下，vue-cli是什么？ vue-cli是官方提供的一个脚手架，个人感觉比较适合新手同学来学习vue！ 1.首先，要安装node和npm 这里先不说这两的安装方法，可以自行到网上搜索一下，例子还是很多的； 2.开始了，这里说一下，因为npm install安装的太慢，如果你的网速还比较渣的话，那我只能对你说自求多福吧！ 这里推荐使用淘宝镜像；一下是安装方法：打开命令行工具，输入： 1npm install -g cnpm --registry= https://registry.npm.taobao.org 安装完成后，输入 1cnpm -v 如果出现版本号，就说明安装成功了！ 3.接下来，安装webpack打开命令行工具输入：1npm install webpack -g 安装完成之后输入 webpack -v，如果出现相应的版本号，则说明安装成功。因为安装了淘宝的镜像，可以直接输入：1cnpm install webpack -g 4.接下来，安装vue-cli脚手架构建工具安装vue-cli脚手架构建工具，打开命令行工具输入：1npm install vue-cli -g 安装完成之后输入 vue -V（注意这里是大写的“V”）,如果出现相应的版本号，则说明安装成功。 5.新建一个文件夹，放置你的项目cd 目录路径，然后输入命令：123vue init webpack projectName //projectName是你的工程名称，可自行输入``` 接下来出现 $ vue init webpack projectName ——————— 这个是那个安装vue脚手架的命令This will install Vue 2.x version of the template. ———————这里说明将要创建一个vue 2.x版本的项目For Vue 1.x use: vue init webpack#1.0 projectName? Project name (projectName) ———————项目名称? Project name projectName? Project description (A Vue.js project) ———————项目描述? Project description A Vue.js project? Author Datura ——————— 项目创建者? Author Datura? Vue build (Use arrow keys)? Vue build standalone? Install vue-router? (Y/n) ——————— 是否安装Vue路由，也就是以后是spa（但页面应用需要的模块）? Install vue-router? Yes? Use ESLint to lint your code? (Y/n) n ———————是否启用eslint检测规则，这里个人建议选no,血的教训? Use ESLint to lint your code? No? Setup unit tests with Karma + Mocha? (Y/n) ——————-单元测试，可选可不选? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? (Y/n) ——————-单元测试，可选可不选? Setup e2e tests with Nightwatch? Yesvue-cli · Generated “projectName”.12&lt;h3&gt;6.启动项目&lt;/h3&gt;依次输入以下命令即可： cd exprice //切换到你的工程目录npm install //安装依赖，node-modulesnpm run dev //运行项目```出现下图，你就成功了 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现一些跨浏览器的兼容事件方法]]></title>
    <url>%2F2017%2F05%2F18%2Fjs%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用JavaScript实现事件的绑定，移除，以及一些常用的事件属性的获取，时常要考虑到在不同浏览器下的兼容性，下面给出了一个跨浏览器的事件对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var EventUtil = &#123; on: function(element, type, handler) &#123;/* 添加事件 */ if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123;//IE 注意：此时事件处理程序会在全局作用域中运行，因此用attachEvent绑定的事件，此时在事件处理函数里的this 等于window，使用时要注意 element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, off: function(element, type, handler) &#123;/* 移除事件 */ if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, getEvent: function(event) &#123;/* 返回对event对象的引用 */ return event ? event : window.event; &#125;, getTarget: function(event) &#123;/* 返回事件的目标 */ return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; /* 取消事件的默认行为 */ if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123;/* 阻止事件冒泡 */ if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, /* mouseover 和mouserout 这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。*/ getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123;//IE8 mouserout事件 return event.toElement; &#125; else if (event.fromElement) &#123;//IE8 mouseover事件 return event.fromElement; &#125; else &#123; return null;//其他事件 &#125; &#125;&#125; 调用如下：1234EventUtil.on(document, &quot;click&quot;, function(event)&#123;//为document元素绑定click事件 event = EventUtil.getEvent(event);//获取event事件对象 alert(&quot;Screen coordinates: &quot; + event.screenX + &quot;,&quot; + event.screenY);&#125;); 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么理解[].forEach.call()？]]></title>
    <url>%2F2017%2F05%2F16%2F%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-forEach-call-%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[今天，在网上看到javascript的[].forEach.call()写法，刚看到的时候有点蒙，不是太明白是什么意思！后来到网上查了一下，其实这东西是个简写的写法。如下：123456789function forEach(elems, callback) &#123; if([].forEach) &#123; [].forEach.call(elems, callback); &#125; else &#123; for(var i = 0; i &lt; elems.length; i++) &#123; callback(elems[i], i); &#125; &#125;&#125; [] 就是个数组，而且是用不到的空数组,用来就是为了访问它的数组相关方法。那完整的写法是什么呢？ 其实是这样的：1Array.prototype.forEach.call(...); 很显然，简写更方便。js中的forEach 方法，它可以接受一个函数参数，如下：1[1,2,3].forEach(function (num) &#123; console.log(num); &#125;); 上面的这句代码中，我们可以访问 this 对象，也就是 [1,2,3] ，可以看出，这个 this 是个数组。 最后， .call 是一个prototype，JavaScript函数内置的。 .call 使用它的第一个参数替换掉上面说的这个 this ，也就是你要传人的数组，其它的参数就跟 forEach 方法的参数一样了。123456[1, 2, 3].forEach.call([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], function (item, i, arr) &#123; console.log(i + &quot;: &quot; + item);&#125;);// 0: &quot;a&quot;// 1: &quot;b&quot;// 2: &quot;c&quot; 因此， [].forEach.call() 是一种快速的方法访问 forEach ，并将空数组的 this 换成想要遍历的list。 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单-Vue 2.0渐进式前端解决方案（Vue.js作者尤雨溪）(转载)]]></title>
    <url>%2F2017%2F05%2F15%2F%E7%AE%80%E5%8D%95-Vue-2-0%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88Vue-js%E4%BD%9C%E8%80%85%E5%B0%A4%E9%9B%A8%E6%BA%AA%EF%BC%89-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[(转载) 本人的新博客上线了：https://sky-xsk.github.io/ 主流框架分析我们看一下现有的一些主流框架从少到多所解决的问题。这个多少并不是来评价框架的好坏，而是从设计的角度出发看它涵盖多少内容。 纯模板引擎：最少的就是纯模板引擎，只管状态到界面的映射。 React和Vue：其实这两者都是非常专注的只做状态到界面映射，以及组件。 Backbone：它会给你多一些架构上指导，比如它会让你分层。 Angular：它做的事情就更多，它有自己的路由，这些都会包含在里面。 Ember：相比Angular，Ember做得就更加彻底，Ember信奉的是约定优于配置，它会将一切都帮你设计好打包好，你就开箱用就可以了。 Meteor：Meteor只是一个极端，它是从前到后全都包含，从前端到数据层到数据库，全都帮你打包好。 通过简单的分析，我们可以感受到，做得少的框架不一定就不如做得多的框架，这体现出一种取舍。也就是说，做得少的框架可以给你更多的灵活性，但你需要做更多的选择；做得多的框架有更强的侵入性，学习成本更高，灵活性更低。一旦选择了一个侵入性强的框架，那么一些小的部分你就没有机会去切换成其他你更想用的方案。Vue的定位与其他框架的区别就是渐进式的想法，也就是“Progressive”——这个词在英文中定义是渐进，一步一步，不是说你必须一竿子把所有的东西都用上。Vue的设计接下来我们回到之前看的图： Vue从设计角度来讲，虽然能够涵盖这张图上所有的东西，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。Vue的实现接下来深入讲一讲这些具体的概念以及Vue在这些概念上具体是做怎样的实现。(1) 声明式渲染现在基本所有的框架都已经认同这个看法——DOM应尽可能是一个函数式到状态的映射状态即是唯一的真相，而Dom状态只是数据状态的一个映射，所有的逻辑应该尽量在状体的层面上去进行，当状态改变的时候，View应该是在框架帮助下自动更新到合理的状态，而不是当观察到数据变化后手动的选择元素再命令式改动它的属性下图是Vue的一个模板示例，如果没有用过Vue的话，可以大概感觉到这是一个怎样的概念声明式渲染 其实，在模板语法上，Vue跟Angular是比较相似。在Vue1.0里面，模板实现跟Angular类似，如下图所示，把模板直接做成在浏览器里面parse成DOM树，然后去遍历这个树，提取其中的各种绑定。aa.png 在Vue2.0中，渲染层的实现做了根本性改动，引入了虚拟DOM从架构上讲，2.0依然写同样的模板，在最左边，Vue2.0跟1.0的模板语法绝大部分是兼容的。Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个虚拟DOM的树。这个树非常轻量，它的职责就是描述当前界面所应处的状态。当我们有了这个虚拟的树之后，再交给一个patch函数，负责把这些虚拟DOM真正施加到真实的DOM上。在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到的数据来源之后，之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新树与旧树进行对比，就可以最终得出应施加到真实DOM上的改动。最后再通过patch函数施加改动。这样做的主要原因是，在浏览器当中，JavaScript的运算在现代的引擎中非常快，但DOM本身是非常缓慢的东西。当你调用原生DOM API的时候，浏览器需要在JavaScript引擎的语境下去接触原生的DOM的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实DOM的操作是最少的。下面看渲染函数。用过React的开发者可能知道，React是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树。JSX实际就是一套用于让我们更简单地去描述树状结构的语法糖如下图所示，在Vue2.0当中，可以看到就是说当比如左侧的模板，经过Vue的编译之后就会变成右侧的东西。 此函数类似于创建一个虚拟元素的函数，我们可以给它一个名字，给它描述应该有的属性特性和可能其他的数据。然后后面这个最后这个参数是个数组，包含了该虚拟元素的子元素。总的来说2.0的编译器做的就是这个活。同时，在Vue2.0里，用户可以选择直接跳过模板这一层去手写渲染函数，同时也有可选JSX支持。从开发者的偏好以及开发者的效益的角度来考量，模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。JSX和直接渲染函数，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。所以在Vue2.0里，两个都是可以选择的。在绝大部分情况下使用模板，但是在需要复杂逻辑的情况下，使用渲染函数。在Vue2.0的路由和内部的一些实践上，都大量地应用渲染函数做复杂的抽象组件，比如过渡动画组件以及路由里面的link组件，都是用渲染函数实现的，同时还保留了它本身的依赖追踪系统。举例在渲染函数里面用到A.B的时候，这个就会触发对应的 getter。整个渲染流程具体要点如下：当某个数据属性被用到时，触发 getter，这个属性就会被作为依赖被 watcher 记录下来。整个函数被渲染完的时候，每一个被用到的数据属性都会被记录。相应的数据变动时，例如给它一个新的值，就会触发 setter，通知数据对象对应数据有变化。此时会通知对应的组件，其数据依赖有所改动，需要重新渲染。对应的组件再次调动渲染函数，生成 Virtual DOM，实现 DOM 更新。 这样一个流程跟主流的一些框架，例如React是有较大区别的。在React中，当组件复杂的时候需要用 shouldComponentUpdate 做优化。但是，它也有自己的各种坑，比如要确保该组件下面的组件不依赖外部的状态。虽说这在大部分情况下是够用的，但遇到极大复杂度的应用，遇到性能瓶颈的时候，这个流程优化起来也是相当复杂的一个话题。如下图所示，在Vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要手动优化。用Vue渲染这些组件的时候，数据变了，对应的组件基本上去除了手动优化的必要性。2.png （2）组件系统相信基本上所有的现代框架都已经走向了组件化道路，Web Components 从规范层面做这个实践。主流框架都有各有不同的封装，但核心思想都是一样，把UI结构映射到恰当的组件树。在Vue中，父子组件之间的通信是通过 props 传递。从父向子单向传递；而如果子组件想要在父组件作用里面产生副作用，就需要去派发事件。这样就形成一个基本的父子通信模式，在涉及大规模状态管理的时候会有额外的方案，这个后面会提到Vue的组件引入构建工具之后有一个单文件组件概念，如下图所示，就是这个Vue文件。在同一个Vue文件里，可以同时写 template、script 和 style，三个东西放在一个里面。同时，Vue的单文件组件和 Web Components 有一个本质不同，它是基于构建工具实现。这样的好处是有了一个构建的机会，可以对这些单文件组件做更多的分析处，在每一个语言块里可以单独使用不同的处理器，这点后面还会讲到。单文件组件 （3）客户端路由在做一个界面复杂度非常的高应用时，它会有很多的状态，这样的应用显然不可能在每做一次操作后都刷新一个页面作为用户反馈。这就要这个应用有多个复杂的状态，同时这些状态还要对应到URL。有一个重要的功能叫做 deep-linking，也就是当用户浏览到一个URL，然后把它传给另外的人或者复制重新打开，应用需要直接渲染出这个URL对应的状态。这就意味着应用的URL和组件树的状态之间有一个映射关系，客户端路由的职责就是让这个映射关系声明式地对应起来。 可能同一层的路由有多个不同的出口，还有着复杂的URL匹配规则，等等。这些问题如果都由自己去一一实现，那么复杂度是非常高的。而Vue基本都有对应的解决方案（router.vuejs.org）。配合Webpack还可以实现基于路由的懒加载，一条路径所对应的组件在打包的时候，会分离成另外一块，只有当该路由被访问的时候，才会被加载出来。这有相应的解决方案，同时也有实例。（4）状态管理说到状态管理，本质上就是把整个应用抽象为下图中的循环。脸书最早提出 Flux 这个概念的时，也是一个很松散的概念，而且官方的实现本身做得很难用。所以，社区就做了各种各样的探索。图中的这三个东西是一个单向数据流，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使State产生变化，从而导致 View 重新渲染。 一个单独的Vue的组件，其实就已经是这样的结构。但是当多个这样的组件来配套的时候，就会遇到一个问题。每个组件都有它自己的状态，但整个应用的状态，跟组件之间并不一定存在一一对应的关系。这个状态可能是一个全局状态。那么状态到底放在哪里？大部分解决方案是把这个状态从组件树中提取出来，放在一个全局的 Store 里面。Vuex 也是这样做的，但是它是针对 Vue 做了特化我们看到最左边就是Vue的组件，这些组件在大部分情况下，就不再有私有的状态，而是从全局的 Store 里面获取状态。Actions 和 Mutations 比较难用一两句话说清楚，大致就是当应用状态进行改变的时候，需要通过 Mutations 去显式地触发，而 Actions 则是负责异步和其他副作用。由于 Mutations 会被记录下来，我们可以把这些记录发到工具里面去做分析，甚至进行回滚。当发现bug的时候，这使得我们可以更好地理解大型应用中的状态变化。更多的细节，还请看官方文档（vuex.vuejs.org）。6.png （5）构建工具构建工具方面，Vue有一个官方的，全局安装的 vue-cli。这里有一个笔误。全局安装之后，我们就可以用 vue 命令创建一个新的项目，Vue 的 CLI 跟其他 CLI 不同之处在于，有多个可选模板，有简单的也有复杂的。极简的配置，更快的安装，可以更快的上手。它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。所有的模板在创建之后，构建脚本都是通过 npm 脚本来执行，在国内安装 npm 依赖的时候有点卡，可以用 yarn 或者推荐用淘宝的 npm 镜象源，可以很大地提升安装速度。之前提到了单文件组件，如下图所示，支持任意的处理器，开箱即用的热重载，所以组件都支持热重载 (hot-reload)。当你做了修改，不会刷新页面，只是对组件本身进行立刻重载，不会影响整个应用当前的状态。CSS也支持热重载。我们看下左下角，在使用这个预处理器的同时，我们只需要添加一个 scoped 特性，Vue 会通过对模板和CSS代码的解析改写，来模拟CSS的效果。同时单文件组件也支持懒加载，一个懒加载的组件和它的依赖会被打包成一个额外的包，只有被用到的时候才加载，这对首屏的加载速度也是很有帮助的。1.png 如下图所示，这个开发者工具本身也是用Vue写的2.png 使用它的话可以看到我们当前应用的组件树结构。3.png 点击组件，就可以观察这个组件当前的状态。也可以把这个组件发送到控制台里。同时这个开发者工具还有一个 Vuex 面板，如果你用了 Vuex，那么每次操作都会被记录下来，记录下来的状态之间可以进行跳转。除此之外，还支持把当前应用的状态快照发送给另外一个人，这个人可以在他的控制台里导入你发送的状态，就可以立刻跳转到你之前所在的状态。这对于重现一些 bug，或要描述当前状态都很有帮助。Vue2.0Vue2.0在不久之前刚刚发布（具体报道参见http://t.cn/RVC0foZ），之前一些技术细节在前文中已有所涉及。Vue2.0相对于1.0的改进有以下几点。1、更轻对Vue1.0大小压缩，Vue2.0它有一个只包含运行时的版本，所有的模板在编译的时候已经完成了。基于这个版本，下图中Vue、vue-router和vuex三个（都是 2.0 版本）加一起，跟Vue1.0的核心库大小一样。2、更快Vue2.0可以说是当前最快的框架之一。这个是基于第三方独立测试的结果。有兴趣的话，可以移步链接进行查看。这个测试是一个比较综合的测试，它对于各种操作，以及在大列表里面更新移除等，都有相当完整的覆盖。可以看出，Vue2.0，不仅仅是在Vue1.0的基础上有很大提升，相比其他框架，也有相当明显的性能优势。3、Vue2.0 架构下图是Vue2.0的架构图，这里不深入讲整个架构的实现。 Vue2.0同时支持服务端，服务端渲染支持流式渲染。因为HTTP请求也是流式，Vue 的服务端渲染结果可以直接 pipe 到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。除了服务端渲染还有原生渲染，这里的原生渲染是指阿里巴巴的项目Weex。在架构层面，通过编译一个 Weex 源文件（类似于 Vue 单文件组建的格式）然后运行。界面节点的操作都是抽象的，这些抽象操作会派发到不同的目标引擎做实际的渲染，同时支持 iOS, Android 和 Web。Vue和Weex现在有一个合作，Vue 2.0 将会正式成为 Weex 的 JavaScript 运行时。这样的合作可以使得符合功能交集的Vue组件可以跨平台使用。(转载)12本人的github，里面有vue2.0的小项目练习，包括仿饿了么的客户端，vue2.0写的，基本功能已经实现，部分bug在修改中;如果觉得有用的话，请给个“star”；https://github.com/sky-xsk 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>vue2.0</tag>
        <tag>es6</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0,自己开发一个全局定义的公用组件（插件）]]></title>
    <url>%2F2017%2F05%2F11%2Fvue2-0-%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%AC%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%88%E6%8F%92%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天，在群里看到有朋友问这样一个问题：“我在项目里，怎么能做一个全局调用的组件，不用每一次都import，注册组件？”看到这个问题，我思考了一下，讲一下我的思路！ 这个问题里，所说的组件，在我看来也可以叫做“插件”，为什么这么说呢？因为这个和vue-resource之类的插件开发的思路是一样的？只是一个放到的是本地，一个是通过“npm install vue-resource ”下载下来的？换一个思路，如果我把自己开发的组件放到网上，是不是别人可以直接用我开发的插件呢？回答是：“必须的”！ 所以我就来做一个公共的组件：同样的开发环境vue-cli;这个就不说了！！！ 新建alerts.vue和alerts.js文件alerts.vue123456789101112131415161718&lt;template&gt; &lt;div class=&quot;alerts&quot;&gt; &lt;h2&gt;开发自定义组件//公共组件可直接在任意地方调用&lt;/h2&gt; &lt;button @click=&quot;clicks()&quot;&gt;点击我试一下&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, methods:&#123; clicks()&#123; alert(&quot;我是公共的组件！（插件）&quot;) &#125; &#125;, &#125;&lt;/script&gt; 这个很简单！接下来是重头戏了！alerts.js1234567const alertsComponent = require(&apos;./alerts.vue&apos;); //引入const alerts = &#123; install: function(Vue) &#123; Vue.component(&apos;alerts&apos;, alertsComponent) &#125;&#125;;module.exports = alerts; 此处注意文件的路径，不要弄错了； 在main.js里引用，和调其他插件的方法一样main.js12import alerts from &apos;./components/alerts/alerts&apos; //注意路径Vue.use(alerts); 调用方法1&lt;alerts&gt;&lt;/alerts&gt; 在任意组件里调用，均可！ 我的github，如果有用，不要吝啬，请给个star；在里面可以找到此例子的源码哦！1https://github.com/sky-xsk/vue2.0-start- 如有错误，请指正！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>vue2.0</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单聊聊javascript的继承]]></title>
    <url>%2F2017%2F05%2F09%2F%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8Ajavascript%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9B%2F</url>
    <content type="text"><![CDATA[在JS中继承是一个非常复杂的话题，比其他任何面向对象语言中的继承都复杂得多。在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可。在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，且JS是基于对象来继承的。（这话是比较官方的说法，看着都很专业） 在说继承之前，首先得先回答一个问题，什么是继承？我理解的继承，简单来说就是，–1.在原有类的基础上，进行可操作的修改，得到一个崭新的类，这个类有原来类的功能，同时也有自己的功能；–2.这个新的类，不会影响原有类的功能，不会相互干预； 这里肯定有人要问了，什么是‘可操作的修改呢？’说白了就是在不影响整个类的功能的前提下，进行的修改！这点和第二点略有重复，仔细想想，还是有所区别的！！！下面开始说说常用的集中继承方式： ###1.代码：12345678910111213141516171819202122function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;Person.prototype.showName = function() &#123; console.log(this.name);&#125;Person.prototype.showSex = function() &#123; console.log(this.sex);&#125;function work(name, sex, job) &#123; //构造函数伪装调用父级的构造函数——为了继承属性 Person.call(this, name, sex); //Person.apply(this, [name, sex]); //此处的call与apply是有区别的，往下看 this.job = job;&#125;work.prototype = Person.prototype; //通过prototype继承父级的属性work.prototype.showJob = function() &#123; console.log(this.job);&#125;var s = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;);s.showJob() //developer 简单的解释一下上面的代码：首先写了一个很简单的构造函数，在函数的原型上分别添加了showName和showSex的方法；紧接着写了一个work（）函数，这里注意work（）里面的参数，多了一个job参数，这个参数就是要继承的参数， Person.call(this, name, sex);有人问这里的this指的是啥？看下图：答案就是 new出来的work对象！work.prototype = Person.prototype;这句话就是通过prototype继承父级的属性，name和sex；然后就是在work的基础上添加showJob方法；最后就是new一个work对象，执行方法！最后work继承了Person的name和sex属性；是不是很好懂！ ###2.代码：123456789101112131415161718192021222324252627282930313233function Person(name, sex) &#123; this.name = name; this.sex = sex; &#125; Person.prototype.showName = function() &#123; alert(this.name); &#125;; Person.prototype.showSex = function() &#123; alert(this.sex); &#125;; function work(name, sex, job) &#123; Person.call(this, name, sex); this.job = job; &#125; //1.原型链 通过原型来继承父级的方法 //work.prototype=Person.prototype; // 2.原型链 通过原型来继承父级的方法(循环方法) // Person.prototype类型是object； for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; Worker.prototype.showJob = function() &#123; alert(this.job); &#125;; var p = new Person(&apos;xue&apos;, &apos;nan&apos;); var w = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;); // p.showName(); // p.showSex(); // w.showName(); // w.showSex(); // w.showJob(); 简单解释一下：1234``` for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; 这里只是用不同方法，通过原型链来继承父级的方法，原理是一样的！ call与apply的区别js中call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。说简单一点，这两函数的作用其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。如有错误请私信本人！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度复用的弹出框组件的写法 vue2.0]]></title>
    <url>%2F2017%2F05%2F09%2F%E9%AB%98%E5%BA%A6%E5%A4%8D%E7%94%A8%E7%9A%84%E5%BC%B9%E5%87%BA%E6%A1%86%E7%BB%84%E4%BB%B6%E7%9A%84%E5%86%99%E6%B3%95-vue2.0%2F</url>
    <content type="text"><![CDATA[和以前的文章一样用的vue-cli;具体的 安装步骤这里不做详细的解释了；直接开始了；一定要存在其他的组件 新建一个alertip.vue组件；组件代码如下123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;tip&quot;&gt; &lt;p&gt;&#123;&#123;alertText&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;button @click=&quot;closeTip&quot;&gt;关闭&lt;/button&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;tip&apos;, components: &#123; &#125;, data() &#123; return &#123; &#125; &#125;, props: [&apos;alertText&apos;], //接收传的值 methods:&#123; closeTip()&#123; this.$emit(&apos;closeTip&apos;)；//分发事件 &#125; &#125;, &#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;!-- 此处的样式只是添加了效果，没有进行准确的排版，这里主要将vue的写法！--&gt;&lt;style scoped&gt;.tip&#123; width: 400px;height: 200px; overflow: hidden; position: fixed; left:38%;top:20%; background: #fff; border: 1px solid #ccc; padding:20px;&#125; &lt;/style&gt; 在其他组件里调用123456789101112131415161718192021222324252627&lt;/template&gt;&lt;div&gt; &lt;alertip v-show=&quot;alertipShow&quot; @closeTip=&quot;alertipShow = false&quot; :alertText=&quot;alertText&quot;&gt;&lt;/alertip&gt; //此处传值，点击事件 &lt;el-button type=&quot;primary&quot; @click=&quot;alerts()&quot;&gt;点击此按钮，出现浮动窗口&lt;/el-button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import alertip from &apos;./components/alertip.vue&apos;; //此处注意组件的路径 export default &#123; name: &apos;app&apos;, components: &#123; alertip &#125;, data() &#123; return &#123; alertipShow:false, alertText:&apos;&apos; &#125; &#125;, methods: &#123; alerts()&#123; this.alertText=&quot;此处的值为传过去的值，不同的页面用的同一个组件，但是弹出的内容是不同的！,这个信息在app组件里&quot;; this.alertipShow = true; &#125;, &#125;&#125; &lt;/script&gt; 其他页面同样的方法可以调用！展示的效果是一样的，但是不同组件可以传入的值可以是不同的，展示的内容也是不同的，但是效果弹窗是一样的！1源码见：https://github.com/sky-xsk/vue2.0-start- 给加个“star”哦！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0/Webpack 一个简单的todolist实例]]></title>
    <url>%2F2017%2F04%2F17%2Fvue2-0-Webpack-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84todolist%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[用的vue-cli,这里就不写过程了，直接上代码吧！同样自己用webpack自己搭一个项目实例！ 1234github地址：https://github.com/sky-xsk/vue2.0-start-vue2.0写的项目：https://github.com/sky-xsk/elem如果有帮助，请给个star； 首先是html12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;todo&quot;&gt; &lt;h2&gt;todolist&lt;/h2&gt; &lt;div class=&quot;t_input&quot;&gt; &lt;span&gt;&lt;input type=&quot;text&quot; class=&quot;t_titles&quot; placeholder=&quot;请输入。。。&quot; v-model=&quot;text&quot; @keyup.13=&quot;add()&quot;&gt;&lt;/span&gt; &lt;span&gt;&lt;button class=&quot;t_add&quot; @click=&quot;add()&quot;&gt;添加&lt;/button&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;t-cont&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in todolist&quot; track-by = &quot;$index&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;item.state&quot; class=&quot;checkbox&quot;/&gt; &#123;&#123;`$&#123;index+1&#125;. `&#125;&#125; &#123;&#123;item.value&#125;&#125; &lt;span @click = &quot;del(index)&quot;&gt;删除&lt;/span&gt; &lt;span @click = &quot;edit(index)&quot;&gt;编辑&lt;/span&gt; &lt;/li&gt; &lt;div class=&quot;check_che&quot; @click=&quot;remove()&quot; v-show=&quot;select.length &gt; 0&quot; &gt;删除选中&lt;/div&gt; &lt;p v-show=&quot;todolist.length == 0&quot;&gt;暂无数据！&lt;/p&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; export default &#123; name: &apos;todo&apos;, data() &#123; return &#123; todolist:[], text:&apos;&apos;, state: false, &#125; &#125;, methods:&#123; //添加 add()&#123; if(this.text == &apos;&apos;)&#123; return &#125;else&#123; this.todolist.push (&#123; value:this.text, state: false, &#125;) &#125; this.text=&apos;&apos;; &#125;, //删除 del(index)&#123; this.todolist.splice(index,1); &#125;, //删除选中 remove()&#123; this.todolist = this.todolist.filter((index) =&gt; !index.state) &#125;, //编辑 edit(index)&#123; this.text = this.todolist[index].value; this.todolist.splice(index,1); &#125; &#125;, //计算属性 computed: &#123; select() &#123; return this.todolist.filter((index) =&gt; index.state == true) &#125; &#125; &#125;&lt;/script&gt; css123456789101112131415&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.t_titles&#123; width: 400px; height: 35px; font-size: 16px; padding-left: 10px;&#125;.t_add&#123; width: 60px; height:40px; font-size: 16px; vertical-align: middle;&#125;.t-cont&#123; width:100%; margin-top: 20px; margin: 0 auto;&#125;.t-cont ul li&#123;list-style: none; height: 30px; border: 1px solid #ccc; line-height: 30px; text-align: left; padding-left: 10px;&#125;.t-cont ul li span&#123;float: right; cursor: pointer; padding-right: 10px;&#125;.t-cont ul li input&#123;padding-top: 5px;&#125;.checks&#123; width: 15px; height: 15px; border-radius:50%; border: 1px solid #ccc; display: inline-block;margin-top: 5px; cursor: pointer; &#125;.checkbox &#123; width: 18px; height: 18px;border: 1px solid #ccc; border-radius: 100%; position: relative; margin-right: 6px; vertical-align: middle; &#125;.checkbox:checked &#123;border-color: deepskyblue;&#125;.checkbox:checked:before &#123; content: &apos;&apos;; display: block; width: 80%; height: 80%; position: absolute; left: 50%; top: 50%;transform: translate(-50%, -50%); background: deepskyblue; border-radius: 100%;&#125;.check_che&#123;border: 1px solid #ccc; padding:10px;&#125;&lt;/style&gt; 效果如截图： 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue2.0</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用sourceTree，将自己的代码上传到github上去]]></title>
    <url>%2F2017%2F04%2F15%2F%E7%94%A8sourceTree%EF%BC%8C%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0github%E4%B8%8A%E5%8E%BB%2F</url>
    <content type="text"><![CDATA[GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 sourceTree是一个工具；接下来我就教大家怎么把自己的代码传到github上面去； 首先你注册一个sourceTree的账号和github的账号，我这边就不写怎么去注册了注册好账号后，在github上点击如图； 点击后，会弹出如下页面； 输入项目名称后，点击绿色按钮，即可； 打开新建的项目，点击绿色按钮，将地址复制下来 在本地新建一个文件夹，作为本地的仓库，接下来，打开sourceTree客户端，单击新建/克隆如图； 源路径填写刚才复制的地址，目标路径就会刚才新建的文件夹的路径；填好后，点击确定即可，这样你的仓库就克隆到本地了； 克隆到本地的仓库有个.git文件千万不要删掉；然后自己的代码复制到本地的仓库中去，然后点击Stage All后单击提交 接下来点击‘推送’ 到github上面看一下，代码推送成功！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>sourceTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0，jsonp的一个小案例 请求百度搜索的接口]]></title>
    <url>%2F2017%2F03%2F10%2Fvue2-0%EF%BC%8Cjsonp%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%A1%88%E4%BE%8B-%E8%AF%B7%E6%B1%82%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[我用的是vue-cli，可以自己去下一个试试看！JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的script 元素是一个例外。利用 script 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。 这里用的”vue-resource”里的示例；下面开始了： #html:123456789101112131415&lt;template&gt; &lt;div class=&quot;bar&quot;&gt; &lt;div id=&quot;box&quot;&gt; &lt;h1&gt;jsonp请求百度接口&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;t1&quot; @keyup=&quot;get($event)&quot; placeholder=&quot;请输入您要搜索的关键词&quot; class=&quot;input_s&quot; @keydown.down=&quot;changeDown()&quot; @keydown.up.prevent=&quot;changeUp()&quot;&gt; &lt;ul class=&quot;ul_se&quot;&gt; &lt;li v-for=&quot;(value,$index) in myData&quot; :class=&quot;&#123;gray:$index==now&#125;&quot; @click=&quot;clickChose($index)&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p v-show=&quot;myData.length==0&quot;&gt;暂无数据...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; #js:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; export default &#123; data() &#123; return &#123; myData:[], t1:&apos;&apos;, now:-1, &#125; &#125;, methods:&#123; get(ev)&#123; //键盘操作 if(ev.keyCode==38 || ev.keyCode==40) return; if(ev.keyCode==13)&#123; window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1); this.t1=&apos;&apos;; &#125; this.$http.jsonp(&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;, //跨域请求接口 &#123; params: &#123; wd:this.t1, &#125;, jsonp:&apos;cb&apos; &#125;).then(function(res)&#123; this.myData = JSON.parse(res.bodyText).s &#125;,function()&#123; console.log(&quot;请求失败！！！&quot;) &#125;); &#125;, changeDown()&#123; //下键选择 this.now++; if(this.now==this.myData.length)this.now=-1; this.t1=this.myData[this.now]; &#125;, changeUp()&#123; //上键选择 this.now--; if(this.now==-2)this.now=this.myData.length-1; this.t1=this.myData[this.now]; &#125;, clickChose($index)&#123; //鼠标选择搜索关键词事件 this.now = $index; this.t1=this.myData[this.now]; window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1); &#125;, &#125;, &#125;&lt;/script&gt; #css:1234567&lt;style scoped&gt;.ul_se&#123; background: #fff; border: 1px solid #ccc; width: 100%;&#125;.ul_se li&#123;list-style: none; height: 30px; line-height: 30px; cursor: pointer;&#125;.input_s&#123;width: 400px; height: 30px; padding-left: 10px;&#125;.gray&#123;background: deepskyblue; color: #fff;&#125;.ul_se li:hover&#123;background: deepskyblue; color: #fff;&#125;&lt;/style&gt; 最终效果：当你在输入框里输入搜索的关键词的时候，就会自动将联想的词汇显示在下方，按一下“enter”键，即可跳转到搜索结果 的页面，同是按“上”，“下”键可以进行选择搜索的关键词，鼠标也可以进行操作选择，跳转！ 以后搜索，直接打开就可以了！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于es6的部分语法介绍]]></title>
    <url>%2F2017%2F03%2F02%2F%E5%85%B3%E4%BA%8Ees6%E7%9A%84%E9%83%A8%E5%88%86%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[#es6的介绍ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准,组件分为：ECMA/DOM/BOMECMAscript简写是ECMA或者叫ES； #在线编译e6转换es5如果不是太熟悉的话，可以用用这个转换的小工具，对比一下es6语法的差别；1http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;code=%20const%20A%20%3D%20&apos;static%20A&apos;%3B%0D%0A%09%20%20%20%09%20console.log(A)%3B%0D%0A%09%20%20%20%09%20let%20b%20%3D&apos;b&apos;%3B%0D%0A%09%20%20%20%09%20console.log(b)%3B%0D%0A%0D%0A%09%20%20%20%09%20alert(A) #变量let1.let的使用范围有限，只能在代码里面使用，在代码外面的还就会弹出未定义,不能重复声明，也就是用同一个变量不能用两次2.如果是var的话，只有在函数里才有作用域 ###eg:12345678910111213141516#html:&lt;ul&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt;&lt;/ul&gt;#js:window.onload = function()&#123; var ali = document.getElementsByTagName(&apos;li&apos;); for(let i = 0;i&lt;ali.length;i++)&#123; ali[i].onclick = function()&#123; alert(i) &#125; &#125; &#125; #constconst的用法比较好理解，它一旦被赋值的话就不能被修改，常量必须在声明的同时赋值，否则会报错，而且通常常量用大写字母规范；和es5一样的一点是，不能重复的去声明，否则是会有问题的； ###eg:12const TEST1 = 0;const TEST2 = 1; #字符串的连接在es6中，字符串的连接变得更简单了，1###eg： var a = “我是字符串1”;var b = “我是字符串2”;var c = 把他们连起来$(a)把他们连起来$(b);console.log(c);123#给变量赋值现在的赋值更简单，更灵活，同时也减少的不少的代码量；###eg: var [a,b,c] = [1,2,3];打印一个：console.log(a);打印多个：console.log(a,b,c);1对，就是这个样！ var { a, c ,b } = { a:1, b:2 , c:3 }打印一个：console.log(a);打印多个：console.log(a,b,c);123```var [a,[b,c],d] = [1,[2,3],4];console.log(a,b,c,d); 12var [&#123;a,e&#125;&#125;,[b,c],d] = [&#123;e:&apos;eeee&apos;,a:&apos;aaaaa&apos;&#125;,[1,2],5] //这个有点变化，注意了console.log(a,b,c,d) 自己会一一对应的，不会因为顺序不同导致值的变化！ #数组数组的操作基本相同，这里介绍一个‘from’方法；‘复制数组’12345var arr = [1,2,3];var arr2 = Array.from(arr);arr2.pop();console.log(arr,arr2);Array.from(arr); 1234var arr = [1,2,3];var arr2 = [...arr];arr2.pop();console.log(arr,arr2); 这两种方法是相同的； #遍历es6用的是for…of..;有点变化！1234var arr = [1,2,2,2,2,2,2,3,4]; for(var i of arr)&#123; console.log(i)&#125; 值得注意的是:可以循环数组，但是不能循环json，他主要是循环map对象用的; #map12345var map = new Map();map.set(&apos;a&apos;,&apos;apple&apos;);map.set(&apos;b&apos;,&apos;banbana&apos;);alert(map.get(&apos;b&apos;)); //获取map.delete(‘a’); //删除 12345678var map = new Map();map.set(&apos;a&apos;,&apos;apple&apos;); map.set(&apos;b&apos;,&apos;banbana&apos;); map.set(&apos;c&apos;,&apos;orange&apos;); map.set(&apos;d&apos;,&apos;pear&apos;); for( var [key,value] of map)&#123; //循环了一下 console.log(value); &#125;; 12345var arr = [&apos;q&apos;,&apos;w&apos;,&apos;e&apos;,&apos;a&apos;,&apos;d&apos;,&apos;f&apos;,&apos;r&apos;] //一套带走，lol //entries循环key和value for(var name of arr.keys())&#123; console.log(name) &#125; #箭头函数（经常会遇到的，刚开始会很懵逼）这里做个对比，就一目了然了； ###es6 eg:123456789101112131415#html&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;#css#box&#123; width:200px; height:200px; border:1px solid #000; &#125;#jswindow.onload = function()&#123; var oBox = document.getElementById(&apos;box&apos;); oBox.onclick = () =&gt;&#123; oBox.style.background = &apos;red&apos;； &#125;&#125; ###es5 eg:123456789101112131415#html&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;#css#box&#123; width:200px; height:200px; border:1px solid #000; &#125;#jswindow.onload = function()&#123; var oBox = document.getElementById(&apos;box&apos;); oBox.onclick=function()&#123; oBox.style.background = &apos;red&apos;； &#125;&#125; #面向对象这个写法，感觉和java里的类有点像；1234567891011121314class Person&#123; constructor(name,age)&#123; this.name = name this.age = age &#125; showName()&#123; return this.name; &#125; showAge()&#123; return this.age; &#125; &#125; var p1 = new Person(&apos;aaa&apos;,10); alert(p1.showName()); 小提示：在es6的语法当中，私有作用域的代码块：{ } 包起来的就是代码块，就形成了一个作用域，称为块级作用域,这个的话和es5就有很大差别； ~~~后期会继续更新的; 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来来来，通俗的理解一下原型，原型链......]]></title>
    <url>%2F2016%2F12%2F26%2F%E6%9D%A5%E6%9D%A5%E6%9D%A5%EF%BC%8C%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[今天，在网上看到这个讲原型和原型链的通俗的分析，感觉对理解还是有帮助的，特此分享： 原型链理解起来有点绕了，网上资料也是很多，每次晚上睡不着的时候总喜欢在网上找点原型链和闭包的文章看，效果极好。不要纠结于那一堆术语了，那除了让你脑筋拧成麻花，真的不能帮你什么。简单粗暴点看原型链吧，想点与代码无关的事，比如人、妖以及人妖。 1）人是人他妈生的，妖是妖他妈生的。人和妖都是对象实例，而人他妈和妖他妈就是原型。原型也是对象，叫原型对象。 2）人他妈和人他爸啪啪啪能生出一堆人宝宝、妖他妈和妖他爸啪啪啪能生出一堆妖宝宝，啪啪啪就是构造函数，俗称造人。 3）人他妈会记录啪啪啪的信息，所以可以通过人他妈找到啪啪啪的信息，也就是说能通过原型对象找到构造函数。 4）人他妈可以生很多宝宝，但这些宝宝只有一个妈妈，这就是原型的唯一性。 5）人他妈也是由人他妈他妈生的，通过人他妈找到人他妈他妈，再通过人他妈他妈找到人他妈他妈……，这个关系叫做原型链。 6）原型链并不是无限的，当你通过人他妈一直往上找，最后发现你会发现人他妈他妈他妈……的他妈都不是人，也就是原型链最终指向null。 7）人他妈生的人会有人的样子，妖他妈生的妖会有妖的丑陋，这叫继承。 8）你继承了你妈的肤色，你妈继承了你妈他妈的肤色，你妈他妈……，这就是原型链的继承。 9）你谈对象了，她妈让你带上房产证去提货，你若没有，那她妈会问你妈有没有，你妈没有那她妈会问你妈她妈有没有……这就是原型链的向上搜索。 10）你会继承你妈的样子，但是你也可以去染发洗剪吹，就是说对象的属性可以自定义，会覆盖继承得到的属性。 11）虽然你洗剪吹了染成黄毛了，但你不能改变你妈的样子，你妈生的弟弟妹妹跟你的黄毛洗剪吹没一点关系，就是说对象实例不能改动原型的属性。 12）但是你家被你玩火烧了的话，那就是说你家你妈家你弟们家都被烧了，这就是原型属性的共享。 13）你妈外号阿珍，邻居大娘都叫你阿珍儿，但你妈头发从飘柔做成了金毛狮王后，隔壁大婶都改口叫你包租仔，这叫原型的动态性。 14）你妈爱美，又跑到韩国整形，整到你妈他妈都认不出来，即使你妈头发换回飘柔了，但隔壁邻居还是叫你金毛狮王子。因为没人认出你妈，整形后的你妈已经回炉再造了，这就是原型的整体重写。(转载！) 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>js</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js如何判断一个对象是不是Array？]]></title>
    <url>%2F2016%2F12%2F26%2Fjs%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AFArray%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[当听到这个问题的时候，肯定有人第一个想法就是用“typeof”来判断，实则，并不能实现；很忧伤！下面咱先来说一说“typeof”，在js中，对于Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任​，大家都懂的！ typeof​12var arr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);​​alert(typeof(arr)); 你会收到一个object ；什么破玩意；是不是这个时候想把键盘摔了，摔了没关系，再买吧！往下看： instanceof咱不能一条道走到黑，咱们得找其他的路子啊，对不对？JavaScript中instanceof运算符会返回一个 Boolean 类型的值，指出对象是否是特定类的一个实例。 使用方法：result = object instanceof class,还是刚刚的数组，成功的返回 true。​请看下面，看实际代码：12var arrayStr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);alert(arrayStr instanceof Array); 啊，成功了！高兴吧！这样真的可以了吗？是吗？其实​instanceof还是有一定的局限性的，一想到这，不是验证正确了吗？没毛病啊！事实上在多个frame中穿梭就会产生大问题了​？？？123456var iframe = document.createElement_x(&apos;iframe&apos;); document.body.appendChild(iframe); xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);//这个写法老古董IE下是不支持的，FF下才有;alert(arr instanceof Array); // falsealert(arr.constructor === Array); // false 返回结果为两个False，让人大失所望。为毛？ ​Object.prototype.toString( ) ECMA-262 写道1234Object.prototype.toString( ) When the toString method is called, the following steps are taken:Get the [[Class]] property of this object.Compute a string value by concatenating the three strings “[object “, Result (1), and “]”.Return Result (2) 上面的规范定义了Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。还是先来看看在ECMA标准中Array的描述吧。12new Array([ item0[, item1 [,…]]])The [[Class]] property of the newly constructed object is set to “Array”. 于是利用这点，第三种方法登场了。call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是’[object Array]’，以判断其是否是Array的实例。也许你要问了，为什么不直接o.toString()？嗯，虽然Array继承自Object，也会有toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：） 与前面几个方案不同，这个方法很好的解决了跨frame对象构建的问题，经过测试，各大浏览器兼容性也很好，可以放心使用。一个好消息是，很多框架，比如jQuery、Base2等等，都计划借鉴此方法以实现某些特殊的，比如数组、正则表达式等对象的类型判定，不用我们自己写了。另外Ext3 也已经换成这样的写法了;12isArray : function (v)&#123; return toString.apply(v) === &apos;[object Array]&apos;;&#125; 4.JQ中$isArray();话不多说，直接上代码吧！1234$(document).ready(function()&#123; var Arr = [&quot;4&quot;,&quot;8&quot;,&quot;1&quot;,&quot;3&quot;]; alert($.isArray(Arr));​&#125;)​ 返回的值为​Boolean 类型的值，是数组则返回一个“true”，反之“false”成了！​行就到这吧！希望大家多多支持！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈，实例mttq；]]></title>
    <url>%2F2016%2F12%2F20%2F%E6%B5%85%E8%B0%88%EF%BC%8C%E5%AE%9E%E4%BE%8Bmttq%EF%BC%9B%2F</url>
    <content type="text"><![CDATA[MQTT - MQ Telemetry TransportMQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。​ 早在1999年，IBM的Andy Stanford-Clark博士以及Arcom公司ArlenNipper博士发明了MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）技术[1] 。据Andy Stanford-Clark博士称，MQTT将在今年和明年呈现爆炸式增长。MQTT的话题是我俩谈论开源物联网平台Pachube时提到的。Stanford-Clark认为Pachube很酷，其不足之处是不具备真正的推送功能。你需要不断轮询才能得到即时数据。这正是MQTT能够实现的，他提到了使用推送通信系统的石油管道检测系统。轻量级的 machine-to-machine 通信协议。publish/subscribe模式。基于TCP/IP。支持QoS。适合于低带宽、不可靠连接、嵌入式设备、CPU内存资源紧张。是一种比较不错的Android消息推送方案。FacebookMessenger采用了MQTT。MQTT有可能成为物联网的重要协议。 下面一个实例，直接看代码：我放到云盘了，可以下载！1https://pan.baidu.com/s/1skZADJZ 例子有问题的话可以私信我！123这里说一下例子的使用方法：1.先去config去配置服务器的地址，前提是在服务器上已经配置好了MQTT协议，2.配置好后，将index.html在浏览器中打开，打开两份，这样你在一个页面发送信息，另一个页面就可以收到了！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>mttq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap VS jQuery Mobile 对比！]]></title>
    <url>%2F2016%2F12%2F08%2FBootstrap-VS-jQuery-Mobile-%E5%AF%B9%E6%AF%94%EF%BC%81%2F</url>
    <content type="text"><![CDATA[很多新手纠结这个问题？两个框架都能够支持做手机网页，那么它们的区别是什么呢，适用场景是什么呢？下面我们从这几个方面比较这两个框架：解决问题、功能、适用场景。 解决问题 ###Bootstrap是一个css框架，针对解决的问题有：1.跨设备的网页响应式布局问题。随着手机、平板、各分辨率屏幕的出现，如何能够一套前端在所有设备上自由适应？2.多人合作的前端布局和样式的规范问题3.常用前端css组件，如按钮、连接、表单、表格、分页组件、下拉菜单、导航栏、ICON等等4.常用JS前端组件（需要扩展js支持），如表单验证、Tips、Popup等等 jQuery Mobile是移动前端框架jQuery Mobile是移动前端框架，包含js、html、css，提供一套完整的移动前端开发组件，可以比喻成Android开发框架，尽可能提供移动APP所具有的所有功能，针对解决的问题有：1.移动网页APP所常用的组件，例如：手机导航栏、选项卡、底部菜单、列表、表单等各种组件，而这些与Bootstrap提供的组件有很大区别，jQuery Mobile提供的是类似手机APP的组件，只用于移动网页，而Bootstrap提供的是面向所有设备的组件，并没有对移动设备专门考虑，与移动APP的组件体验不一样。2.网页页面之间转换效果3.异步数据加载 功能 Bootstrap其核心主要是一个css样式框架，基于css 的Media Query功能实现了响应式布局，能够帮助前端开发人员快速布局、快速开发、合作开发。它必须借助jQuery类似的js框架来实现Ajax数据交互。 jQuery Mobile其核心是一个完整的WebAPP框架，加入了一个轻量级的jQuery可以实现Dom操作，在jQuery的基础上提供了一系列类似移动APP的Widget（视图组件），提供了一套不错的页面转场效果，可通过Ajax实现与后端数据交互。 适用场景 Bootstrap通常用于：展示网站的响应式布局开发，使得网站可以在不同设备上方便浏览；以及网站后台管理系统的前端CSS框架。 jQuery Mobile通常用于：期望接近移动APP体验的WebAPP，项目只运行在手机端，不用于电脑设备展示（虽然是可以展示的，但是效果不好）。 总结 如果做跨设备响应式前端，选择Boostrap；如果仅作移动端，期望得到近似APP的WebAPP，使用jQuery Mobile。 如果做一个产品级的WebAPP，当前jQuery Mobile的能力并不能让你满意，自己开发响应式布局框架和WebApp组件是必然要走的路。 最后希望初学者可以掌握这两种框架，还有推荐一个js库，zepto.js,这个框架在开发移动端的时候，很便利，和jQ很像，但又有所不同，但是zepto.js更小，更便捷，zepto.js还提供了手机端的touch的api，真心很棒！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <categories>
        <category>Bootstrap</category>
        <category>jQuery Mobile</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
        <tag>jQuery Mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 CSS3 怎么绘制需要的几何图形]]></title>
    <url>%2F2016%2F08%2F13%2F%E7%94%A8-CSS3-%E6%80%8E%E4%B9%88%E7%BB%98%E5%88%B6%E9%9C%80%E8%A6%81%E7%9A%84%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[圆形思路：给任何正方形元素设置一个足够大的 border-radius ，就可以把它变成一个圆形.代码如下： 12345html:&lt;div class=&quot;size example1&quot;&gt;&lt;/div&gt;css:​​ .size&#123;width:200px; heigh: 200px;background​:#8BC34A;&#125;​.example1&#123;border-radius:100px;&#125; 自适应椭圆1234html:&lt;div class=&quot;example3&quot;&gt;&lt;/div&gt;css:.example3&#123; width:200px; height:150px; border-radius:50%; background:#8BC34A;&#125; 自适应的半椭圆:沿横轴劈开的半椭圆1234html:&lt;div class=&quot;example4&quot;&gt;&lt;/div&gt;css:.example4&#123;width:200px;height:150px; border-radius:50%/100%100%00; background:#8BC34A;&#125; 自适应的半椭圆:沿纵轴劈开的半椭圆1234html:&lt;div class=&quot;example5&quot;&gt;&lt;/div&gt;css：.example5&#123;width:200px; height:150px; border-radius:100%00100%/50%; background:#8BC34A;&#125; 四分之一椭圆1234html:&lt;div class=&quot;example６&quot;&gt;&lt;/div&gt;css：.example6&#123; width:160px; height:100px;border-radius:100% 0 0 0;background:#8BC34A;&#125; 用椭圆绘制opera浏览器的logo（示例借鉴）思路：绘制opera浏览器的logo,分析起来不难，就只有两个图层，一个是最底部的椭圆，一个是最上面那层的椭圆。先确定一下最底层的椭圆宽高，量了一下，水平宽度为258px，垂直高度为275px，因为其是一个对称的椭圆，没有倾斜度，故4个角均为水平半径为258px，垂直半径为275px的4个相等椭圆，用同样的办法确定最里面的椭圆的半径，因此，四个角均为水平半径120px，垂直半径为229px的椭圆，代码如下：12345678910111213141516171819202122232425html:&lt;div class=&quot;opera&quot;&gt; &lt;div ​class=&quot;opera-top&quot;&gt;&lt;/div&gt;&lt;/div&gt;css:.opera&#123; width:258px; height:275px; background:#F22629; border-radius:258px258px258px258px/275px275px275px275px; position:relative;&#125;.opera-top&#123; width:112px; height:231px; background:#FFFFFF; border-radius:112px112px112px112px/231px231px231px231px; position:absolute; left:50%; right:50%; top:50%; bottom:50%; margin-left:-56px; margin-top:-115px;&#125; 如有错误，请大家多多指教！ 访客的ip和所在地址： 访问时间: 当前时间: var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; function sTime(){ var d = new Date(); var s = d.getHours(); var m = d.getMinutes(); var se = d.getSeconds(); if(s]]></content>
      <tags>
        <tag>css3.0</tag>
      </tags>
  </entry>
</search>