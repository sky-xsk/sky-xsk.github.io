<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单聊聊javascript的继承；]]></title>
    <url>%2F2017%2F05%2F09%2F%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8Ajavascript%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9B%2F</url>
    <content type="text"><![CDATA[在JS中继承是一个非常复杂的话题，比其他任何面向对象语言中的继承都复杂得多。在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可。在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，且JS是基于对象来继承的。（这话是比较官方的说法，看着都很专业） ###在说继承之前，首先得先回答一个问题，什么是继承？###我理解的继承，简单来说就是，–1.在原有类的基础上，进行可操作的修改，得到一个崭新的类，这个类有原来类的功能，同时也有自己的功能；–2.这个新的类，不会影响原有类的功能，不会相互干预； 这里肯定有人要问了，什么是‘可操作的修改呢？’说白了就是在不影响整个类的功能的前提下，进行的修改！这点和第二点略有重复，仔细想想，还是有所区别的！！！下面开始说说常用的集中继承方式： ###1.代码：12345678910111213141516171819202122function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;Person.prototype.showName = function() &#123; console.log(this.name);&#125;Person.prototype.showSex = function() &#123; console.log(this.sex);&#125;function work(name, sex, job) &#123; //构造函数伪装调用父级的构造函数——为了继承属性 Person.call(this, name, sex); //Person.apply(this, [name, sex]); //此处的call与apply是有区别的，往下看 this.job = job;&#125;work.prototype = Person.prototype; //通过prototype继承父级的属性work.prototype.showJob = function() &#123; console.log(this.job);&#125;var s = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;);s.showJob() //developer 简单的解释一下上面的代码：首先写了一个很简单的构造函数，在函数的原型上分别添加了showName和showSex的方法；紧接着写了一个work（）函数，这里注意work（）里面的参数，多了一个job参数，这个参数就是要继承的参数， Person.call(this, name, sex);有人问这里的this指的是啥？看下图：答案就是 new出来的work对象！work.prototype = Person.prototype;这句话就是通过prototype继承父级的属性，name和sex；然后就是在work的基础上添加showJob方法；最后就是new一个work对象，执行方法！最后work继承了Person的name和sex属性；是不是很好懂！ ###2.代码：123456789101112131415161718192021222324252627282930313233function Person(name, sex) &#123; this.name = name; this.sex = sex; &#125; Person.prototype.showName = function() &#123; alert(this.name); &#125;; Person.prototype.showSex = function() &#123; alert(this.sex); &#125;; function work(name, sex, job) &#123; Person.call(this, name, sex); this.job = job; &#125; //1.原型链 通过原型来继承父级的方法 //work.prototype=Person.prototype; // 2.原型链 通过原型来继承父级的方法(循环方法) // Person.prototype类型是object； for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; Worker.prototype.showJob = function() &#123; alert(this.job); &#125;; var p = new Person(&apos;xue&apos;, &apos;nan&apos;); var w = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;); // p.showName(); // p.showSex(); // w.showName(); // w.showSex(); // w.showJob(); 简单解释一下：1234``` for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; 这里只是用不同方法，通过原型链来继承父级的方法，原理是一样的！ ###call与apply的区别###js中call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。说简单一点，这两函数的作用其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。如有错误请私信本人！]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0，jsonp的一个小案例 请求百度搜索的接口]]></title>
    <url>%2F2017%2F03%2F10%2Fvue2-0%EF%BC%8Cjsonp%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%A1%88%E4%BE%8B-%E8%AF%B7%E6%B1%82%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[我用的是vue-cli，可以自己去下一个试试看！JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的script 元素是一个例外。利用 script 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。 这里用的”vue-resource”里的示例；下面开始了： #html:123456789101112131415&lt;template&gt; &lt;div class=&quot;bar&quot;&gt; &lt;div id=&quot;box&quot;&gt; &lt;h1&gt;jsonp请求百度接口&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;t1&quot; @keyup=&quot;get($event)&quot; placeholder=&quot;请输入您要搜索的关键词&quot; class=&quot;input_s&quot; @keydown.down=&quot;changeDown()&quot; @keydown.up.prevent=&quot;changeUp()&quot;&gt; &lt;ul class=&quot;ul_se&quot;&gt; &lt;li v-for=&quot;(value,$index) in myData&quot; :class=&quot;&#123;gray:$index==now&#125;&quot; @click=&quot;clickChose($index)&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p v-show=&quot;myData.length==0&quot;&gt;暂无数据...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; #js:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; export default &#123; data() &#123; return &#123; myData:[], t1:&apos;&apos;, now:-1, &#125; &#125;, methods:&#123; get(ev)&#123; //键盘操作 if(ev.keyCode==38 || ev.keyCode==40) return; if(ev.keyCode==13)&#123; window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1); this.t1=&apos;&apos;; &#125; this.$http.jsonp(&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;, //跨域请求接口 &#123; params: &#123; wd:this.t1, &#125;, jsonp:&apos;cb&apos; &#125;).then(function(res)&#123; this.myData = JSON.parse(res.bodyText).s &#125;,function()&#123; console.log(&quot;请求失败！！！&quot;) &#125;); &#125;, changeDown()&#123; //下键选择 this.now++; if(this.now==this.myData.length)this.now=-1; this.t1=this.myData[this.now]; &#125;, changeUp()&#123; //上键选择 this.now--; if(this.now==-2)this.now=this.myData.length-1; this.t1=this.myData[this.now]; &#125;, clickChose($index)&#123; //鼠标选择搜索关键词事件 this.now = $index; this.t1=this.myData[this.now]; window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1); &#125;, &#125;, &#125;&lt;/script&gt; #css:1234567&lt;style scoped&gt;.ul_se&#123; background: #fff; border: 1px solid #ccc; width: 100%;&#125;.ul_se li&#123;list-style: none; height: 30px; line-height: 30px; cursor: pointer;&#125;.input_s&#123;width: 400px; height: 30px; padding-left: 10px;&#125;.gray&#123;background: deepskyblue; color: #fff;&#125;.ul_se li:hover&#123;background: deepskyblue; color: #fff;&#125;&lt;/style&gt; 最终效果：当你在输入框里输入搜索的关键词的时候，就会自动将联想的词汇显示在下方，按一下“enter”键，即可跳转到搜索结果 的页面，同是按“上”，“下”键可以进行选择搜索的关键词，鼠标也可以进行操作选择，跳转！ 以后搜索，直接打开就可以了！ 推荐首音乐]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
</search>