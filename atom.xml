<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>殖民的博客</title>
  <subtitle>Don&#39;t Be Same！Be Better！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sky-xsk.github.io/"/>
  <updated>2017-05-18T16:08:17.000Z</updated>
  <id>http://sky-xsk.github.io/</id>
  
  <author>
    <name>殖民</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js实现一些跨浏览器的兼容事件方法</title>
    <link href="http://sky-xsk.github.io/2017/05/18/js%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
    <id>http://sky-xsk.github.io/2017/05/18/js实现一些跨浏览器的兼容事件方法/</id>
    <published>2017-05-18T15:56:19.000Z</published>
    <updated>2017-05-18T16:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>用JavaScript实现事件的绑定，移除，以及一些常用的事件属性的获取，时常要考虑到在不同浏览器下的兼容性，下面给出了一个跨浏览器的事件对象：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line">    on: function(element, type, handler) &#123;/* 添加事件 */</div><div class="line">        if (element.addEventListener) &#123;</div><div class="line">            element.addEventListener(type, handler, false);</div><div class="line">        &#125; else if (element.attachEvent) &#123;//IE  注意：此时事件处理程序会在全局作用域中运行，因此用attachEvent绑定的事件，此时在事件处理函数里的this 等于window，使用时要注意</div><div class="line"></div><div class="line">            element.attachEvent(&quot;on&quot; + type, handler);</div><div class="line">        &#125; else &#123;</div><div class="line">            element[&quot;on&quot; + type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    off: function(element, type, handler) &#123;/* 移除事件 */</div><div class="line">        if (element.removeEventListener) &#123;</div><div class="line">            element.removeEventListener(type, handler, false);</div><div class="line">        &#125; else if (element.detachEvent) &#123;</div><div class="line">            element.detachEvent(&quot;on&quot; + type, handler);</div><div class="line">        &#125; else &#123;</div><div class="line">            element[&quot;on&quot; + type] = null;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    getEvent: function(event) &#123;/* 返回对event对象的引用 */</div><div class="line">        return event ? event : window.event;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    getTarget: function(event) &#123;/* 返回事件的目标 */</div><div class="line">        return event.target || event.srcElement;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    preventDefault: function(event) &#123; /* 取消事件的默认行为 */</div><div class="line">        if (event.preventDefault) &#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125; else &#123;</div><div class="line">            event.returnValue = false;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    stopPropagation: function(event) &#123;/* 阻止事件冒泡 */</div><div class="line">        if (event.stopPropagation) &#123;</div><div class="line">            event.stopPropagation();</div><div class="line">        &#125; else &#123;</div><div class="line">            event.cancelBubble = true;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    /* mouseover 和mouserout 这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。*/</div><div class="line">    getRelatedTarget: function(event) &#123;</div><div class="line">        if (event.relatedTarget) &#123;</div><div class="line">            return event.relatedTarget;</div><div class="line">        &#125; else if (event.toElement) &#123;//IE8 mouserout事件</div><div class="line">            return event.toElement;</div><div class="line">        &#125; else if (event.fromElement) &#123;//IE8 mouseover事件</div><div class="line">            return event.fromElement;</div><div class="line">        &#125; else &#123;</div><div class="line">            return null;//其他事件</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUtil.on(document, &quot;click&quot;, function(event)&#123;//为document元素绑定click事件</div><div class="line">    event = EventUtil.getEvent(event);//获取event事件对象</div><div class="line">    alert(&quot;Screen coordinates: &quot; + event.screenX + &quot;,&quot; + event.screenY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用JavaScript实现事件的绑定，移除，以及一些常用的事件属性的获取，时常要考虑到在不同浏览器下的兼容性，下面给出了一个跨浏览器的事件对象：&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title> 怎么理解[].forEach.call()？</title>
    <link href="http://sky-xsk.github.io/2017/05/16/%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-forEach-call-%EF%BC%9F/"/>
    <id>http://sky-xsk.github.io/2017/05/16/怎么理解-forEach-call-？/</id>
    <published>2017-05-16T13:35:17.000Z</published>
    <updated>2017-05-18T16:08:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，在网上看到javascript的[].forEach.call()写法，刚看到的时候有点蒙，不是太明白是什么意思！后来到网上查了一下，其实这东西是个简写的写法。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function forEach(elems, callback) &#123;</div><div class="line">  if([].forEach) &#123;</div><div class="line">    [].forEach.call(elems, callback);</div><div class="line">  &#125; else &#123;</div><div class="line">    for(var i = 0; i &lt; elems.length; i++) &#123;</div><div class="line">      callback(elems[i], i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
 <a id="more"></a>
<p> [] 就是个数组，而且是用不到的空数组,用来就是为了访问它的数组相关方法。那完整的写法是什么呢？<br> 其实是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.prototype.forEach.call(...);</div></pre></td></tr></table></figure></p>
<p>很显然，简写更方便。<br>js中的forEach 方法，它可以接受一个函数参数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1,2,3].forEach(function (num) &#123; console.log(num); &#125;);</div></pre></td></tr></table></figure></p>
<p>上面的这句代码中，我们可以访问 this 对象，也就是 [1,2,3] ，可以看出，这个 this 是个数组。</p>
<p>最后， .call 是一个prototype，JavaScript函数内置的。 .call 使用它的第一个参数替换掉上面说的这个 this ，也就是你要传人的数组，其它的参数就跟 forEach 方法的参数一样了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].forEach.call([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], function (item, i, arr) &#123;</div><div class="line">    console.log(i + &quot;: &quot; + item);</div><div class="line">&#125;);</div><div class="line">// 0: &quot;a&quot;</div><div class="line">// 1: &quot;b&quot;</div><div class="line">// 2: &quot;c&quot;</div></pre></td></tr></table></figure></p>
<p>因此， [].forEach.call() 是一种快速的方法访问 forEach ，并将空数组的 this 换成想要遍历的list。</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，在网上看到javascript的[].forEach.call()写法，刚看到的时候有点蒙，不是太明白是什么意思！后来到网上查了一下，其实这东西是个简写的写法。如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function forEach(elems, callback) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  if([].forEach) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [].forEach.call(elems, callback);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for(var i = 0; i &amp;lt; elems.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      callback(elems[i], i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>简单-Vue 2.0渐进式前端解决方案（Vue.js作者尤雨溪）(转载)</title>
    <link href="http://sky-xsk.github.io/2017/05/15/%E7%AE%80%E5%8D%95-Vue-2-0%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88Vue-js%E4%BD%9C%E8%80%85%E5%B0%A4%E9%9B%A8%E6%BA%AA%EF%BC%89-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://sky-xsk.github.io/2017/05/15/简单-Vue-2-0渐进式前端解决方案（Vue-js作者尤雨溪）-转载/</id>
    <published>2017-05-15T15:09:28.000Z</published>
    <updated>2017-05-18T16:07:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>(转载)</code></p>
<p>本人的新博客上线了：<br><a href="https://sky-xsk.github.io/">https://sky-xsk.github.io/</a></p>
<p><strong>主流框架分析</strong><br>我们看一下现有的一些主流框架从少到多所解决的问题。这个多少并不是来评价框架的好坏，而是从设计的角度出发看它涵盖多少内容。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-407dc7f60ed1d67e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br> <a id="more"></a><br>纯模板引擎：最少的就是纯模板引擎，只管状态到界面的映射。</p>
<p>React和Vue：其实这两者都是非常专注的只做状态到界面映射，以及组件。</p>
<p>Backbone：它会给你多一些架构上指导，比如它会让你分层。</p>
<p>Angular：它做的事情就更多，它有自己的路由，这些都会包含在里面。</p>
<p>Ember：相比Angular，Ember做得就更加彻底，Ember信奉的是约定优于配置，它会将一切都帮你设计好打包好，你就开箱用就可以了。</p>
<p>Meteor：Meteor只是一个极端，它是从前到后全都包含，从前端到数据层到数据库，全都帮你打包好。</p>
<p>通过简单的分析，我们可以感受到，做得少的框架不一定就不如做得多的框架，这体现出一种取舍。也就是说，做得少的框架可以给你更多的灵活性，但你需要做更多的选择；做得多的框架有更强的侵入性，学习成本更高，灵活性更低。一旦选择了一个侵入性强的框架，那么一些小的部分你就没有机会去切换成其他你更想用的方案。<br><strong>Vue的定位</strong>与其他框架的区别就是渐进式的想法，也就是“Progressive”——这个词在英文中定义是渐进，一步一步，不是说你必须一竿子把所有的东西都用上。<br><strong>Vue的设计</strong>接下来我们回到之前看的图：<br><img src="http://upload-images.jianshu.io/upload_images/4155235-72b56c882d9e0928.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Vue从设计角度来讲，虽然能够涵盖这张图上所有的东西，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。<br><strong>Vue的实现</strong>接下来深入讲一讲这些具体的概念以及Vue在这些概念上具体是做怎样的实现。<br>(1) 声明式渲染<br>现在基本所有的框架都已经认同这个看法——<strong>DOM应尽可能是一个函数式到状态的映射</strong>状态即是唯一的真相，而Dom状态只是数据状态的一个映射，所有的逻辑应该尽量在状体的层面上去进行，当状态改变的时候，View应该是在框架帮助下自动更新到合理的状态，而不是当观察到数据变化后手动的选择元素再命令式改动它的属性下图是Vue的一个模板示例，如果没有用过Vue的话，可以大概感觉到这是一个怎样的概念<br><img src="http://upload-images.jianshu.io/upload_images/4155235-cbbd5445f7dc238c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">声明式渲染</p>
<p>其实，在模板语法上，Vue跟Angular是比较相似。在Vue1.0里面，模板实现跟Angular类似，如下图所示，把模板直接做成在浏览器里面parse成DOM树，然后去遍历这个树，提取其中的各种绑定。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-b2bd278fee9930b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">aa.png</p>
<p>在Vue2.0中，渲染层的实现做了根本性改动，引入了虚拟DOM<br>从架构上讲，2.0依然写同样的模板，在最左边，Vue2.0跟1.0的模板语法绝大部分是兼容的。Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个虚拟DOM的树。这个树非常轻量，它的职责就是描述当前界面所应处的状态。当我们有了这个虚拟的树之后，再交给一个patch函数，负责把这些虚拟DOM真正施加到真实的DOM上。<br>在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到的数据来源之后，之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新树与旧树进行对比，就可以最终得出应施加到真实DOM上的改动。最后再通过patch函数施加改动。<br><strong>这样做的主要原因是，在浏览器当中，JavaScript的运算在现代的引擎中非常快，但DOM本身是非常缓慢的东西。当你调用原生DOM API的时候，浏览器需要在JavaScript引擎的语境下去接触原生的DOM的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实DOM的操作是最少的。</strong><br>下面看渲染函数。用过React的开发者可能知道，React是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树。JSX实际就是一套用于让我们更简单地去描述树状结构的语法糖如下图所示，在Vue2.0当中，可以看到就是说当比如左侧的模板，经过Vue的编译之后就会变成右侧的东西。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-f5318b26fd379db8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>此函数类似于创建一个虚拟元素的函数，我们可以给它一个名字，给它描述应该有的属性特性和可能其他的数据。然后后面这个最后这个参数是个数组，包含了该虚拟元素的子元素。总的来说2.0的编译器做的就是这个活。<br>同时，在Vue2.0里，<strong>用户可以选择直接跳过模板这一层去手写渲染函数，同时也有可选JSX支持</strong>。从开发者的偏好以及开发者的效益的角度来考量，模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。<br>JSX和直接渲染函数，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。<br>所以在Vue2.0里，两个都是可以选择的。<strong>在绝大部分情况下使用模板，但是在需要复杂逻辑的情况下，使用渲染函数</strong>。在Vue2.0的路由和内部的一些实践上，都大量地应用渲染函数做复杂的抽象组件，比如<strong>过渡动画组件以及路由里面的link组件，都是用渲染函数实现的</strong>，同时还保留了它本身的依赖追踪系统。<br><strong>举例</strong><br>在渲染函数里面用到A.B的时候，这个就会触发对应的 getter。整个渲染流程具体要点如下：<br>当某个数据属性被用到时，触发 getter，这个属性就会被作为依赖被 watcher 记录下来。<br>整个函数被渲染完的时候，每一个被用到的数据属性都会被记录。<br>相应的数据变动时，例如给它一个新的值，就会触发 setter，通知数据对象对应数据有变化。<br>此时会通知对应的组件，其数据依赖有所改动，需要重新渲染。<br>对应的组件再次调动渲染函数，生成 Virtual DOM，实现 DOM 更新。</p>
<p>这样一个流程跟主流的一些框架，例如React是有较大区别的。在React中，当组件复杂的时候需要用 shouldComponentUpdate 做优化。但是，它也有自己的各种坑，比如要确保该组件下面的组件不依赖外部的状态。虽说这在大部分情况下是够用的，但遇到极大复杂度的应用，遇到性能瓶颈的时候，这个流程优化起来也是相当复杂的一个话题。<br>如下图所示，在Vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要手动优化。用Vue渲染这些组件的时候，数据变了，对应的组件基本上去除了手动优化的必要性。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-bab8386ad22743e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">2.png</p>
<p>（2）组件系统<br>相信基本上所有的现代框架都已经走向了组件化道路，Web Components 从规范层面做这个实践。主流框架都有各有不同的封装，但核心思想都是一样，<strong>把UI结构映射到恰当的组件树。</strong><br>在Vue中，<strong>父子组件之间的通信是通过 props 传递。从父向子单向传递；而如果子组件想要在父组件作用里面产生副作用，就需要去派发事件</strong>。这样就形成一个基本的父子通信模式，在涉及大规模状态管理的时候会有额外的方案，这个后面会提到<br>Vue的组件引入构建工具之后有一个单文件组件概念，如下图所示，就是这个Vue文件。在同一个Vue文件里，可以同时写 template、script 和 style，三个东西放在一个里面。<br>同时，<strong>Vue的单文件组件和 Web Components 有一个本质不同，它是基于构建工具实现</strong>。这样的好处是有了一个构建的机会，可以对这些单文件组件做更多的分析处，在每一个语言块里可以单独使用不同的处理器，这点后面还会讲到。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-e637288e2605bd6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">单文件组件</p>
<p>（3）客户端路由<br>在做一个界面复杂度非常的高应用时，它会有很多的状态，这样的应用显然不可能在每做一次操作后都刷新一个页面作为用户反馈。这就要这个应用有多个复杂的状态，同时这些状态还要对应到URL。<br>有一个重要的功能叫做 <strong>deep-linking，也就是当用户浏览到一个URL，然后把它传给另外的人或者复制重新打开，应用需要直接渲染出这个URL对应的状态</strong>。这就意味着应用的URL和组件树的状态之间有一个映射关系，<strong>客户端路由的职责就是让这个映射关系声明式地对应起来</strong>。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-39da1f251705df15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可能同一层的路由有多个不同的出口，还有着复杂的URL匹配规则，等等。这些问题如果都由自己去一一实现，那么复杂度是非常高的。而Vue基本都有对应的解决方案（router.vuejs.org）。配合Webpack还可以实现基于路由的懒加载，<strong>一条路径所对应的组件在打包的时候，会分离成另外一块，只有当该路由被访问的时候，才会被加载出来</strong>。这有相应的解决方案，同时也有实例。<br>（4）状态管理<br>说到状态管理，本质上就是把整个应用抽象为下图中的循环。脸书最早提出 Flux 这个概念的时，也是一个很松散的概念，而且官方的实现本身做得很难用。所以，社区就做了各种各样的探索。<strong>图中的这三个东西是一个单向数据流，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使State产生变化，从而导致 View 重新渲染</strong>。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-ae606217fafa1da3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一个单独的Vue的组件，其实就已经是这样的结构。但是当多个这样的组件来配套的时候，就会遇到一个问题。每个组件都有它自己的状态，但整个应用的状态，跟组件之间并不一定存在一一对应的关系。这个状态可能是一个全局状态。那么状态到底放在哪里？<strong>大部分解决方案是把这个状态从组件树中提取出来，放在一个全局的 Store 里面。Vuex 也是这样做的，但是它是针对 Vue 做了特化</strong><br>我们看到最左边就是Vue的组件，这些组件在大部分情况下，就不再有私有的状态，而是从全局的 Store 里面获取状态。Actions 和 Mutations 比较难用一两句话说清楚，<strong>大致就是当应用状态进行改变的时候，需要通过 Mutations 去显式地触发，而 Actions 则是负责异步和其他副作用</strong>。<br>由于 Mutations 会被记录下来，我们可以把这些记录发到工具里面去做分析，甚至进行回滚。当发现bug的时候，这使得我们可以更好地理解大型应用中的状态变化。更多的细节，还请看官方文档（vuex.vuejs.org）。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-6fa04bd4fa157483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">6.png</p>
<p>（5）构建工具<br>构建工具方面，Vue有一个官方的，<strong>全局安装的 vue-cli。</strong>这里有一个笔误。全局安装之后，我们就可以用 vue 命令创建一个新的项目，<strong>Vue 的 CLI 跟其他 CLI 不同之处在于，有多个可选模板，有简单的也有复杂的。极简的配置，更快的安装，可以更快的上手。</strong><br>它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。所有的模板在创建之后，构建脚本都是通过 npm 脚本来执行，在国内安装 npm 依赖的时候有点卡，可以用 yarn 或者推荐用淘宝的 npm 镜象源，可以很大地提升安装速度。<br>之前提到了单文件组件，如下图所示，支持任意的处理器，开箱即用的热重载，所以组件都支持热重载 (hot-reload)。当你做了修改，不会刷新页面，只是对组件本身进行立刻重载，不会影响整个应用当前的状态。CSS也支持热重载。<br>我们看下左下角，在使用这个预处理器的同时，我们只需要添加一个 scoped 特性，Vue 会通过对模板和CSS代码的解析改写，来模拟CSS的效果。<strong>同时单文件组件也支持懒加载，一个懒加载的组件和它的依赖会被打包成一个额外的包，只有被用到的时候才加载</strong>，这对首屏的加载速度也是很有帮助的。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-1c8dfe606eeeb0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">1.png</p>
<p>如下图所示，这个开发者工具本身也是用Vue写的<br><img src="http://upload-images.jianshu.io/upload_images/4155235-94aa654696b9489b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">2.png</p>
<p>使用它的话可以看到我们当前应用的组件树结构。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-e8042cb7949e252f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">3.png</p>
<p>点击组件，就可以观察这个组件当前的状态。也可以把这个组件发送到控制台里。同时这个开发者工具还有一个 Vuex 面板，如果你用了 Vuex，那么每次操作都会被记录下来，记录下来的状态之间可以进行跳转。<br>除此之外，<strong>还支持把当前应用的状态快照发送给另外一个人，这个人可以在他的控制台里导入你发送的状态，就可以立刻跳转到你之前所在的状态。这对于重现一些 bug，或要描述当前状态都很有帮助</strong>。<br>Vue2.0<br>Vue2.0在不久之前刚刚发布（具体报道参见<a href="http://t.cn/RVC0foZ%EF%BC%89%EF%BC%8C%E4%B9%8B%E5%89%8D%E4%B8%80%E4%BA%9B%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%9C%A8%E5%89%8D%E6%96%87%E4%B8%AD%E5%B7%B2%E6%9C%89%E6%89%80%E6%B6%89%E5%8F%8A%E3%80%82Vue2.0%E7%9B%B8%E5%AF%B9%E4%BA%8E1.0%E7%9A%84%E6%94%B9%E8%BF%9B%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%E3%80%82" target="_blank" rel="external">http://t.cn/RVC0foZ），之前一些技术细节在前文中已有所涉及。Vue2.0相对于1.0的改进有以下几点。</a><br>1、更轻<br>对Vue1.0大小压缩，Vue2.0它有一个只包含运行时的版本，所有的模板在编译的时候已经完成了。基于这个版本，下图中Vue、vue-router和vuex三个（都是 2.0 版本）加一起，跟Vue1.0的核心库大小一样。<br>2、更快<br>Vue2.0可以说是当前最快的框架之一。这个是基于第三方独立测试的结果。有兴趣的话，可以<a href="http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html" target="_blank" rel="external">移步链接</a>进行查看。<br>这个测试是一个比较综合的测试，它对于各种操作，以及在大列表里面更新移除等，都有相当完整的覆盖。可以看出，Vue2.0，不仅仅是在Vue1.0的基础上有很大提升，相比其他框架，也有相当明显的性能优势。<br>3、Vue2.0 架构<br>下图是Vue2.0的架构图，这里不深入讲整个架构的实现。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-95887005d88183f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Vue2.0同时支持服务端，服务端渲染支持流式渲染。因为HTTP请求也是流式，Vue 的服务端渲染结果可以直接 pipe 到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。<br>除了服务端渲染还有原生渲染，这里的原生渲染是指阿里巴巴的项目Weex。在架构层面，通过编译一个 Weex 源文件（类似于 Vue 单文件组建的格式）然后运行。界面节点的操作都是抽象的，这些抽象操作会派发到不同的目标引擎做实际的渲染，同时支持 iOS, Android 和 Web。<br>Vue和Weex现在有一个合作，Vue 2.0 将会正式成为 Weex 的 JavaScript 运行时。这样的合作可以使得符合功能交集的Vue组件可以跨平台使用。<br><code>(转载)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">本人的github，里面有vue2.0的小项目练习，包括仿饿了么的客户端，vue2.0写的，基本功能已经实现，部分bug在修改中;如果觉得有用的话，请给个“star”；</div><div class="line">https://github.com/sky-xsk</div></pre></td></tr></table></figure></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;(转载)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本人的新博客上线了：&lt;br&gt;&lt;a href=&quot;https://sky-xsk.github.io/&quot;&gt;https://sky-xsk.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主流框架分析&lt;/strong&gt;&lt;br&gt;我们看一下现有的一些主流框架从少到多所解决的问题。这个多少并不是来评价框架的好坏，而是从设计的角度出发看它涵盖多少内容。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4155235-407dc7f60ed1d67e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
      <category term="es6" scheme="http://sky-xsk.github.io/tags/es6/"/>
    
      <category term="转载" scheme="http://sky-xsk.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0,自己开发一个全局定义的公用组件（插件）</title>
    <link href="http://sky-xsk.github.io/2017/05/11/vue2-0-%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%AC%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%88%E6%8F%92%E4%BB%B6%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/05/11/vue2-0-自己开发一个全局定义的公用组件（插件）/</id>
    <published>2017-05-11T10:40:11.000Z</published>
    <updated>2017-05-15T14:05:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，在群里看到有朋友问这样一个问题：“我在项目里，怎么能做一个全局调用的组件，不用每一次都import，注册组件？”看到这个问题，我思考了一下，讲一下我的思路！</p>
<p>这个问题里，所说的组件，在我看来也可以叫做“插件”，为什么这么说呢？因为这个和vue-resource之类的插件开发的思路是一样的？只是一个放到的是本地，一个是通过“npm install vue-resource ”下载下来的？换一个思路，如果我把自己开发的组件放到网上，是不是别人可以直接用我开发的插件呢？回答是：“必须的”！<br> <a id="more"></a><br>所以我就来做一个公共的组件：同样的开发环境vue-cli;这个就不说了！！！</p>
<p></p><h1>新建alerts.vue和alerts.js文件</h1><br><b>alerts.vue</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;alerts&quot;&gt;</div><div class="line">      &lt;h2&gt;开发自定义组件//公共组件可直接在任意地方调用&lt;/h2&gt;</div><div class="line">       &lt;button @click=&quot;clicks()&quot;&gt;点击我试一下&lt;/button&gt;  </div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    export default &#123;</div><div class="line">        data() &#123;</div><div class="line">            return &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">     methods:&#123;</div><div class="line">          clicks()&#123;</div><div class="line">              alert(&quot;我是公共的组件！（插件）&quot;)</div><div class="line">          &#125;</div><div class="line">    &#125;,</div><div class="line"> &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p></p>
<p>这个很简单！接下来是重头戏了！<br><b>alerts.js</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const alertsComponent = require(&apos;./alerts.vue&apos;); //引入</div><div class="line">const alerts = &#123;</div><div class="line">    install: function(Vue) &#123;</div><div class="line">        Vue.component(&apos;alerts&apos;, alertsComponent)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">module.exports = alerts;</div></pre></td></tr></table></figure></p>
<p>此处注意文件的路径，不要弄错了；</p>
<p></p><h1>在main.js里引用，和调其他插件的方法一样</h1><br><b>main.js</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import alerts from &apos;./components/alerts/alerts&apos;  //注意路径</div><div class="line">Vue.use(alerts);</div></pre></td></tr></table></figure><p></p>
<p></p><h1>调用方法</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;alerts&gt;&lt;/alerts&gt;</div></pre></td></tr></table></figure><p></p>
<p>在任意组件里调用，均可！</p>
<p><b>我的github，如果有用，不要吝啬，请给个star；在里面可以找到此例子的源码哦！</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/sky-xsk/vue2.0-start-</div></pre></td></tr></table></figure></p>
<p>如有错误，请指正！</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，在群里看到有朋友问这样一个问题：“我在项目里，怎么能做一个全局调用的组件，不用每一次都import，注册组件？”看到这个问题，我思考了一下，讲一下我的思路！&lt;/p&gt;
&lt;p&gt;这个问题里，所说的组件，在我看来也可以叫做“插件”，为什么这么说呢？因为这个和vue-resource之类的插件开发的思路是一样的？只是一个放到的是本地，一个是通过“npm install vue-resource ”下载下来的？换一个思路，如果我把自己开发的组件放到网上，是不是别人可以直接用我开发的插件呢？回答是：“必须的”！&lt;br&gt;
    
    </summary>
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/categories/vue2-0/"/>
    
      <category term="js" scheme="http://sky-xsk.github.io/categories/vue2-0/js/"/>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊javascript的继承</title>
    <link href="http://sky-xsk.github.io/2017/05/09/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8Ajavascript%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9B/"/>
    <id>http://sky-xsk.github.io/2017/05/09/简单聊聊javascript的继承；/</id>
    <published>2017-05-09T15:10:13.000Z</published>
    <updated>2017-05-14T23:31:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在JS中继承是一个非常复杂的话题，比其他任何面向对象语言中的继承都复杂得多。<br>在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可。在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，且JS是基于对象来继承的。（这话是比较官方的说法，看着都很专业）<br> <a id="more"></a></p>
<p></p><h1>在说继承之前，首先得先回答一个问题，什么是继承？</h1><br>我理解的继承，简单来说就是，<br>–1.在原有类的基础上，进行可操作的修改，得到一个崭新的类，这个类有原来类的功能，同时也有自己的功能；<br>–2.这个新的类，不会影响原有类的功能，不会相互干预；<p></p>
<p>这里肯定有人要问了，什么是‘可操作的修改呢？’说白了就是在不影响整个类的功能的前提下，进行的修改！这点和第二点略有重复，仔细想想，还是有所区别的！！！<br>下面开始说说常用的集中继承方式：</p>
<p>###1.代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function Person(name, sex) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.sex = sex;</div><div class="line">&#125;</div><div class="line">Person.prototype.showName = function() &#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line">Person.prototype.showSex = function() &#123;</div><div class="line">    console.log(this.sex);</div><div class="line">&#125;</div><div class="line">function work(name, sex, job) &#123;</div><div class="line">   //构造函数伪装调用父级的构造函数——为了继承属性</div><div class="line">    Person.call(this, name, sex);</div><div class="line">    //Person.apply(this, [name, sex]);  //此处的call与apply是有区别的，往下看</div><div class="line">    this.job = job;</div><div class="line">&#125;</div><div class="line">work.prototype = Person.prototype; //通过prototype继承父级的属性</div><div class="line">work.prototype.showJob = function() &#123;</div><div class="line">    console.log(this.job);</div><div class="line">&#125;</div><div class="line">var s = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;);</div><div class="line">s.showJob()  //developer</div></pre></td></tr></table></figure></p>
<p>简单的解释一下上面的代码：首先写了一个很简单的构造函数，在函数的原型上分别添加了showName和showSex的方法；紧接着写了一个work（）函数，这里注意work（）里面的参数，多了一个job参数，这个参数就是要继承的参数， Person.call(this, name, sex);有人问这里的this指的是啥？看下图：<br><img src="http://upload-images.jianshu.io/upload_images/4155235-9aee6ba236710093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>答案就是 <b>new出来的work对象！</b><br>work.prototype = Person.prototype;这句话就是通过prototype继承父级的属性，name和sex；然后就是在work的基础上添加showJob方法；<br>最后就是new一个work对象，执行方法！最后work继承了Person的name和sex属性；是不是很好懂！</p>
<p>###2.代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function Person(name, sex) &#123;</div><div class="line">           this.name = name;</div><div class="line">           this.sex = sex;</div><div class="line">       &#125;</div><div class="line">       Person.prototype.showName = function() &#123;</div><div class="line">           alert(this.name);</div><div class="line">       &#125;;</div><div class="line">       Person.prototype.showSex = function() &#123;</div><div class="line">           alert(this.sex);</div><div class="line">       &#125;;</div><div class="line">       function work(name, sex, job) &#123;</div><div class="line">           Person.call(this, name, sex);</div><div class="line">           this.job = job;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       //1.原型链 通过原型来继承父级的方法</div><div class="line">       //work.prototype=Person.prototype;</div><div class="line"></div><div class="line">      // 2.原型链 通过原型来继承父级的方法(循环方法)</div><div class="line">      // Person.prototype类型是object；</div><div class="line">       for (var i in Person.prototype) &#123;</div><div class="line">           Worker.prototype[i] = Person.prototype[i];</div><div class="line">       &#125;</div><div class="line">       Worker.prototype.showJob = function() &#123;</div><div class="line">           alert(this.job);</div><div class="line">       &#125;;</div><div class="line">       var p = new Person(&apos;xue&apos;, &apos;nan&apos;);</div><div class="line">       var w = new work(&apos;xue&apos;, &apos;nan&apos;, &apos;developer&apos;);</div><div class="line">       // p.showName();</div><div class="line">       // p.showSex();</div><div class="line">       // w.showName();</div><div class="line">       // w.showSex();</div><div class="line">       // w.showJob();</div></pre></td></tr></table></figure></p>
<p>简单解释一下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"> for (var i in Person.prototype) &#123;</div><div class="line">       Worker.prototype[i] = Person.prototype[i];</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里只是用不同方法，通过原型链来继承父级的方法，原理是一样的！</p>
<p></p><h1>call与apply的区别</h1><br>js中call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。<br>说简单一点，这两函数的作用其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。<br>如有错误请私信本人！<p></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JS中继承是一个非常复杂的话题，比其他任何面向对象语言中的继承都复杂得多。&lt;br&gt;在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可。在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，且JS是基于对象来继承的。（这话是比较官方的说法，看着都很专业）&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://sky-xsk.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>高度复用的弹出框组件的写法  vue2.0</title>
    <link href="http://sky-xsk.github.io/2017/05/09/%E9%AB%98%E5%BA%A6%E5%A4%8D%E7%94%A8%E7%9A%84%E5%BC%B9%E5%87%BA%E6%A1%86%E7%BB%84%E4%BB%B6%E7%9A%84%E5%86%99%E6%B3%95-vue2.0/"/>
    <id>http://sky-xsk.github.io/2017/05/09/高度复用的弹出框组件的写法-vue2.0/</id>
    <published>2017-05-08T17:33:20.000Z</published>
    <updated>2017-05-15T14:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>和以前的文章一样用的vue-cli;具体的 安装步骤这里不做详细的解释了；直接开始了；一定要存在其他的组件<br> <a id="more"></a></p>
<p></p><h1>新建一个alertip.vue组件；组件代码如下</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;tip&quot;&gt;</div><div class="line">        &lt;p&gt;&#123;&#123;alertText&#125;&#125;&lt;/p&gt;</div><div class="line">        &lt;p&gt;&lt;button @click=&quot;closeTip&quot;&gt;关闭&lt;/button&gt;&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    export default &#123;</div><div class="line">        name: &apos;tip&apos;,</div><div class="line">        components: &#123; &#125;,</div><div class="line">        data() &#123;</div><div class="line">            return &#123; &#125;</div><div class="line">        &#125;,</div><div class="line">        props: [&apos;alertText&apos;], //接收传的值</div><div class="line">        methods:&#123;</div><div class="line">             closeTip()&#123;</div><div class="line">                this.$emit(&apos;closeTip&apos;)；//分发事件</div><div class="line">            &#125; </div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</div><div class="line">&lt;!-- 此处的样式只是添加了效果，没有进行准确的排版，这里主要将vue的写法！--&gt;</div><div class="line">&lt;style scoped&gt;</div><div class="line">.tip&#123; width: 400px;height: 200px; overflow: hidden; position: fixed; left:38%;top:20%; background: #fff; border: 1px solid #ccc; padding:20px;&#125; </div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><p></p>
<p></p><h1>在其他组件里调用</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;/template&gt;</div><div class="line">&lt;div&gt;  </div><div class="line">      &lt;alertip v-show=&quot;alertipShow&quot; @closeTip=&quot;alertipShow = false&quot; :alertText=&quot;alertText&quot;&gt;&lt;/alertip&gt; //此处传值，点击事件</div><div class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;alerts()&quot;&gt;点击此按钮，出现浮动窗口&lt;/el-button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">import alertip from &apos;./components/alertip.vue&apos;; //此处注意组件的路径</div><div class="line"> export default &#123;</div><div class="line">        name: &apos;app&apos;,</div><div class="line">        components: &#123;</div><div class="line">            alertip</div><div class="line">        &#125;,</div><div class="line">       data() &#123;</div><div class="line">            return &#123;</div><div class="line">                alertipShow:false,</div><div class="line">                alertText:&apos;&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">         methods: &#123;</div><div class="line">            alerts()&#123;</div><div class="line">                this.alertText=&quot;此处的值为传过去的值，不同的页面用的同一个组件，但是弹出的内容是不同的！,这个信息在app组件里&quot;;</div><div class="line">                this.alertipShow = true;</div><div class="line">            &#125;,  </div><div class="line">     &#125;</div><div class="line">&#125;       </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p></p>
<p>其他页面同样的方法可以调用！展示的效果是一样的，但是不同组件可以传入的值可以是不同的，展示的内容也是不同的，但是效果弹窗是一样的！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">源码见：https://github.com/sky-xsk/vue2.0-start-</div></pre></td></tr></table></figure></p>
<p></p><h1>给加个“star”哦！</h1><p></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script>

</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=28947001&auto=1&height=66"></iframe>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和以前的文章一样用的vue-cli;具体的 安装步骤这里不做详细的解释了；直接开始了；一定要存在其他的组件&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0/Webpack 一个简单的todolist实例</title>
    <link href="http://sky-xsk.github.io/2017/04/17/vue2-0-Webpack-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84todolist%E5%AE%9E%E4%BE%8B/"/>
    <id>http://sky-xsk.github.io/2017/04/17/vue2-0-Webpack-一个简单的todolist实例/</id>
    <published>2017-04-17T15:55:53.000Z</published>
    <updated>2017-05-18T16:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>用的vue-cli,这里就不写过程了，直接上代码吧！同样自己用webpack自己搭一个项目实例！</p>
 <a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">github地址：https://github.com/sky-xsk/vue2.0-start-</div><div class="line">vue2.0写的项目：</div><div class="line">https://github.com/sky-xsk/elem</div><div class="line">如果有帮助，请给个star；</div></pre></td></tr></table></figure>
<p>首先是html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;todo&quot;&gt;</div><div class="line">        &lt;h2&gt;todolist&lt;/h2&gt;</div><div class="line">        &lt;div class=&quot;t_input&quot;&gt;</div><div class="line">            &lt;span&gt;&lt;input type=&quot;text&quot;  class=&quot;t_titles&quot;  placeholder=&quot;请输入。。。&quot; v-model=&quot;text&quot; @keyup.13=&quot;add()&quot;&gt;&lt;/span&gt;</div><div class="line">            &lt;span&gt;&lt;button class=&quot;t_add&quot; @click=&quot;add()&quot;&gt;添加&lt;/button&gt;&lt;/span&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div class=&quot;t-cont&quot;&gt;</div><div class="line">            &lt;ul&gt;</div><div class="line">                &lt;li v-for=&quot;(item,index) in todolist&quot; track-by = &quot;$index&quot;&gt;</div><div class="line">                     &lt;input type=&quot;checkbox&quot; v-model=&quot;item.state&quot; class=&quot;checkbox&quot;/&gt;</div><div class="line">                    &#123;&#123;`$&#123;index+1&#125;. `&#125;&#125;  &#123;&#123;item.value&#125;&#125;</div><div class="line">                    &lt;span @click = &quot;del(index)&quot;&gt;删除&lt;/span&gt;</div><div class="line">                    &lt;span @click = &quot;edit(index)&quot;&gt;编辑&lt;/span&gt;</div><div class="line">                &lt;/li&gt;</div><div class="line">                &lt;div class=&quot;check_che&quot; @click=&quot;remove()&quot; v-show=&quot;select.length &gt; 0&quot; &gt;删除选中&lt;/div&gt;</div><div class="line">                &lt;p v-show=&quot;todolist.length == 0&quot;&gt;暂无数据！&lt;/p&gt;</div><div class="line"></div><div class="line">            &lt;/ul&gt;</div><div class="line">        &lt;/div&gt;    </div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p>
<p>js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">    export default &#123;</div><div class="line">        name: &apos;todo&apos;,</div><div class="line">        data() &#123;</div><div class="line">            return &#123;</div><div class="line">                todolist:[], </div><div class="line">                text:&apos;&apos;,</div><div class="line">                state: false,</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        methods:&#123;</div><div class="line">            //添加</div><div class="line">            add()&#123;</div><div class="line">                if(this.text == &apos;&apos;)&#123;</div><div class="line">                    return </div><div class="line">                &#125;else&#123;</div><div class="line">                    this.todolist.push (&#123;</div><div class="line">                    value:this.text,</div><div class="line">                    state: false,</div><div class="line">                &#125;)</div><div class="line">             &#125;  </div><div class="line">                this.text=&apos;&apos;;</div><div class="line">            &#125;,</div><div class="line">            //删除</div><div class="line">            del(index)&#123;</div><div class="line">                this.todolist.splice(index,1);</div><div class="line">            &#125;,</div><div class="line">            //删除选中</div><div class="line">            remove()&#123;</div><div class="line">                this.todolist = this.todolist.filter((index) =&gt; !index.state)</div><div class="line">            &#125;,</div><div class="line">            //编辑</div><div class="line">            edit(index)&#123;</div><div class="line">                this.text = this.todolist[index].value;</div><div class="line">                this.todolist.splice(index,1);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        //计算属性</div><div class="line">         computed: &#123;</div><div class="line">            select() &#123;</div><div class="line">                return this.todolist.filter((index) =&gt; index.state == true)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>css<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</div><div class="line">&lt;style scoped&gt;</div><div class="line">.t_titles&#123; width: 400px; height: 35px; font-size: 16px; padding-left: 10px;&#125;</div><div class="line">.t_add&#123; width: 60px; height:40px; font-size: 16px; vertical-align: middle;&#125;</div><div class="line">.t-cont&#123; width:100%; margin-top: 20px; margin: 0 auto;&#125;</div><div class="line">.t-cont ul li&#123;list-style: none; height: 30px; border: 1px solid #ccc; line-height: 30px; text-align: left; padding-left: 10px;&#125;</div><div class="line">.t-cont ul li span&#123;float: right; cursor: pointer; padding-right: 10px;&#125;</div><div class="line">.t-cont ul li input&#123;padding-top: 5px;&#125;</div><div class="line">.checks&#123; width: 15px; height: 15px; border-radius:50%; border: 1px solid #ccc; display: inline-block;margin-top: 5px; cursor: pointer; &#125;</div><div class="line">.checkbox &#123; width: 18px; height: 18px;border: 1px solid #ccc; border-radius: 100%; position: relative; margin-right: 6px; vertical-align: middle;  &#125;</div><div class="line">.checkbox:checked &#123;border-color: deepskyblue;&#125;</div><div class="line">.checkbox:checked:before &#123; content: &apos;&apos;; display: block; width: 80%; height: 80%; position: absolute; left: 50%; top: 50%;transform: translate(-50%, -50%); background: deepskyblue; border-radius: 100%;&#125;</div><div class="line">.check_che&#123;border: 1px solid #ccc; padding:10px;&#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>效果如截图：<br><img src="http://upload-images.jianshu.io/upload_images/4155235-561bedd249824704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用的vue-cli,这里就不写过程了，直接上代码吧！同样自己用webpack自己搭一个项目实例！&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
      <category term="webpack" scheme="http://sky-xsk.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>用sourceTree，将自己的代码上传到github上去</title>
    <link href="http://sky-xsk.github.io/2017/04/15/%E7%94%A8sourceTree%EF%BC%8C%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0github%E4%B8%8A%E5%8E%BB/"/>
    <id>http://sky-xsk.github.io/2017/04/15/用sourceTree，将自己的代码上传到github上去/</id>
    <published>2017-04-15T15:00:42.000Z</published>
    <updated>2017-05-14T23:31:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 是一个面向开源及私有<a href="http://baike.baidu.com/subview/37/6030295.htm" target="_blank" rel="external">软件</a>项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。<br>GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。<br> <a id="more"></a><br>sourceTree是一个工具；接下来我就教大家怎么把自己的代码传到github上面去；</p>
<h1>首先你注册一个sourceTree的账号和github的账号，我这边就不写怎么去注册了</h1><br><h1>注册好账号后，在github上点击如图；</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/4155235-69efecbbd6fd7f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1>点击后，会弹出如下页面；</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/4155235-c840254ac8f8bc38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>输入项目名称后，点击绿色按钮，即可；</p>
<h1>打开新建的项目，点击绿色按钮，将地址复制下来</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/4155235-8314bc364f2e533d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1>在本地新建一个文件夹，作为本地的仓库，</h1><br><h1>接下来，打开sourceTree客户端，单击新建/克隆如图；</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/4155235-a0558159406961d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>源路径填写刚才复制的地址，目标路径就会刚才新建的文件夹的路径；填好后，点击确定即可，这样你的仓库就克隆到本地了；</p>
<h1>克隆到本地的仓库有个.git文件千万不要删掉；然后自己的代码复制到本地的仓库中去，</h1><br><h1>然后点击Stage All后单击提交</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/4155235-52ec5b3216216497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1>接下来点击‘推送’</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/4155235-35cd59b562c0d45f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4155235-2de6e13e90410cbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p></p><h1>到github上面看一下，代码推送成功！</h1><p></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub 是一个面向开源及私有&lt;a href=&quot;http://baike.baidu.com/subview/37/6030295.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;软件&lt;/a&gt;项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。&lt;br&gt;GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。&lt;br&gt;
    
    </summary>
    
    
      <category term="sourceTree" scheme="http://sky-xsk.github.io/tags/sourceTree/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0，jsonp的一个小案例 请求百度搜索的接口</title>
    <link href="http://sky-xsk.github.io/2017/03/10/vue2-0%EF%BC%8Cjsonp%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%A1%88%E4%BE%8B-%E8%AF%B7%E6%B1%82%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <id>http://sky-xsk.github.io/2017/03/10/vue2-0，jsonp的一个小案例-请求百度搜索的接口/</id>
    <published>2017-03-09T16:12:23.000Z</published>
    <updated>2017-05-14T23:31:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/timg.png" alt="“JSONP原理图”"><br>我用的是vue-cli，可以自己去下一个试试看！<br>JSONP(JSON with Padding)是<a href="http://baike.baidu.com/view/136475.htm" target="_blank" rel="external">JSON</a>的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的script 元素是一个例外。利用 script 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。<br> <a id="more"></a><br>这里用的”vue-resource”里的示例；<br>下面开始了：</p>
<p>#html:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;bar&quot;&gt;</div><div class="line">      &lt;div id=&quot;box&quot;&gt;</div><div class="line">        &lt;h1&gt;jsonp请求百度接口&lt;/h1&gt;</div><div class="line">        &lt;input type=&quot;text&quot; v-model=&quot;t1&quot; @keyup=&quot;get($event)&quot; placeholder=&quot;请输入您要搜索的关键词&quot; class=&quot;input_s&quot;  @keydown.down=&quot;changeDown()&quot; @keydown.up.prevent=&quot;changeUp()&quot;&gt;</div><div class="line">        &lt;ul class=&quot;ul_se&quot;&gt;</div><div class="line">            &lt;li v-for=&quot;(value,$index) in myData&quot; :class=&quot;&#123;gray:$index==now&#125;&quot; @click=&quot;clickChose($index)&quot;&gt;</div><div class="line">                &#123;&#123;value&#125;&#125;</div><div class="line">            &lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">        &lt;p v-show=&quot;myData.length==0&quot;&gt;暂无数据...&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line"></div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p>
<p>#js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    export default &#123;</div><div class="line">        data() &#123;</div><div class="line">            return &#123;</div><div class="line">                myData:[],</div><div class="line">                    t1:&apos;&apos;,</div><div class="line">                    now:-1,</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">         methods:&#123;</div><div class="line">             get(ev)&#123; //键盘操作</div><div class="line">                  if(ev.keyCode==38 || ev.keyCode==40)</div><div class="line">                        return;</div><div class="line">                 if(ev.keyCode==13)&#123;</div><div class="line">                       window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1);</div><div class="line">                       this.t1=&apos;&apos;;</div><div class="line">                &#125;</div><div class="line">                this.$http.jsonp(&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;, //跨域请求接口</div><div class="line">                    &#123;</div><div class="line">                    params: &#123;</div><div class="line">                        wd:this.t1,</div><div class="line">                    &#125;,</div><div class="line">                    jsonp:&apos;cb&apos;</div><div class="line">                &#125;).then(function(res)&#123;</div><div class="line">                    this.myData = JSON.parse(res.bodyText).s</div><div class="line">                &#125;,function()&#123;</div><div class="line">                    console.log(&quot;请求失败！！！&quot;)</div><div class="line">                &#125;);</div><div class="line">              &#125;,</div><div class="line"></div><div class="line">             changeDown()&#123; //下键选择</div><div class="line">                this.now++;</div><div class="line">                if(this.now==this.myData.length)this.now=-1;</div><div class="line">                this.t1=this.myData[this.now];</div><div class="line">            &#125;,</div><div class="line"></div><div class="line">            changeUp()&#123; //上键选择</div><div class="line">                this.now--;</div><div class="line">                if(this.now==-2)this.now=this.myData.length-1;</div><div class="line">                this.t1=this.myData[this.now];</div><div class="line">            &#125;,</div><div class="line">             clickChose($index)&#123;  //鼠标选择搜索关键词事件</div><div class="line">                this.now = $index;</div><div class="line">                this.t1=this.myData[this.now];</div><div class="line">                window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.t1);</div><div class="line">            &#125;,</div><div class="line"></div><div class="line">       &#125;,</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>#css:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;style scoped&gt;</div><div class="line">.ul_se&#123; background: #fff; border: 1px solid #ccc; width: 100%;&#125;</div><div class="line">.ul_se li&#123;list-style: none; height: 30px; line-height: 30px; cursor: pointer;&#125;</div><div class="line">.input_s&#123;width: 400px; height: 30px; padding-left: 10px;&#125;</div><div class="line">.gray&#123;background: deepskyblue; color: #fff;&#125;</div><div class="line">.ul_se li:hover&#123;background: deepskyblue; color: #fff;&#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>最终效果：当你在输入框里输入搜索的关键词的时候，就会自动将联想的词汇显示在下方，按一下“enter”键，即可跳转到搜索结果 的页面，同是按“上”，“下”键可以进行选择搜索的关键词，鼠标也可以进行操作选择，跳转！<br><img src="http://upload-images.jianshu.io/upload_images/4155235-3eccbc030e74c61b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>以后搜索，直接打开就可以了！</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/timg.png&quot; alt=&quot;“JSONP原理图”&quot;&gt;&lt;br&gt;我用的是vue-cli，可以自己去下一个试试看！&lt;br&gt;JSONP(JSON with Padding)是&lt;a href=&quot;http://baike.baidu.com/view/136475.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSON&lt;/a&gt;的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的script 元素是一个例外。利用 script 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://sky-xsk.github.io/categories/js/"/>
    
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>关于es6的部分语法介绍</title>
    <link href="http://sky-xsk.github.io/2017/03/02/%E5%85%B3%E4%BA%8Ees6%E7%9A%84%E9%83%A8%E5%88%86%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://sky-xsk.github.io/2017/03/02/关于es6的部分语法介绍/</id>
    <published>2017-03-02T10:15:18.000Z</published>
    <updated>2017-05-15T14:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>#es6的介绍<br>ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准,组件分为：ECMA/DOM/BOM<br>ECMAscript简写是ECMA或者叫ES；<br> <a id="more"></a></p>
<p>#在线编译e6转换es5<br>如果不是太熟悉的话，可以用用这个转换的小工具，对比一下es6语法的差别；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;code=%20const%20A%20%3D%20&apos;static%20A&apos;%3B%0D%0A%09%20%20%20%09%20console.log(A)%3B%0D%0A%09%20%20%20%09%20let%20b%20%3D&apos;b&apos;%3B%0D%0A%09%20%20%20%09%20console.log(b)%3B%0D%0A%0D%0A%09%20%20%20%09%20alert(A)</div></pre></td></tr></table></figure></p>
<p>#变量let<br>1.let的使用范围有限，只能在代码里面使用，在代码外面的还就会弹出未定义,不能重复声明，也就是用同一个变量不能用两次<br>2.如果是var的话，只有在函数里才有作用域</p>
<p>###eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#html:</div><div class="line">&lt;ul&gt;</div><div class="line">     &lt;li&gt;test&lt;/li&gt;</div><div class="line">     &lt;li&gt;test&lt;/li&gt;</div><div class="line">     &lt;li&gt;test&lt;/li&gt;</div><div class="line">     &lt;li&gt;test&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">#js:</div><div class="line">window.onload = function()&#123;</div><div class="line">           var ali = document.getElementsByTagName(&apos;li&apos;);</div><div class="line">           for(let i = 0;i&lt;ali.length;i++)&#123;</div><div class="line">                ali[i].onclick = function()&#123;</div><div class="line">                   alert(i)</div><div class="line">                 &#125;</div><div class="line">           &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>#const<br>const的用法比较好理解，它一旦被赋值的话就不能被修改，常量必须在声明的同时赋值，否则会报错，而且通常常量用大写字母规范；和es5一样的一点是，不能重复的去声明，否则是会有问题的；</p>
<p>###eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const TEST1 = 0;</div><div class="line">const TEST2 = 1;</div></pre></td></tr></table></figure></p>
<p>#字符串的连接<br>在es6中，字符串的连接变得更简单了，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">###eg：</div></pre></td></tr></table></figure></p>
<p>var a = “我是字符串1”;<br>var b = “我是字符串2”;<br>var c = <code>把他们连起来$(a)把他们连起来$(b)</code>;<br>console.log(c);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#给变量赋值</div><div class="line">现在的赋值更简单，更灵活，同时也减少的不少的代码量；</div><div class="line">###eg:</div></pre></td></tr></table></figure></p>
<p>var [a,b,c] = [1,2,3];<br>打印一个：console.log(a);<br>打印多个：console.log(a,b,c);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对，就是这个样！</div></pre></td></tr></table></figure></p>
<p>var { a, c ,b } = { a:1, b:2 , c:3 }<br>打印一个：console.log(a);<br>打印多个：console.log(a,b,c);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">var [a,[b,c],d] = [1,[2,3],4];</div><div class="line">console.log(a,b,c,d);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var [&#123;a,e&#125;&#125;,[b,c],d] = [&#123;e:&apos;eeee&apos;,a:&apos;aaaaa&apos;&#125;,[1,2],5] //这个有点变化，注意了</div><div class="line">console.log(a,b,c,d)</div></pre></td></tr></table></figure>
<p>自己会一一对应的，不会因为顺序不同导致值的变化！</p>
<p>#数组<br>数组的操作基本相同，这里介绍一个‘from’方法；‘复制数组’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">var arr2 = Array.from(arr);</div><div class="line">arr2.pop();</div><div class="line">console.log(arr,arr2);</div><div class="line">Array.from(arr);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">var arr2 = [...arr];</div><div class="line">arr2.pop();</div><div class="line">console.log(arr,arr2);</div></pre></td></tr></table></figure>
<p>这两种方法是相同的；</p>
<p>#遍历<br>es6用的是for…of..;有点变化！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,2,2,2,2,2,3,4];</div><div class="line">   for(var i of arr)&#123;</div><div class="line">     console.log(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是:可以循环数组，但是不能循环json，他主要是循环map对象用的;</p>
<p>#map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&apos;a&apos;,&apos;apple&apos;);</div><div class="line">map.set(&apos;b&apos;,&apos;banbana&apos;);</div><div class="line">alert(map.get(&apos;b&apos;));  //获取</div><div class="line">map.delete(‘a’);      //删除</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&apos;a&apos;,&apos;apple&apos;);</div><div class="line">      map.set(&apos;b&apos;,&apos;banbana&apos;);</div><div class="line">      map.set(&apos;c&apos;,&apos;orange&apos;);</div><div class="line">      map.set(&apos;d&apos;,&apos;pear&apos;);</div><div class="line">      for( var [key,value] of map)&#123; //循环了一下</div><div class="line">          console.log(value);</div><div class="line">      &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;q&apos;,&apos;w&apos;,&apos;e&apos;,&apos;a&apos;,&apos;d&apos;,&apos;f&apos;,&apos;r&apos;]   //一套带走，lol</div><div class="line">      //entries循环key和value</div><div class="line">      for(var name of arr.keys())&#123;</div><div class="line">          console.log(name)</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>#箭头函数（经常会遇到的，刚开始会很懵逼）<br>这里做个对比，就一目了然了；</p>
<p>###es6 eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#html</div><div class="line">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">#css</div><div class="line">#box&#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px; </div><div class="line">    border:1px solid #000;  </div><div class="line">&#125;</div><div class="line">#js</div><div class="line">window.onload = function()&#123;</div><div class="line">          var oBox = document.getElementById(&apos;box&apos;);</div><div class="line">          oBox.onclick = () =&gt;&#123;</div><div class="line">              oBox.style.background = &apos;red&apos;；</div><div class="line">          &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###es5 eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#html</div><div class="line">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">#css</div><div class="line">#box&#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px; </div><div class="line">    border:1px solid #000;  </div><div class="line">&#125;</div><div class="line">#js</div><div class="line">window.onload = function()&#123;</div><div class="line">          var oBox = document.getElementById(&apos;box&apos;);</div><div class="line">          oBox.onclick=function()&#123;</div><div class="line">              oBox.style.background = &apos;red&apos;；</div><div class="line">           &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#面向对象<br>这个写法，感觉和java里的类有点像；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">          constructor(name,age)&#123;</div><div class="line">              this.name = name</div><div class="line">              this.age = age</div><div class="line">          &#125;</div><div class="line">          showName()&#123;</div><div class="line">              return this.name;</div><div class="line">          &#125;</div><div class="line">          showAge()&#123;</div><div class="line">              return this.age;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      var p1 = new Person(&apos;aaa&apos;,10);</div><div class="line">      alert(p1.showName());</div></pre></td></tr></table></figure></p>
<p>小提示：在es6的语法当中，私有作用域的代码块：<code>{ }</code> 包起来的就是代码块，就形成了一个作用域，称为块级作用域,这个的话和es5就有很大差别；</p>
<p>~~~后期会继续更新的;</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#es6的介绍&lt;br&gt;ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准,组件分为：ECMA/DOM/BOM&lt;br&gt;ECMAscript简写是ECMA或者叫ES；&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
      <category term="es6" scheme="http://sky-xsk.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>来来来，通俗的理解一下原型，原型链......</title>
    <link href="http://sky-xsk.github.io/2016/12/26/%E6%9D%A5%E6%9D%A5%E6%9D%A5%EF%BC%8C%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://sky-xsk.github.io/2016/12/26/来来来，通俗的理解一下原型，原型链/</id>
    <published>2016-12-26T15:24:23.000Z</published>
    <updated>2017-05-15T17:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，在网上看到这个讲原型和原型链的通俗的分析，感觉对理解还是有帮助的，特此分享：<br> <a id="more"></a><br>原型链理解起来有点绕了，网上资料也是很多，每次晚上睡不着的时候总喜欢在网上找点原型链和闭包的文章看，效果极好。不要纠结于那一堆术语了，那除了让你脑筋拧成麻花，真的不能帮你什么。简单粗暴点看原型链吧，想点与代码无关的事，比如人、妖以及人妖。</p>
<p>1）人是人他妈生的，妖是妖他妈生的。人和妖都是对象实例，而人他妈和妖他妈就是原型。原型也是对象，叫原型对象。</p>
<p>2）人他妈和人他爸啪啪啪能生出一堆人宝宝、妖他妈和妖他爸啪啪啪能生出一堆妖宝宝，啪啪啪就是构造函数，俗称造人。</p>
<p>3）人他妈会记录啪啪啪的信息，所以可以通过人他妈找到啪啪啪的信息，也就是说能通过原型对象找到构造函数。</p>
<p>4）人他妈可以生很多宝宝，但这些宝宝只有一个妈妈，这就是原型的唯一性。</p>
<p>5）人他妈也是由人他妈他妈生的，通过人他妈找到人他妈他妈，再通过人他妈他妈找到人他妈他妈……，这个关系叫做原型链。</p>
<p>6）原型链并不是无限的，当你通过人他妈一直往上找，最后发现你会发现人他妈他妈他妈……的他妈都不是人，也就是原型链最终指向null。</p>
<p>7）人他妈生的人会有人的样子，妖他妈生的妖会有妖的丑陋，这叫继承。</p>
<p>8）你继承了你妈的肤色，你妈继承了你妈他妈的肤色，你妈他妈……，这就是原型链的继承。</p>
<p>9）你谈对象了，她妈让你带上房产证去提货，你若没有，那她妈会问你妈有没有，你妈没有那她妈会问你妈她妈有没有……这就是原型链的向上搜索。</p>
<p>10）你会继承你妈的样子，但是你也可以去染发洗剪吹，就是说对象的属性可以自定义，会覆盖继承得到的属性。</p>
<p>11）虽然你洗剪吹了染成黄毛了，但你不能改变你妈的样子，你妈生的弟弟妹妹跟你的黄毛洗剪吹没一点关系，就是说对象实例不能改动原型的属性。</p>
<p>12）但是你家被你玩火烧了的话，那就是说你家你妈家你弟们家都被烧了，这就是原型属性的共享。</p>
<p>13）你妈外号阿珍，邻居大娘都叫你阿珍儿，但你妈头发从飘柔做成了金毛狮王后，隔壁大婶都改口叫你包租仔，这叫原型的动态性。</p>
<p>14）你妈爱美，又跑到韩国整形，整到你妈他妈都认不出来，即使你妈头发换回飘柔了，但隔壁邻居还是叫你金毛狮王子。因为没人认出你妈，整形后的你妈已经回炉再造了，这就是原型的整体重写。(转载！)</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，在网上看到这个讲原型和原型链的通俗的分析，感觉对理解还是有帮助的，特此分享：&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
      <category term="转载" scheme="http://sky-xsk.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>js如何判断一个对象是不是Array？</title>
    <link href="http://sky-xsk.github.io/2016/12/26/js%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AFArray%EF%BC%9F/"/>
    <id>http://sky-xsk.github.io/2016/12/26/js如何判断一个对象是不是Array？/</id>
    <published>2016-12-26T14:57:03.000Z</published>
    <updated>2017-05-14T23:31:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>当听到这个问题的时候，肯定有人第一个想法就是用“typeof”来判断，实则，并不能实现；很忧伤！<br>下面咱先来说一说“typeof”，在js中，对于Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任​，大家都懂的！<br> <a id="more"></a></p>
<p></p><h1>typeof</h1>​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);​​</div><div class="line">alert(typeof(arr));</div></pre></td></tr></table></figure><p></p>
<p>你会收到一个object ；什么破玩意；是不是这个时候想把键盘摔了，摔了没关系，再买吧！往下看：</p>
<p></p><h1>instanceof</h1><br>咱不能一条道走到黑，咱们得找其他的路子啊，对不对？<br>JavaScript中instanceof运算符会返回一个 Boolean 类型的值，指出对象是否是特定类的一个实例。<br> 使用方法：<strong>result = object instanceof class</strong>,还是刚刚的数组，成功的返回 true。​请看下面，看实际代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arrayStr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);</div><div class="line">alert(arrayStr instanceof Array);</div></pre></td></tr></table></figure><p></p>
<p>啊，成功了！高兴吧！这样真的可以了吗？是吗？<br>其实​instanceof还是有一定的局限性的，一想到这，不是验证正确了吗？没毛病啊！<br>事实上在多个frame中穿梭就会产生大问题了​？？？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var iframe = document.createElement_x(&apos;iframe&apos;);   </div><div class="line">document.body.appendChild(iframe);   </div><div class="line">xArray = window.frames[window.frames.length-1].Array;      </div><div class="line">var arr = new xArray(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);//这个写法老古董IE下是不支持的，FF下才有;</div><div class="line">alert(arr instanceof Array); // false</div><div class="line">alert(arr.constructor === Array); // false</div></pre></td></tr></table></figure></p>
<p>返回结果为两个False，让人大失所望。为毛？</p>
<p></p><h1>​Object.prototype.toString( )</h1> <p></p>
<blockquote>
<p>ECMA-262 写道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object.prototype.toString( ) When the toString method is called, the following steps are taken:</div><div class="line">Get the [[Class]] property of this object.</div><div class="line">Compute a string value by concatenating the three strings “[object “, Result (1), and “]”.</div><div class="line">Return Result (2)</div></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的规范定义了Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。还是先来看看在ECMA标准中Array的描述吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Array([ item0[, item1 [,…]]])</div><div class="line">The [[Class]] property of the newly constructed object is set to “Array”.</div></pre></td></tr></table></figure></p>
<p>于是利用这点，第三种方法登场了。<br>call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是’[object Array]’，以判断其是否是Array的实例。也许你要问了，为什么不直接o.toString()？嗯，虽然Array继承自Object，也会有toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：）</p>
<p>与前面几个方案不同，这个方法很好的解决了跨frame对象构建的问题，经过测试，各大浏览器兼容性也很好，可以放心使用。一个好消息是，很多框架，比如jQuery、Base2等等，都计划借鉴此方法以实现某些特殊的，比如数组、正则表达式等对象的类型判定，不用我们自己写了。<br>另外Ext3 也已经换成这样的写法了;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">isArray : function (v)&#123;         </div><div class="line">return toString.apply(v) === &apos;[object Array]&apos;;&#125;</div></pre></td></tr></table></figure></p>
<p></p><h1>4.JQ中$isArray();</h1><br>话不多说，直接上代码吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(document).ready(function()&#123;</div><div class="line">        var Arr = [&quot;4&quot;,&quot;8&quot;,&quot;1&quot;,&quot;3&quot;];</div><div class="line">        alert($.isArray(Arr));​</div><div class="line">&#125;)​</div></pre></td></tr></table></figure><p></p>
<p>返回的值为​Boolean 类型的值，是数组则返回一个“true”，反之“false”<br>成了！​<br>行就到这吧！希望大家多多支持！</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当听到这个问题的时候，肯定有人第一个想法就是用“typeof”来判断，实则，并不能实现；很忧伤！&lt;br&gt;下面咱先来说一说“typeof”，在js中，对于Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任​，大家都懂的！&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://sky-xsk.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>浅谈，实例mttq；</title>
    <link href="http://sky-xsk.github.io/2016/12/20/%E6%B5%85%E8%B0%88%EF%BC%8C%E5%AE%9E%E4%BE%8Bmttq%EF%BC%9B/"/>
    <id>http://sky-xsk.github.io/2016/12/20/浅谈，实例mttq；/</id>
    <published>2016-12-20T12:24:23.000Z</published>
    <updated>2017-05-16T10:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>MQTT - MQ Telemetry Transport<br>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。​<br> <a id="more"></a><br>早在1999年，IBM的Andy Stanford-Clark博士以及Arcom公司ArlenNipper博士发明了MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）技术[1] 。据Andy Stanford-Clark博士称，MQTT将在今年和明年呈现爆炸式增长。<br>MQTT的话题是我俩谈论开源物联网平台Pachube时提到的。Stanford-Clark认为Pachube很酷，其不足之处是不具备真正的推送功能。你需要不断轮询才能得到即时数据。这正是MQTT能够实现的，他提到了使用推送通信系统的石油管道检测系统。<br>轻量级的 machine-to-machine 通信协议。<br>publish/subscribe模式。<br>基于TCP/IP。<br>支持QoS。<br>适合于低带宽、不可靠连接、嵌入式设备、CPU内存资源紧张。<br>是一种比较不错的Android消息推送方案。<br>FacebookMessenger采用了MQTT。<br>MQTT有可能成为物联网的重要协议。</p>
<p>下面一个实例，直接看代码：我放到云盘了，可以下载！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://pan.baidu.com/s/1skZADJZ</div></pre></td></tr></table></figure></p>
<p>例子有问题的话可以私信我！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这里说一下例子的使用方法：</div><div class="line">1.先去config去配置服务器的地址，前提是在服务器上已经配置好了MQTT协议，</div><div class="line">2.配置好后，将index.html在浏览器中打开，打开两份，这样你在一个页面发送信息，另一个页面就可以收到了！</div></pre></td></tr></table></figure></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MQTT - MQ Telemetry Transport&lt;br&gt;MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。​&lt;br&gt;
    
    </summary>
    
    
      <category term="mttq" scheme="http://sky-xsk.github.io/tags/mttq/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap VS jQuery Mobile 对比！</title>
    <link href="http://sky-xsk.github.io/2016/12/08/Bootstrap-VS-jQuery-Mobile-%E5%AF%B9%E6%AF%94%EF%BC%81/"/>
    <id>http://sky-xsk.github.io/2016/12/08/Bootstrap-VS-jQuery-Mobile-对比！/</id>
    <published>2016-12-08T15:30:20.000Z</published>
    <updated>2017-05-15T14:23:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4155235-c39527f8937b08f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>很多新手纠结这个问题？两个框架都能够支持做手机网页，那么它们的区别是什么呢，适用场景是什么呢？下面我们从这几个方面比较这两个框架：解决问题、功能、适用场景。<br> <a id="more"></a></p>
<p></p><h1>解决问题</h1><p></p>
<p>###Bootstrap是一个css框架，针对解决的问题有：<br>1.跨设备的网页响应式布局问题。随着手机、平板、各分辨率屏幕的出现，如何能够一套前端在所有设备上自由适应？<br>2.多人合作的前端布局和样式的规范问题<br>3.常用前端css组件，如按钮、连接、表单、表格、分页组件、下拉菜单、导航栏、ICON等等<br>4.常用JS前端组件（需要扩展js支持），如表单验证、Tips、Popup等等</p>
<p></p><h1>jQuery Mobile是移动前端框架</h1><br>jQuery Mobile是移动前端框架，包含js、html、css，提供一套完整的移动前端开发组件，可以比喻成Android开发框架，尽可能提供移动APP所具有的所有功能，针对解决的问题有：<br>1.移动网页APP所常用的组件，例如：手机导航栏、选项卡、底部菜单、列表、表单等各种组件，而这些与Bootstrap提供的组件有很大区别，jQuery Mobile提供的是类似手机APP的组件，只用于移动网页，而Bootstrap提供的是面向所有设备的组件，并没有对移动设备专门考虑，与移动APP的组件体验不一样。<br>2.网页页面之间转换效果<br>3.异步数据加载<p></p>
<p></p><h1>功能</h1><br>　Bootstrap其核心主要是一个css样式框架，基于css 的Media Query功能实现了响应式布局，能够帮助前端开发人员快速布局、快速开发、合作开发。它必须借助jQuery类似的js框架来实现Ajax数据交互。<br>　　jQuery Mobile其核心是一个完整的WebAPP框架，加入了一个轻量级的jQuery可以实现Dom操作，在jQuery的基础上提供了一系列类似移动APP的Widget（视图组件），提供了一套不错的页面转场效果，可通过Ajax实现与后端数据交互。<p></p>
<p></p><h1>适用场景</h1><br>　Bootstrap通常用于：展示网站的响应式布局开发，使得网站可以在不同设备上方便浏览；以及网站后台管理系统的前端CSS框架。<br>　　jQuery Mobile通常用于：期望接近移动APP体验的WebAPP，项目只运行在手机端，不用于电脑设备展示（虽然是可以展示的，但是效果不好）。<p></p>
<p></p><h1>总结</h1><br>　如果做跨设备响应式前端，选择Boostrap；如果仅作移动端，期望得到近似APP的WebAPP，使用jQuery Mobile。<br>　　如果做一个产品级的WebAPP，当前jQuery Mobile的能力并不能让你满意，自己开发响应式布局框架和WebApp组件是必然要走的路。<p></p>
<p></p><h1>最后</h1><br>希望初学者可以掌握这两种框架，还有推荐一个js库，zepto.js,这个框架在开发移动端的时候，很便利，和jQ很像，但又有所不同，但是zepto.js更小，更便捷，zepto.js还提供了手机端的touch的api，真心很棒！<p></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4155235-c39527f8937b08f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;很多新手纠结这个问题？两个框架都能够支持做手机网页，那么它们的区别是什么呢，适用场景是什么呢？下面我们从这几个方面比较这两个框架：解决问题、功能、适用场景。&lt;br&gt;
    
    </summary>
    
      <category term="Bootstrap" scheme="http://sky-xsk.github.io/categories/Bootstrap/"/>
    
      <category term="jQuery Mobile" scheme="http://sky-xsk.github.io/categories/Bootstrap/jQuery-Mobile/"/>
    
    
      <category term="Bootstrap" scheme="http://sky-xsk.github.io/tags/Bootstrap/"/>
    
      <category term="jQuery Mobile" scheme="http://sky-xsk.github.io/tags/jQuery-Mobile/"/>
    
  </entry>
  
  <entry>
    <title>用 CSS3 怎么绘制需要的几何图形</title>
    <link href="http://sky-xsk.github.io/2016/08/13/%E7%94%A8-CSS3-%E6%80%8E%E4%B9%88%E7%BB%98%E5%88%B6%E9%9C%80%E8%A6%81%E7%9A%84%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2/"/>
    <id>http://sky-xsk.github.io/2016/08/13/用-CSS3-怎么绘制需要的几何图形/</id>
    <published>2016-08-13T10:17:52.000Z</published>
    <updated>2017-05-14T23:31:53.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h1>圆形</h1><br>思路：给任何正方形元素设置一个足够大的 border-radius ，就可以把它变成一个圆形.代码如下：<br> <a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">html:</div><div class="line">&lt;div class=&quot;size example1&quot;&gt;&lt;/div&gt;</div><div class="line">css:​​ </div><div class="line">.size&#123;width:200px; heigh: 200px;background​:#8BC34A;&#125;</div><div class="line">​.example1&#123;border-radius:100px;&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h1>自适应椭圆</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">html:</div><div class="line">&lt;div class=&quot;example3&quot;&gt;&lt;/div&gt;</div><div class="line">css:</div><div class="line">.example3&#123; width:200px;  height:150px; border-radius:50%;  background:#8BC34A;&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h1>自适应的半椭圆:沿横轴劈开的半椭圆</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">html:</div><div class="line">&lt;div class=&quot;example4&quot;&gt;&lt;/div&gt;</div><div class="line">css:</div><div class="line">.example4&#123;width:200px;height:150px; border-radius:50%/100%100%00; background:#8BC34A;&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h1>自适应的半椭圆:沿纵轴劈开的半椭圆</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">html:</div><div class="line">&lt;div class=&quot;example5&quot;&gt;&lt;/div&gt;</div><div class="line">css：</div><div class="line">.example5&#123;width:200px; height:150px;  border-radius:100%00100%/50%; background:#8BC34A;&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h1>四分之一椭圆</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">html:</div><div class="line">&lt;div class=&quot;example６&quot;&gt;&lt;/div&gt;</div><div class="line">css：</div><div class="line">.example6&#123; width:160px; height:100px;border-radius:100% 0 0 0;background:#8BC34A;&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h1>用椭圆绘制opera浏览器的logo（示例借鉴）</h1><br>思路：绘制opera浏览器的logo,分析起来不难，就只有两个图层，一个是最底部的椭圆，一个是最上面那层的椭圆。先确定一下最底层的椭圆宽高，量了一下，水平宽度为258px，垂直高度为275px，因为其是一个对称的椭圆，没有倾斜度，故4个角均为水平半径为258px，垂直半径为275px的4个相等椭圆，用同样的办法确定最里面的椭圆的半径，因此，四个角均为水平半径120px，垂直半径为229px的椭圆，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">html:</div><div class="line">&lt;div class=&quot;opera&quot;&gt;</div><div class="line">     &lt;div ​class=&quot;opera-top&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">css:</div><div class="line">.opera&#123;</div><div class="line">    width:258px;</div><div class="line">    height:275px;</div><div class="line">    background:#F22629;</div><div class="line">    border-radius:258px258px258px258px/275px275px275px275px;</div><div class="line">    position:relative;</div><div class="line">&#125;</div><div class="line">.opera-top&#123;</div><div class="line">    width:112px;</div><div class="line">    height:231px;</div><div class="line">    background:#FFFFFF;</div><div class="line">    border-radius:112px112px112px112px/231px231px231px231px;</div><div class="line">    position:absolute;</div><div class="line">    left:50%;</div><div class="line">    right:50%;</div><div class="line">    top:50%;</div><div class="line">    bottom:50%;</div><div class="line">    margin-left:-56px;</div><div class="line">    margin-top:-115px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>如有错误，请大家多多指教！</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h1&gt;圆形&lt;/h1&gt;&lt;br&gt;思路：给任何正方形元素设置一个足够大的 border-radius ，就可以把它变成一个圆形.代码如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="css3.0" scheme="http://sky-xsk.github.io/tags/css3-0/"/>
    
  </entry>
  
</feed>
