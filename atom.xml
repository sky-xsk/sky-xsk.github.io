<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>殖民的博客</title>
  <subtitle>Don&#39;t Be Same！Be Better！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sky-xsk.github.io/"/>
  <updated>2018-08-31T05:44:31.097Z</updated>
  <id>http://sky-xsk.github.io/</id>
  
  <author>
    <name>殖民</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue项目国际化，中英繁，三种语言切换</title>
    <link href="http://sky-xsk.github.io/2018/08/31/vue%E9%A1%B9%E7%9B%AE%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%8C%E4%B8%AD%E8%8B%B1%E7%B9%81%EF%BC%8C%E4%B8%89%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/"/>
    <id>http://sky-xsk.github.io/2018/08/31/vue项目国际化，中英繁，三种语言切换/</id>
    <published>2018-08-31T13:42:36.000Z</published>
    <updated>2018-08-31T05:44:31.097Z</updated>
    
    <content type="html"><![CDATA[<p>我们的软件，为了满足不同地区的需求，我们的前端部分需要做，多语言的支持，这里做一个简单的分享！<br> <a id="more"></a><br> 1.首先，安装；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vue-i18n</div></pre></td></tr></table></figure></p>
<p>2.在与main.js同级目录下，新建文件夹，如图吧：<br><img src="https://upload-images.jianshu.io/upload_images/4155235-21dde0c56dbd60d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>3.看一下main.js,注意文件的目录结构，层级；<br><img src="https://upload-images.jianshu.io/upload_images/4155235-7546d8e5ac70196c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>4.看i18n.js；<br><img src="https://upload-images.jianshu.io/upload_images/4155235-09a98dd0224c78d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>5.看index.js<br><img src="https://upload-images.jianshu.io/upload_images/4155235-7aacc48386c521fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>6.cn.js<br><img src="https://upload-images.jianshu.io/upload_images/4155235-1874b71e69bb8bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>7.en.js<br><img src="https://upload-images.jianshu.io/upload_images/4155235-05de5c19b3948b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>8.tw.js<br><img src="https://upload-images.jianshu.io/upload_images/4155235-d0273fde3feff76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>9.下面是在组件里切换语言；<br><img src="https://upload-images.jianshu.io/upload_images/4155235-ae9eef693166e651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/4155235-1202ccdf5449ce98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/4155235-45b12b95994eae95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>截图，不上代码的原因，希望可以自己动手写一遍，不要复制粘贴！<br>其实吧! 截图也挺累！</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的软件，为了满足不同地区的需求，我们的前端部分需要做，多语言的支持，这里做一个简单的分享！&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>node+vue 项目，不断更新中。。。</title>
    <link href="http://sky-xsk.github.io/2018/08/31/node-vue-%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%E3%80%82%E3%80%82%E3%80%82/"/>
    <id>http://sky-xsk.github.io/2018/08/31/node-vue-项目，不断更新中。。。/</id>
    <published>2018-08-31T13:38:57.000Z</published>
    <updated>2018-08-31T05:42:37.530Z</updated>
    
    <content type="html"><![CDATA[<p>请移步，github！<br><code>https://github.com/sky-xsk/node-vue-</code><br>记得给个“start”，谢谢！<br> <a id="more"></a><br> 请移步，github！<br><code>https://github.com/sky-xsk/node-vue-</code><br>记得给个“start”，谢谢！</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请移步，github！&lt;br&gt;&lt;code&gt;https://github.com/sky-xsk/node-vue-&lt;/code&gt;&lt;br&gt;记得给个“start”，谢谢！&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>vue+iview+mqtt（mqttws31.js） 简单实例</title>
    <link href="http://sky-xsk.github.io/2018/05/15/vue-iview-mqtt%EF%BC%88mqttws31-js%EF%BC%89-%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"/>
    <id>http://sky-xsk.github.io/2018/05/15/vue-iview-mqtt（mqttws31-js）-简单实例/</id>
    <published>2018-05-15T13:21:46.000Z</published>
    <updated>2018-08-31T05:41:35.017Z</updated>
    
    <content type="html"><![CDATA[<p>怎么新建一个项目工程，这里就不说了！主要说mqtt，怎么使用mqttws31.js，发送一个消息，怎么接收显示的问题！<br>代码会放到我的GitHub上，往后看！<br> <a id="more"></a></p>
<p> ###index.html<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;消息队列&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Access-Control-Allow-Origin&quot; content=&quot;*&quot; /&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</div><div class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/main.css&quot;&gt;</div><div class="line">    &lt;script src=&quot;./tools/mqttws31.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  //引入js</div><div class="line">    &lt;script src=&quot;./tools/config.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;       //引入主题配置文件</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;/dist/vendors.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;/dist/main.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p> ###config.js<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> host = &apos;222.73.204.54&apos;; // hostname or IP address ,自己配的消息队列服务，这里用的在线的服务，测试工具的话也会放到github；地址在最下方！</div><div class="line"> port = 9001;  //端口</div><div class="line"> addtopic = &apos;add&apos;; //约定的主题</div><div class="line">//下面暂时不用在意，下次会讲</div><div class="line"> useTLS = false;</div><div class="line"> username = null;</div><div class="line"> password = null;</div><div class="line"> cleansession = false;</div></pre></td></tr></table></figure></p>
<p>上面东西配好后，下面就是重点了: 具体代码解释，会写到注释里！</p>
<p>###app.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    export default &#123;</div><div class="line">        data() &#123;</div><div class="line">            return &#123;</div><div class="line">                reconnectTimeout: 2000,</div><div class="line">                mqtt: &#123;&#125;,</div><div class="line">                msg:&quot;&quot;,</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        mounted() &#123;</div><div class="line">            this.MQTTconnect();</div><div class="line">        &#125;,</div><div class="line">        methods: &#123;</div><div class="line">            //实时货柜变化</div><div class="line">            addtopic(msg) &#123;</div><div class="line">                this.msg = msg;</div><div class="line">            &#125;,</div><div class="line">            //实时通信</div><div class="line">            MQTTconnect() &#123;</div><div class="line">                this.mqtt = new Paho.MQTT.Client(  //实例化一个对象</div><div class="line">                    host,</div><div class="line">                    port,</div><div class="line">                    &quot;client&quot; + this.getuuid(),  //防止多个浏览器打开，导致的问题，保证唯一性</div><div class="line">                );</div><div class="line">                var options = &#123; </div><div class="line">                    timeout: 10,</div><div class="line">                    useSSL: useTLS,</div><div class="line">                    cleanSession: cleansession,</div><div class="line">                   //如果为false(flag=0)，Client断开连接后，Server应该保存Client的订阅信息。如果为true(flag=1)，表示Server应该立刻丢弃任何会话状态信息。</div><div class="line">                    onSuccess: this.onConnect,</div><div class="line">                    onFailure: function(message) &#123;</div><div class="line">                        //连接失败定时重连</div><div class="line">                        setTimeout(this.MQTTconnect, this.reconnectTimeout);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">                this.mqtt.onConnectionLost = this.onConnectionLost;</div><div class="line">                this.mqtt.onMessageArrived = this.onMessageArrived;</div><div class="line">                //用户名和密码的验证，我这里都为空；不加验证</div><div class="line">                if (username != null) &#123;</div><div class="line">                    options.userName = username;</div><div class="line">                    options.password = password;</div><div class="line">                &#125;</div><div class="line">                this.mqtt.connect(options);</div><div class="line">            &#125;,</div><div class="line">            //uuid随机生成</div><div class="line">            getuuid() &#123;</div><div class="line">                var uid = [];</div><div class="line">                var hexDigits = &quot;0123456789abcdefghijklmnopqrst&quot;;</div><div class="line">                for (var i = 0; i &lt; 32; i++) &#123;</div><div class="line">                    uid[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);</div><div class="line">                &#125;</div><div class="line">                uid[6] = &quot;4&quot;;</div><div class="line">                uid[15] = hexDigits.substr((uid[15] &amp; 0x3) | 0x8, 1);</div><div class="line">                var uuid = uid.join(&quot;&quot;);</div><div class="line">                return uuid;</div><div class="line">            &#125;,</div><div class="line">            //连接</div><div class="line">            onConnect() &#123;</div><div class="line">                //连接成功，订阅主题</div><div class="line">                this.mqtt.subscribe(addtopic, &#123;</div><div class="line">                    qos: 2  </div><div class="line">                  //QoS0，最多一次送达。也就是发出去就fire掉，没有后面的事情了。</div><div class="line">                 // QoS1，至少一次送达。发出去之后必须等待ack，没有ack，就要找时机重发</div><div class="line">                 // QoS2，准确一次送达。消息id将拥有一个简单的生命周期。</div><div class="line">                &#125;);</div><div class="line">               </div><div class="line">                //发布一个消息，再连接成功后，发送一个响应，确保连接没有问题；</div><div class="line">                this.mqtt.send(&quot;login&quot;, &quot;&#123;\&quot;command\&quot;:\&quot;login\&quot;,\&quot;clientId\&quot;:\&quot;&quot; + this.mqtt.clientId + &quot;\&quot;&#125;&quot;, 0);</div><div class="line">            &#125;,</div><div class="line">            //连接丢失</div><div class="line">            onConnectionLost(response) &#123;</div><div class="line">                //console.log(&quot;异常掉线，掉线信息为:&quot; + response.errorMessage);</div><div class="line">            &#125;,</div><div class="line">    </div><div class="line">            //接收到消息，处理</div><div class="line">            onMessageArrived(message) &#123;</div><div class="line">                var topics = message.destinationName;</div><div class="line">                var msg = $.parseJSON(message.payloadString);</div><div class="line">                //判断主题，调用方法，这里可以订阅多个主题，在此处判断，接受不同的主题，调用不同的方法！</div><div class="line">                if (topics == &quot;add&quot;) &#123;</div><div class="line">                    //添加</div><div class="line">                    this.addtopic(msg);</div><div class="line">                &#125;else &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;style&gt;</div><div class="line">    .apps &#123;</div><div class="line">        width: 100%;</div><div class="line">        overflow: hidden;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>###消息验证<br>提供一个这样的在线的测试工具；<br><img src="https://upload-images.jianshu.io/upload_images/4155235-dab43619d5103ea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="(SJBLQ$O)6JCDOT13P65R1F.png"><br>介绍一下：<br>1.server： 消息队列服务所在的地址，保证和config.js里面的地址一样；<br>2.port：端口保证和config.js里面的地址一样；<br>3.订阅：是订阅主题的地方，要和config.js约定的主题相同，才可！<br>4.发布，填写topic，我们是“add”，payload,内容，如上图！随便写！<br>点击发布，在你的页面，就能看到你发送的信息了！<br><img src="https://upload-images.jianshu.io/upload_images/4155235-5c9ede47f1df9954.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1526366434(1).jpg"></p>
<p>###ok，结束了！拿去用到项目里吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github地址：https://github.com/sky-xsk/vue-iview-mqtt-mqttws31.js-</div></pre></td></tr></table></figure></p>
<p>给个星星star，说明你看过！谢谢！</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怎么新建一个项目工程，这里就不说了！主要说mqtt，怎么使用mqttws31.js，发送一个消息，怎么接收显示的问题！&lt;br&gt;代码会放到我的GitHub上，往后看！&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>总结几种常见的垂直居中布局</title>
    <link href="http://sky-xsk.github.io/2018/04/27/%E6%80%BB%E7%BB%93%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/"/>
    <id>http://sky-xsk.github.io/2018/04/27/总结几种常见的垂直居中布局/</id>
    <published>2018-04-26T17:09:38.000Z</published>
    <updated>2018-04-26T09:10:50.221Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，直接看代码！</p>
<p>###1.margin: auto;实现绝对定位元素的水平垂直居中，IE7及以下低版本浏览器不兼容</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&apos;maps1&apos;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    margin: 0;</div><div class="line">    padding: 0;</div><div class="line">    border: 0;</div><div class="line">    list-style: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.maps1&#123;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    background-color: #000;</div><div class="line">    position: absolute;</div><div class="line">    top: 0;</div><div class="line">    right: 0;</div><div class="line">    bottom: 0;</div><div class="line">    left: 0;</div><div class="line">    margin: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###2. margin的负间距实现绝对定位元素的水平垂直居中,兼容性比较好，比较常用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&apos;maps2&apos;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    margin: 0;</div><div class="line">    padding: 0;</div><div class="line">    border: 0;</div><div class="line">    list-style: none;</div><div class="line">&#125;</div><div class="line">.maps2&#123;</div><div class="line">    position: absolute;</div><div class="line">    left: 50%;</div><div class="line">    top: 50%;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    background-color: green;</div><div class="line">    border: 10px solid #000;</div><div class="line">    margin: -110px 0 0 -110px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###3.通过transform偏移实现绝对定位元素的水平垂直居中， IE8及以下低版本浏览器不兼容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    margin: 0;</div><div class="line">    padding: 0;</div><div class="line">    border: 0;</div><div class="line">    list-style: none;</div><div class="line">&#125;</div><div class="line">.maps3&#123;</div><div class="line">    position: absolute;</div><div class="line">    left: 50%;</div><div class="line">    top: 50%;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    background-color: gray;</div><div class="line">    -webkit-transform: translate(-50%, -50%);</div><div class="line">    -moz-transform: translate(-50%, -50%);</div><div class="line">    -o-transform: translate(-50%, -50%);</div><div class="line">    -ms-transform: translate(-50%, -50%);</div><div class="line">    transform: translate(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###4.CSS3弹性盒模型布局不定宽高实现水平垂直居中 ，CSS3弹性盒模型布局本身就不支持低版本IE6-9浏览器的兼容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;maps4&quot;&gt;</div><div class="line">       &lt;div&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">body,</div><div class="line">html &#123;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">* &#123;</div><div class="line">    margin: 0;</div><div class="line">    padding: 0;</div><div class="line">    border: 0;</div><div class="line">    list-style: none;</div><div class="line">&#125;</div><div class="line">.maps4&#123;</div><div class="line">    /** height:100%就是让页面撑满整个可视区 */</div><div class="line">    height: 100%;</div><div class="line">    /** 流行版弹性盒模型布局 */</div><div class="line">    display: flex;</div><div class="line">    display: -webkit-flex;</div><div class="line">    /** 老安卓版弹性盒模型布局 */</div><div class="line">   /** display: box;</div><div class="line">    display: -webkit-box;</div><div class="line">    /** 老安卓版的横向居中 */</div><div class="line">    /**box-pack: center;</div><div class="line">    -webkit-box-pack: center;</div><div class="line">    /** 老安卓版的垂直居中 */</div><div class="line">    /**box-align: center;</div><div class="line">    -webkit-box-align: center;</div><div class="line">    /** 流行版的横向居中 */</div><div class="line">    justify-content: center;</div><div class="line">    -webkit-justify-content: center;</div><div class="line">    /** 流行版的垂直居中 */</div><div class="line">    align-items: center;</div><div class="line">    -webkit-align-items: center;</div><div class="line">&#125;</div><div class="line">.maps4 div &#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: black;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看代码应该是比较清晰的了，当自己的笔记，不喜勿喷！</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;废话不多说，直接看代码！&lt;/p&gt;
&lt;p&gt;###1.margin: auto;实现绝对定位元素的水平垂直居中，IE7及以下低版本浏览器不兼容&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue2.0 keep-alive</title>
    <link href="http://sky-xsk.github.io/2018/04/27/vue2-0-keep-alive/"/>
    <id>http://sky-xsk.github.io/2018/04/27/vue2-0-keep-alive/</id>
    <published>2018-04-26T17:06:15.000Z</published>
    <updated>2018-04-26T09:08:30.468Z</updated>
    
    <content type="html"><![CDATA[<p>参考</p>
<p>###1.用法<br>vue2.0提供了一个keep-alive组件<br>用来缓存组件,避免多次加载相应的组件,减少性能消耗<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;keep-alive&gt;</div><div class="line">      &lt;component&gt;</div><div class="line">          &lt;!-- 组件将被缓存 --&gt;</div><div class="line">      &lt;/component&gt;</div><div class="line">&lt;/keep-alive&gt;</div></pre></td></tr></table></figure></p>
<p>有时候 可能需要缓存整个站点的所有页面,而页面一般一进去都要触发请求的<br><a id="more"></a><br>在使用keep-alive的情况下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;keep-alive&gt;</div><div class="line">    &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">&lt;/keep-alive&gt;</div></pre></td></tr></table></figure></p>
<p>将首次触发请求写在created钩子函数中,就能实现缓存,<br>比如列表页,去了详情页 回来,还是在原来的页面</p>
<p>###2.缓存部分页面或者组件</p>
<p>####(1)使用router. meta属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 这是目前用的比较多的方式</div><div class="line">&lt;keep-alive&gt;</div><div class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</div><div class="line">&lt;/keep-alive&gt;</div><div class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</div></pre></td></tr></table></figure></p>
<p>router设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">routes: [</div><div class="line">  &#123; path: &apos;/&apos;, redirect: &apos;/index&apos;,  component: Index, meta: &#123; keepAlive: true &#125;&#125;,</div><div class="line">  &#123;</div><div class="line">    path: &apos;/common&apos;,</div><div class="line">    component: TestParent,</div><div class="line">    children: [</div><div class="line">      &#123; path: &apos;/test2&apos;, component: Test2, meta: &#123; keepAlive: true &#125; &#125; </div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line"> // 表示index和test2都使用keep-alive</div></pre></td></tr></table></figure></p>
<p>####(2).使用新增属性inlcude/exclude<br>2.1.0后提供了include/exclude两个属性 可以针对性缓存相应的组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!-- comma-delimited string --&gt;</div><div class="line">&lt;keep-alive include=&quot;a,b&quot;&gt;</div><div class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</div><div class="line">&lt;/keep-alive&gt;</div><div class="line">&lt;!-- regex (use v-bind) --&gt;</div><div class="line">&lt;keep-alive :include=&quot;/a|b/&quot;&gt;</div><div class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</div><div class="line">&lt;/keep-alive&gt;</div><div class="line"></div><div class="line">//其中a,b是组件的name</div></pre></td></tr></table></figure></p>
<p>注意:这种方法都是预先知道组件的名称的<br>(2)动态判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;keep-alive :include=&quot;includedComponents&quot;&gt;</div><div class="line">  &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">&lt;/keep-alive&gt;</div></pre></td></tr></table></figure></p>
<p><code>includedComponents</code>动态设置即可</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;###1.用法&lt;br&gt;vue2.0提供了一个keep-alive组件&lt;br&gt;用来缓存组件,避免多次加载相应的组件,减少性能消耗&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;keep-alive&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;lt;component&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &amp;lt;!-- 组件将被缓存 --&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;lt;/component&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/keep-alive&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有时候 可能需要缓存整个站点的所有页面,而页面一般一进去都要触发请求的&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解决vue打包时出现的错误（自己写的js，打包时出错）</title>
    <link href="http://sky-xsk.github.io/2017/12/14/%E8%A7%A3%E5%86%B3vue%E6%89%93%E5%8C%85%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%88%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84js%EF%BC%8C%E6%89%93%E5%8C%85%E6%97%B6%E5%87%BA%E9%94%99%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/12/14/解决vue打包时出现的错误（自己写的js，打包时出错）/</id>
    <published>2017-12-14T14:44:52.000Z</published>
    <updated>2017-12-14T06:49:18.181Z</updated>
    
    <content type="html"><![CDATA[<p>今天，打包项目是遇到这样的报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ERROR in static/js/app.3229f4e0a68089746e5c.js from UglifyJs</div><div class="line">Unexpected token: punc (() [./static/js/tool.js:14,0][static/js/app.3229f4e0a68089746e5c.js:72,11]</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这里说一下，static是自己新建的文件夹放置自己写js文件，tool.js就是自己写的，在vue文件里或者其他js文件里引用；<br><b>解决方法：</b><br>修改build文件夹下的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack.base.conf.js</div></pre></td></tr></table></figure></p>
<p>找到module对象：<br>修改如下代码<br><b>修改前：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   test: /\.js$/,</div><div class="line">   loader: &apos;babel-loader&apos;,</div><div class="line">   include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]</div><div class="line"> &#125;,</div></pre></td></tr></table></figure></p>
<p><b>修改后：</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">test: /\.js$/,</div><div class="line">loader: &apos;babel-loader&apos;,</div><div class="line">include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;static/js/tool.js&apos;)]</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p><b>再次打包，问题完美解决！</b></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script>

</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，打包项目是遇到这样的报错：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ERROR in static/js/app.3229f4e0a68089746e5c.js from UglifyJs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Unexpected token: punc (() [./static/js/tool.js:14,0][static/js/app.3229f4e0a68089746e5c.js:72,11]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://sky-xsk.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>理解js的运行机制</title>
    <link href="http://sky-xsk.github.io/2017/12/08/%E7%90%86%E8%A7%A3js%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://sky-xsk.github.io/2017/12/08/理解js的运行机制/</id>
    <published>2017-12-08T09:23:31.000Z</published>
    <updated>2017-12-08T01:26:47.515Z</updated>
    
    <content type="html"><![CDATA[<p>最近比较忙，硬是没抽出时间总结一点小知识。最近在网上看到一篇不错的文章，转一下！<br>本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。</p>
<p>不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论：<br> <a id="more"></a></p>
<p>javascript是按照语句出现的顺序执行的<br>看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = &apos;1&apos;;</div><div class="line">console.log(a);</div><div class="line"></div><div class="line">let b = &apos;2&apos;;</div><div class="line">console.log(b);</div></pre></td></tr></table></figure></p>
<p>然而实际上js是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">    console.log(&apos;定时器开始啦&apos;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    console.log(&apos;马上执行for循环啦&apos;);</div><div class="line">    for(var i = 0; i &lt; 10000; i++)&#123;</div><div class="line">        i == 99 &amp;&amp; resolve();</div><div class="line">    &#125;</div><div class="line">&#125;).then(function()&#123;</div><div class="line">    console.log(&apos;执行then函数啦&apos;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;代码执行结束&apos;);</div></pre></td></tr></table></figure></p>
<p>依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//&quot;定时器开始啦&quot;</div><div class="line">//&quot;马上执行for循环啦&quot;</div><div class="line">//&quot;执行then函数啦&quot;</div><div class="line">//&quot;代码执行结束&quot;</div></pre></td></tr></table></figure></p>
<p>去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？<br>我们真的要彻底弄明白javascript的执行机制了。</p>
<p>###1.关于javascript<br>javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p>
<p>###2.javascript事件循环<br>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p>
<p>同步任务<br>异步任务<br>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：</p>
<p>导图要表达的内容用文字来表述的话：</p>
<p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。<br>当指定的事情完成时，Event Table会将这个函数移入Event Queue。<br>    主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。<br>    上述过程会不断重复，也就是常说的Event Loop(事件循环)。<br>    我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。<br>说了这么多文字，不如直接一段代码更直白：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let data = [];</div><div class="line">$.ajax(&#123;</div><div class="line">    url:www.javascript.com,</div><div class="line">    data:data,</div><div class="line">    success:() =&gt; &#123;</div><div class="line">        console.log(&apos;发送成功!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">console.log(&apos;代码执行结束&apos;);</div></pre></td></tr></table></figure></p>
<p>上面是一段简易的ajax请求代码：</p>
<p>ajax进入Event Table，注册回调函数success。<br>执行console.log(‘代码执行结束’)。<br>ajax事件完成，回调函数success进入Event Queue。<br>主线程从Event Queue读取回调函数success并执行。<br>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</p>
<p>###3.又爱又恨的setTimeout<br>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    console.log(&apos;延时3秒&apos;);</div><div class="line">&#125;,3000)</div></pre></td></tr></table></figure></p>
<p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p>
<p>先看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    task();</div><div class="line">&#125;,3000)</div><div class="line">console.log(&apos;执行console&apos;);</div></pre></td></tr></table></figure></p>
<p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//执行console</div><div class="line">//task()</div></pre></td></tr></table></figure></p>
<p>去验证一下，结果正确！<br>然后我们修改一下前面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    task()</div><div class="line">&#125;,3000)</div><div class="line"></div><div class="line">sleep(10000000)</div></pre></td></tr></table></figure></p>
<p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？</p>
<p>这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：</p>
<p>task()进入Event Table并注册,计时开始。<br>执行sleep函数，很慢，非常慢，计时仍在继续。<br>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。<br>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。<br>上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p>
<p>我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p>
<p>答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//代码1</div><div class="line">console.log(&apos;先执行这里&apos;);</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    console.log(&apos;执行啦&apos;)</div><div class="line">&#125;,0);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//代码2</div><div class="line">console.log(&apos;先执行这里&apos;);</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    console.log(&apos;执行啦&apos;)</div><div class="line">&#125;,3000);</div></pre></td></tr></table></figure>
<p>代码1的输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//先执行这里</div><div class="line">//执行啦</div></pre></td></tr></table></figure></p>
<p>代码2的输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//先执行这里</div><div class="line">// ... 3s later</div><div class="line">// 执行啦</div></pre></td></tr></table></figure></p>
<p>关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p>
<p>###4.又恨又爱的setInterval<br>上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p>
<p>###5.Promise与process.nextTick(callback)<br>传统的定时器我们已经研究过了，接着我们探究<code>Promise</code>与<code>process.nextTick(callback)</code>的表现。</p>
<p><code>Promise</code>的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的<a href="https://link.juejin.im/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise" target="_blank" rel="external">Promise</a>。而<code>process.nextTick(callback)</code>类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p>
<p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<ul>
<li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<p>不同类型的任务会进入对应的Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的Event Queue。</p>
<p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">setTimeout(function() &#123;</div><div class="line">    console.log(&apos;setTimeout&apos;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">new Promise(function(resolve) &#123;</div><div class="line">    console.log(&apos;promise&apos;);</div><div class="line">&#125;).then(function() &#123;</div><div class="line">    console.log(&apos;then&apos;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(&apos;console&apos;);</div></pre></td></tr></table></figure></p>
<p>这段代码作为宏任务，进入主线程。<br>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)<br>接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。<br>遇到console.log()，立即执行。<br>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。<br>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。<br>结束。<br>事件循环，宏任务，微任务的关系如图所示：</p>
<p>我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;1&apos;);</div><div class="line"></div><div class="line">setTimeout(function() &#123;</div><div class="line">    console.log(&apos;2&apos;);</div><div class="line">    process.nextTick(function() &#123;</div><div class="line">        console.log(&apos;3&apos;);</div><div class="line">    &#125;)</div><div class="line">    new Promise(function(resolve) &#123;</div><div class="line">        console.log(&apos;4&apos;);</div><div class="line">        resolve();</div><div class="line">    &#125;).then(function() &#123;</div><div class="line">        console.log(&apos;5&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line">process.nextTick(function() &#123;</div><div class="line">    console.log(&apos;6&apos;);</div><div class="line">&#125;)</div><div class="line">new Promise(function(resolve) &#123;</div><div class="line">    console.log(&apos;7&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;).then(function() &#123;</div><div class="line">    console.log(&apos;8&apos;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">setTimeout(function() &#123;</div><div class="line">    console.log(&apos;9&apos;);</div><div class="line">    process.nextTick(function() &#123;</div><div class="line">        console.log(&apos;10&apos;);</div><div class="line">    &#125;)</div><div class="line">    new Promise(function(resolve) &#123;</div><div class="line">        console.log(&apos;11&apos;);</div><div class="line">        resolve();</div><div class="line">    &#125;).then(function() &#123;</div><div class="line">        console.log(&apos;12&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>第一轮事件循环流程分析如下：</p>
<p>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。<br>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。<br>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。<br>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。<br>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。<br>宏任务Event Queue    微任务Event Queue<br>setTimeout1    process1<br>setTimeout2    then1<br>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</p>
<p>我们发现了process1和then1两个微任务。</p>
<p>执行process1,输出6。<br>执行then1，输出8。<br>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始：</p>
<p>首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。<br>宏任务Event Queue    微任务Event Queue<br>setTimeout2    process2<br>then2<br>第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。<br>输出3。<br>输出5。<br>第二轮事件循环结束，第二轮输出2，4，3，5。<br>第三轮事件循环开始，此时只剩setTimeout2了，执行。<br>直接输出9。<br>将process.nextTick()分发到微任务Event Queue中。记为process3。<br>直接执行new Promise，输出11。<br>将then分发到微任务Event Queue中，记为then3。<br>宏任务Event Queue    微任务Event Queue<br>process3<br>then3<br>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。<br>输出10。<br>输出12。<br>第三轮事件循环结束，第三轮输出9，11，10，12。<br>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。<br>(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p>
<p>###6.写在最后<br>(1)js的异步<br>我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。</p>
<p>(2)事件循环Event Loop<br>事件循环是js实现异步的一种方法，也是js的执行机制。</p>
<p>(3)javascript的执行和运行<br>执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</p>
<p>(4)setImmediate<br>微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。</p>
<p>(5)最后的最后<br>javascript是一门单线程语言<br>Event Loop是javascript的执行机制<br>牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">转自http://www.zhangxinxu.com/php/myRecommBackup.php?id=js-excude-detail</div></pre></td></tr></table></figure>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近比较忙，硬是没抽出时间总结一点小知识。最近在网上看到一篇不错的文章，转一下！&lt;br&gt;本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。&lt;/p&gt;
&lt;p&gt;不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论：&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>用axios+element-ui 增删改查小例子</title>
    <link href="http://sky-xsk.github.io/2017/10/17/%E7%94%A8axios-element-ui-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%B0%8F%E4%BE%8B%E5%AD%90/"/>
    <id>http://sky-xsk.github.io/2017/10/17/用axios-element-ui-增删改查小例子/</id>
    <published>2017-10-17T15:33:21.000Z</published>
    <updated>2017-10-17T07:36:22.328Z</updated>
    
    <content type="html"><![CDATA[<p>axios-elementui增删改查小例子，代码见github,给加个星星：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/sky-xsk/axios-elementui-</div></pre></td></tr></table></figure></p>
<p>我用的是公司内部提供的api，所以不在公司内部，是看不到效果的，最主要的还是对源码的参考！<br>放心我会附上图片效果的!<br> 之前使用vue-reource写的，并且没有封装，这个例子用的是es6里的promise进行的封装，单独抽取出api接口；<br>代码如下：<br><a id="more"></a><br>模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;div id=&quot;user&quot;&gt; </div><div class="line">        &lt;h1&gt;vue2.0+axios+elementui 简单的增删改查&lt;/h1&gt;</div><div class="line">        &lt;el-row class=&quot;line-display&quot;&gt;</div><div class="line">            &lt;el-col :span=&quot;22&quot; :offset=&quot;1&quot;&gt;</div><div class="line">                &lt;div class=&quot;grid-content&quot; style=&quot;margin-top:30px;&quot;&gt;</div><div class="line">                    &lt;!-- 操作 --&gt;</div><div class="line">                    &lt;ul class=&quot;btn-edit fr&quot;&gt;</div><div class="line">                        &lt;li &gt;</div><div class="line">                            &lt;el-button type=&quot;primary&quot; @click=&quot;dialogCreateVisible = true&quot;&gt; &lt;i class=&quot;el-icon-plus iconss&quot; &gt;&lt;/i&gt;添加用户&lt;/el-button&gt;</div><div class="line">                            &lt;el-button type=&quot;danger&quot; icon=&quot;delete&quot; :disabled=&quot;selected.length==0&quot; @click=&quot;removeUsers()&quot;  &gt;删除&lt;/el-button&gt;</div><div class="line">                        &lt;/li&gt;</div><div class="line">                    &lt;/ul&gt;</div><div class="line">                    &lt;!-- 用户列表--&gt;</div><div class="line">                    &lt;el-col :span=&quot;24&quot; style=&quot;height:20px;&quot;&gt;&lt;/el-col&gt;</div><div class="line">                    &lt;el-table :data=&quot;users&quot;</div><div class="line">                              stripe</div><div class="line">                              v-loading=&quot;loading&quot;</div><div class="line">                              element-loading-text=&quot;拼命加载中...&quot;</div><div class="line">                              style=&quot;width: 100%;margin-top:20px;&quot;</div><div class="line">                              height=&quot;443&quot;</div><div class="line">                              @sort-change=&quot;tableSortChange&quot;</div><div class="line">                              @selection-change=&quot;tableSelectionChange&quot; &gt;</div><div class="line">                        &lt;el-table-column type=&quot;selection&quot;</div><div class="line">                                         width=&quot;60&quot;&gt;</div><div class="line">                        &lt;/el-table-column&gt;</div><div class="line">                        &lt;el-table-column sortable=&quot;custom&quot;</div><div class="line">                                         prop=&quot;username&quot;</div><div class="line">                                         label=&quot;用户名&quot;</div><div class="line">                                         width=&quot;100&quot;&gt;</div><div class="line">                        &lt;/el-table-column&gt;</div><div class="line">                        &lt;el-table-column prop=&quot;name&quot;</div><div class="line">                                         label=&quot;姓名&quot;</div><div class="line">                                         width=&quot;80&quot;&gt;</div><div class="line">                        &lt;/el-table-column&gt;</div><div class="line">                        &lt;el-table-column prop=&quot;phone&quot;</div><div class="line">                                         label=&quot;手机&quot;&gt;</div><div class="line">                        &lt;/el-table-column&gt;</div><div class="line">                        &lt;el-table-column prop=&quot;email&quot;</div><div class="line">                                         label=&quot;邮箱&quot;&gt;</div><div class="line">                        &lt;/el-table-column&gt;</div><div class="line">                        &lt;el-table-column prop=&quot;create_time&quot; sortable=&quot;custom&quot; </div><div class="line">                                         label=&quot;注册日期&quot;&gt;</div><div class="line">                                   </div><div class="line">                        &lt;/el-table-column&gt;</div><div class="line">                        &lt;el-table-column</div><div class="line">                            prop=&quot;is_active&quot;</div><div class="line">                            label=&quot;状态&quot;</div><div class="line">                            width=&quot;75&quot;</div><div class="line">                            inline-template&gt;</div><div class="line">                            &lt;el-tag :type=&quot;row.is_active === true ? &apos;primary&apos; : &apos;success&apos;&quot; close-transition&gt;&#123;&#123;row.is_active|isEnabledFormatter&#125;&#125;&lt;/el-tag&gt;</div><div class="line">                        &lt;/el-table-column&gt;</div><div class="line">                        &lt;el-table-column</div><div class="line">                            inline-template</div><div class="line">                            label=&quot;操作&quot;</div><div class="line">                            width=&quot;250&quot;&gt;</div><div class="line">                            &lt;span&gt;</div><div class="line">                                &lt;el-button type=&quot;danger&quot; size=&quot;small&quot; @click=&quot;removeUser(row)&quot;&gt;删除&lt;/el-button&gt;</div><div class="line">                                &lt;el-button type=&quot;success&quot; size=&quot;small&quot; @click=&quot;setCurrent(row)&quot;&gt;编辑&lt;/el-button&gt;</div><div class="line">                            &lt;/span&gt;</div><div class="line">                        &lt;/el-table-column&gt;</div><div class="line">                    &lt;/el-table&gt;</div><div class="line">                    &lt;div style=&quot; width:100%; ovflow:hidden; height:40px;&quot;&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/el-col&gt;</div><div class="line">        &lt;/el-row&gt;</div><div class="line">        &lt;!-- 创建用户 begin--&gt;</div><div class="line">        &lt;el-dialog title=&quot;创建用户&quot; v-model=&quot;dialogCreateVisible&quot; :close-on-click-modal=&quot;false&quot; :close-on-press-escape=&quot;false&quot; @close=&quot;reset&quot; &gt;</div><div class="line">            &lt;el-form id=&quot;#create&quot; :model=&quot;create&quot; :rules=&quot;rules&quot; ref=&quot;create&quot; label-width=&quot;100px&quot;&gt;</div><div class="line">                &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;create.username&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;create.name&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;create.password&quot; type=&quot;password&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;create.checkPass&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;电话&quot; prop=&quot;phone&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;create.phone&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;create.email&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;是否启用&quot;&gt;</div><div class="line">                    &lt;el-switch on-text=&quot;&quot; off-text=&quot;&quot; v-model=&quot;create.is_active&quot;&gt;&lt;/el-switch&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">            &lt;/el-form&gt;</div><div class="line">            &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</div><div class="line">                &lt;el-button @click=&quot;dialogCreateVisible = false&quot;&gt;取 消&lt;/el-button&gt;</div><div class="line">                &lt;el-button type=&quot;primary&quot; :loading=&quot;createLoading&quot; @click=&quot;createUser&quot;&gt;确 定&lt;/el-button&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/el-dialog&gt;</div><div class="line">        &lt;!-- 修改用户 begin--&gt;</div><div class="line">        &lt;el-dialog title=&quot;修改用户信息&quot; v-model=&quot;dialogUpdateVisible&quot;  :close-on-click-modal=&quot;false&quot; :close-on-press-escape=&quot;false&quot;&gt;</div><div class="line">            &lt;el-form id=&quot;#update&quot; :model=&quot;update&quot; :rules=&quot;updateRules&quot; ref=&quot;update&quot; label-width=&quot;100px&quot;&gt;</div><div class="line">                &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;update.name&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;电话&quot; prop=&quot;phone&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;update.phone&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt;</div><div class="line">                    &lt;el-input v-model=&quot;update.email&quot;&gt;&lt;/el-input&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">                &lt;el-form-item label=&quot;是否启用&quot;&gt;</div><div class="line">                    &lt;el-switch on-text=&quot;&quot; off-text=&quot;&quot; v-model=&quot;update.is_active&quot;&gt;&lt;/el-switch&gt;</div><div class="line">                &lt;/el-form-item&gt;</div><div class="line">            &lt;/el-form&gt;</div><div class="line">            &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</div><div class="line">                &lt;el-button @click=&quot;dialogUpdateVisible = false&quot;&gt;取 消&lt;/el-button&gt;</div><div class="line">                &lt;el-button type=&quot;primary&quot; :loading=&quot;updateLoading&quot; @click=&quot;updateUser&quot;&gt;确 定&lt;/el-button&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/el-dialog&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p>
<p>js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    import &#123;</div><div class="line">        mapState,</div><div class="line">        mapMutations,</div><div class="line">        mapGetters,</div><div class="line">        mapActions</div><div class="line">    &#125; from &apos;vuex&apos;;</div><div class="line">    import api from &apos;../api/api.js&apos;</div><div class="line">    var placeholders = &#123;</div><div class="line">        &quot;name&quot;: &quot;请输入查找姓名&quot;,</div><div class="line">        &quot;username&quot;: &quot;请输入查找用户名&quot;,</div><div class="line">        &quot;phone&quot;: &quot;请输入查找电话&quot;</div><div class="line">    &#125;;</div><div class="line">    function getuuid() &#123;</div><div class="line">        var uid = [];</div><div class="line">        var hexDigits = &quot;0123456789abcdefghijklmnopqrst&quot;;</div><div class="line">        for (var i = 0; i &lt; 32; i++) &#123;</div><div class="line">            uid[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);</div><div class="line">        &#125;</div><div class="line">        uid[6] = &quot;4&quot;;</div><div class="line">        uid[15] = hexDigits.substr((uid[15] &amp; 0x3) | 0x8, 1);</div><div class="line">        var uuid = uid.join(&quot;&quot;);</div><div class="line">        return uuid;</div><div class="line">    &#125;</div><div class="line">    export default &#123;</div><div class="line">        name:&apos;&apos;,</div><div class="line">        data : function () &#123;</div><div class="line">            var validatePass = (rule, value, callback) =&gt; &#123;</div><div class="line">                if (value === &apos;&apos;) &#123;</div><div class="line">                    callback(new Error(&apos;请再次输入密码&apos;));</div><div class="line">                &#125; else if (value !== this.create.password) &#123;</div><div class="line">                    callback(new Error(&apos;两次输入密码不一致!&apos;));</div><div class="line">                &#125; else &#123;</div><div class="line">                    callback();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            return&#123;</div><div class="line">                users:[],</div><div class="line">                filter: &#123;</div><div class="line">                    per_page: 10, // 页大小</div><div class="line">                    page: 1, // 当前页</div><div class="line">                    name: &apos;&apos;,</div><div class="line">                    username: &apos;&apos;,</div><div class="line">                    phone: &apos;&apos;,</div><div class="line">                    is_active: &apos;&apos;,</div><div class="line">                    create_time:&apos;&apos;,</div><div class="line">                    sorts: &apos;&apos;</div><div class="line">                &#125;,</div><div class="line">                create: &#123;</div><div class="line">                    id: &apos;&apos;,</div><div class="line">                    username: &apos;&apos;,</div><div class="line">                    name: &apos;&apos;,</div><div class="line">                    password: &apos;&apos;,</div><div class="line">                    checkPass: &apos;&apos;,</div><div class="line">                    phone: &apos;&apos;,</div><div class="line">                    email: &apos;&apos;,</div><div class="line">                    is_active: true</div><div class="line">                &#125;,</div><div class="line">                currentId: &apos;&apos;,</div><div class="line">                update: &#123;</div><div class="line">                    name: &apos;&apos;,</div><div class="line">                    phone: &apos;&apos;,</div><div class="line">                    email: &apos;&apos;,</div><div class="line">                    is_active: true</div><div class="line">                &#125;,</div><div class="line">                rules: &#123;</div><div class="line">                    name: [&#123;</div><div class="line">                        required: true,</div><div class="line">                        message: &apos;请输入姓名&apos;,</div><div class="line">                        trigger: &apos;blur&apos;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        min: 3,</div><div class="line">                        max: 15,</div><div class="line">                        message: &apos;长度在 3 到 15 个字符&apos;</div><div class="line">                    &#125;],</div><div class="line">                    username: [&#123;</div><div class="line">                        required: true,</div><div class="line">                        message: &apos;请输入用户名&apos;,</div><div class="line">                        trigger: &apos;blur&apos;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        min: 3,</div><div class="line">                        max: 25,</div><div class="line">                        message: &apos;长度在 3 到 25 个字符&apos;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        pattern: /^[A-Za-z0-9]+$/,</div><div class="line">                        message: &apos;用户名只能为字母和数字&apos;</div><div class="line">                    &#125;],</div><div class="line">                    password: [&#123;</div><div class="line">                        required: true,</div><div class="line">                        message: &apos;请输入密码&apos;,</div><div class="line">                        trigger: &apos;blur&apos;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        min: 6,</div><div class="line">                        max: 25,</div><div class="line">                        message: &apos;长度在 6 到 25 个字符&apos;</div><div class="line">                    &#125;],</div><div class="line">                    checkPass: [&#123;</div><div class="line">                        required: true,</div><div class="line">                        message: &apos;请再次输入密码&apos;,</div><div class="line">                        trigger: &apos;blur&apos;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        validator: validatePass</div><div class="line">                    &#125;],</div><div class="line">                    email: [&#123;</div><div class="line">                        type: &apos;email&apos;,</div><div class="line">                        message: &apos;邮箱格式不正确&apos;</div><div class="line">                    &#125;],</div><div class="line">                    phone: [&#123;</div><div class="line">                        pattern: /^1[34578]\d&#123;9&#125;$/,</div><div class="line">                        message: &apos;请输入中国国内的手机号码&apos;</div><div class="line">                    &#125;]</div><div class="line">                &#125;,</div><div class="line">                updateRules: &#123;</div><div class="line">                    name: [&#123;</div><div class="line">                        required: true,</div><div class="line">                        message: &apos;请输入姓名&apos;,</div><div class="line">                        trigger: &apos;blur&apos;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        min: 3,</div><div class="line">                        max: 15,</div><div class="line">                        message: &apos;长度在 3 到 15 个字符&apos;</div><div class="line">                    &#125;],</div><div class="line">                    email: [&#123;</div><div class="line">                        type: &apos;email&apos;,</div><div class="line">                        message: &apos;邮箱格式不正确&apos;</div><div class="line">                    &#125;],</div><div class="line">                    phone: [&#123;</div><div class="line">                        pattern: /^1[34578]\d&#123;9&#125;$/,</div><div class="line">                        message: &apos;请输入中国国内的手机号码&apos;</div><div class="line">                    &#125;]</div><div class="line">                &#125;,</div><div class="line">                total_rows:0,</div><div class="line">                loading:true,</div><div class="line">                keywords: &apos;&apos;, //搜索框的关键字内容</div><div class="line">                select: &apos;username&apos;, //搜索框的搜索字段</div><div class="line">                selected: [], //已选择项</div><div class="line">                dialogCreateVisible: false, //创建对话框的显示状态</div><div class="line">                dialogUpdateVisible: false, //编辑对话框的显示状态</div><div class="line">                createLoading: false,</div><div class="line">                updateLoading: false,</div><div class="line">                placeholder: placeholders[&quot;username&quot;]</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        mounted:function()&#123;</div><div class="line">            this.getUsers();</div><div class="line">        &#125;,</div><div class="line">        methods:&#123;</div><div class="line"></div><div class="line">            tableSelectionChange(val) &#123;</div><div class="line">                this.selected = val;</div><div class="line">            &#125;,</div><div class="line">            //排序</div><div class="line">            tableSortChange(val) &#123;</div><div class="line">                if (val.prop != null) &#123;</div><div class="line">                    if (val.order == &apos;descending&apos;) &#123;</div><div class="line">                        this.filter.sorts = &apos;-&apos; + val.prop;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        this.filter.sorts = &apos;&apos; + val.prop;</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    this.filter.sorts = &apos;&apos;;</div><div class="line">                &#125;</div><div class="line">                this.getUsers();</div><div class="line">            &#125;,</div><div class="line">            //每页显示多少条</div><div class="line">            pageSizeChange(val) &#123;</div><div class="line">                console.log(`每页 $&#123;val&#125; 条`);</div><div class="line">                this.filter.per_page = val;</div><div class="line">                this.getUsers();</div><div class="line">            &#125;,</div><div class="line">            //当前页选择</div><div class="line">            pageCurrentChange(val) &#123;</div><div class="line">                console.log(`当前页: $&#123;val&#125;`);</div><div class="line">                this.filter.page = val;</div><div class="line">                this.getUsers();</div><div class="line">            &#125;,</div><div class="line">             searchFieldChange(val) &#123;</div><div class="line">                this.placeholder = placeholders[val];</div><div class="line">                console.log(`搜索字段： $&#123;val&#125; `);</div><div class="line">            &#125;,</div><div class="line">             rowClick(row, event) &#123;</div><div class="line">                var index = $.inArray(row, this.selected)</div><div class="line">                if (index &lt; 0) &#123;</div><div class="line">                    this.selected.push(row);</div><div class="line">                    this.$refs.usersTable.toggleRowSelection(row, true);</div><div class="line">                &#125; else &#123;</div><div class="line">                    this.selected.splice(index, 1);</div><div class="line">                    this.$refs.usersTable.toggleRowSelection(row, false);</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">           // 重置表单</div><div class="line">            reset() &#123;</div><div class="line">                this.$refs.create.resetFields();</div><div class="line">            &#125;,</div><div class="line">            setCurrent(user) &#123;</div><div class="line">                this.currentId = user.id;</div><div class="line">                this.update.name = user.name;</div><div class="line">                this.update.phone = user.phone;</div><div class="line">                this.update.email = user.email;</div><div class="line">                this.update.is_active = user.is_active;</div><div class="line">                this.dialogUpdateVisible = true;</div><div class="line">            &#125;,</div><div class="line">            //获取用户数据</div><div class="line">            getUsers()&#123;</div><div class="line">                this.loading = true;</div><div class="line">                api._get().then(res =&gt; &#123;</div><div class="line">                    this.users = res.datas;</div><div class="line">                    this.total_rows = res.datas.total_rows;</div><div class="line">                    this.loading=false;</div><div class="line">                    console.log(res);</div><div class="line">                &#125;,err =&gt; &#123;</div><div class="line">                    console.log(err);</div><div class="line">                &#125;)</div><div class="line">            &#125;,</div><div class="line">            //创建用户</div><div class="line">            createUser() &#123;</div><div class="line">                this.$refs.create.validate((valid) =&gt; &#123;</div><div class="line">                    if (valid) &#123;</div><div class="line">                        this.create.id = getuuid();</div><div class="line">                        this.createLoading = true;</div><div class="line">                        api._post(this.create).then(res =&gt; &#123;</div><div class="line">                            this.$message.success(&apos;创建用户成功！&apos;);</div><div class="line">                            this.dialogCreateVisible = false;</div><div class="line">                            this.createLoading = false;</div><div class="line">                            this.reset();</div><div class="line">                            this.getUsers();</div><div class="line">                        &#125;).catch((res) =&gt; &#123;</div><div class="line">                            var data = res;</div><div class="line">                            if (data instanceof Array) &#123;</div><div class="line">                              this.$message.error(data[0][&quot;message&quot;]);</div><div class="line">                            &#125; else if (data instanceof Object) &#123;</div><div class="line">                              this.$message.error(data[&quot;message&quot;]);</div><div class="line">                            &#125;</div><div class="line">                            this.createLoading = false;</div><div class="line">                        &#125;);</div><div class="line">                    &#125; else &#123;</div><div class="line">                      //this.$message.error(&apos;存在输入校验错误!&apos;);</div><div class="line">                      return false;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;,</div><div class="line">            </div><div class="line">            // 更新用户资料</div><div class="line">            updateUser() &#123;</div><div class="line">                this.$refs.update.validate((valid) =&gt; &#123;</div><div class="line">                    if (valid) &#123;</div><div class="line">                        this.updateLoading = true;</div><div class="line">                        api._update(this.currentId, this.update).then(res =&gt; &#123;</div><div class="line">                            this.$message.success(&apos;修改用户资料成功！&apos;);</div><div class="line">                            this.dialogUpdateVisible = false;</div><div class="line">                            this.updateLoading = false;</div><div class="line">                            this.getUsers();</div><div class="line">                        &#125;).catch((res) =&gt; &#123;</div><div class="line">                            var data = res;</div><div class="line">                            if (data instanceof Array) &#123;</div><div class="line">                                this.$message.error(data[0][&quot;message&quot;]);</div><div class="line">                            &#125; else if (data instanceof Object) &#123;</div><div class="line">                                this.$message.error(data[&quot;message&quot;]);</div><div class="line">                            &#125;</div><div class="line">                            this.updateLoading = false;</div><div class="line">                          &#125;);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        return false;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;,</div><div class="line"></div><div class="line">            // 删除单个用户</div><div class="line">            removeUser(user) &#123;</div><div class="line">                </div><div class="line">                this.$confirm(&apos;此操作将永久删除用户 &apos; + user.username + &apos;, 是否继续?&apos;, &apos;提示&apos;, &#123;</div><div class="line">                  type: &apos;warning&apos;</div><div class="line">                &#125;).then(() =&gt; &#123;</div><div class="line">                    api._remove(user).then(res =&gt; &#123;</div><div class="line">                        this.$message.success(&apos;成功删除了用户&apos; + user.username + &apos;!&apos;);</div><div class="line">                        this.getUsers();</div><div class="line">                        console.log(user.id);</div><div class="line">                    &#125;).catch((res) =&gt; &#123;</div><div class="line">                        this.$message.error(&apos;删除失败!&apos;);</div><div class="line">                    &#125;);</div><div class="line">                &#125;).catch(() =&gt; &#123;</div><div class="line">                    this.$message.info(&apos;已取消操作!&apos;);</div><div class="line">                &#125;);</div><div class="line">            &#125;,</div><div class="line"></div><div class="line">             //删除多个用户</div><div class="line">            removeUsers() &#123;</div><div class="line">                this.$confirm(&apos;此操作将永久删除 &apos; + this.selected.length + &apos; 个用户, 是否继续?&apos;, &apos;提示&apos;, &#123;</div><div class="line">                    type: &apos;warning&apos;</div><div class="line">                &#125;).then(() =&gt; &#123;</div><div class="line">                    api._removes().then(res =&gt;&#123;</div><div class="line">                        this.$message.success(&apos;删除了&apos; + this.selected.length + &apos;个用户!&apos;);</div><div class="line">                        this.getUsers();</div><div class="line">                    &#125;).catch((res) =&gt; &#123;</div><div class="line">                        this.$message.error(&apos;删除失败!&apos;);</div><div class="line">                    &#125;);</div><div class="line">                &#125;).catch(() =&gt; &#123;</div><div class="line">                    this.$message(&apos;已取消操作!&apos;);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;style&gt;</div><div class="line">ul li&#123;list-style: none&#125;</div><div class="line">.tc&#123;text-align:center; &#125;</div><div class="line">.mg&#123; margin-top:10px;&#125;</div><div class="line">.fl&#123;float:left&#125;</div><div class="line">.fr&#123;float:right&#125;</div><div class="line">h1&#123;text-align: center;&#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>抽离的api以及代码的二次封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">import axios from &apos;axios&apos;</div><div class="line">import qs from &apos;qs&apos;</div><div class="line"></div><div class="line">//延时设置</div><div class="line">axios.defaults.timeout = 5000</div><div class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;</div><div class="line">axios.defaults.params = &#123;&#125;</div><div class="line">// POST传参序列化</div><div class="line">axios.interceptors.request.use((config) =&gt; &#123;</div><div class="line">    // if (config.method === &apos;post&apos;) &#123;</div><div class="line">    //     config.data = qs.stringify(config.data)</div><div class="line">    // &#125;</div><div class="line">    let URL = config.url.split(config.baseURL)</div><div class="line">    return config</div><div class="line">&#125;, (error) =&gt; &#123;</div><div class="line">    return Promise.reject(error)</div><div class="line">&#125;)</div><div class="line">  </div><div class="line">// 返回状态判断</div><div class="line">axios.interceptors.response.use((res) =&gt; &#123;</div><div class="line">    //console.log(res)</div><div class="line">    return res</div><div class="line">&#125;, (error) =&gt; &#123;</div><div class="line">    return Promise.reject(error)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * 备注：也可以使用fetch</div><div class="line"> * </div><div class="line"> */</div><div class="line"></div><div class="line">//封装获取数据</div><div class="line">export const oGet = (url, params) =&gt; &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        axios.get(url, params)</div><div class="line">            .then(res =&gt; &#123;</div><div class="line">                resolve(res.data)</div><div class="line">            &#125;, err =&gt; &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;).catch(err =&gt; &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;;</div><div class="line">//封装发送数据</div><div class="line">export const oPost = (url, params) =&gt; &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        axios.post(url, params)</div><div class="line">            .then(res =&gt; &#123;</div><div class="line">                resolve(res.data)</div><div class="line">            &#125;, err =&gt; &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;).catch(err =&gt; &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line">//封装更新数据</div><div class="line">export const oUpdate = (url ,param,params) =&gt; &#123;</div><div class="line">    return new Promise((resolve , reject) =&gt; &#123;</div><div class="line">        axios.patch(url ,param, params)</div><div class="line">            .then(res =&gt; &#123;</div><div class="line">                resolve(res.data)</div><div class="line">            &#125;, err =&gt; &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;).catch(err =&gt; &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line">//封装删除数据</div><div class="line">export const oRemove = (url , params) =&gt; &#123;</div><div class="line">    return new Promise((resolve,reject) =&gt; &#123;</div><div class="line">        axios.delete(url,params)</div><div class="line">            .then(res =&gt; &#123;</div><div class="line">                resolve(res.data)</div><div class="line">            &#125;,err =&gt; &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;).catch(err =&gt; &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">   //此处是本地接口，你可在本公司局域网内使用 </div><div class="line"></div><div class="line">   //获取用户数据</div><div class="line">    _get () &#123;</div><div class="line">        return oGet(&apos;http://192.168.1.190/api/v1/accounts&apos;);</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    //新建用户</div><div class="line">    _post (params) &#123;</div><div class="line">        return oPost(&apos;http://192.168.1.190/api/v1/accounts&apos;,params);</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    //更新用户数据</div><div class="line">    _update (param,params) &#123;</div><div class="line">        return oUpdate(&apos;http://192.168.1.190/api/v1/accounts&apos;+&apos;?ids=&apos;+param, params);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    //删除单个用户</div><div class="line">    _remove(user)&#123;</div><div class="line">        var userid = user.id;</div><div class="line">        return oRemove(&apos;http://192.168.1.190/api/v1/accounts/&apos;+ userid);</div><div class="line">        </div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    //批量删除</div><div class="line">    _removes()&#123;</div><div class="line">        var ids = [];</div><div class="line">        $.each(this.selected, (i, user) =&gt; &#123;</div><div class="line">            ids.push(user.id);</div><div class="line">        &#125;);</div><div class="line">        ids = ids.join(&quot;,&quot;);</div><div class="line">        return oRemove(&apos;http://192.168.1.190/api/v1/accounts/&apos;+ids);</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>截图效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4155235-480a8c378f33e691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br><img src="http://upload-images.jianshu.io/upload_images/4155235-23e2daf6c1a9cae4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br><img src="http://upload-images.jianshu.io/upload_images/4155235-c6f831189ea0b8e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br><img src="http://upload-images.jianshu.io/upload_images/4155235-daf4cbd8523f1ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br><img src="http://upload-images.jianshu.io/upload_images/4155235-fb187bf0f83228ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p>
<p>如果有帮助，请不要吝啬，给个‘star’，就是对我的鼓励！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/sky-xsk/axios-elementui-</div></pre></td></tr></table></figure></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;axios-elementui增删改查小例子，代码见github,给加个星星：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;https://github.com/sky-xsk/axios-elementui-&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我用的是公司内部提供的api，所以不在公司内部，是看不到效果的，最主要的还是对源码的参考！&lt;br&gt;放心我会附上图片效果的!&lt;br&gt; 之前使用vue-reource写的，并且没有封装，这个例子用的是es6里的promise进行的封装，单独抽取出api接口；&lt;br&gt;代码如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="vue2.0" scheme="http://sky-xsk.github.io/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性进阶（8）</title>
    <link href="http://sky-xsk.github.io/2017/09/06/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%888%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/09/06/es6语法特性进阶（8）/</id>
    <published>2017-09-05T16:42:31.000Z</published>
    <updated>2017-09-05T08:49:30.915Z</updated>
    
    <content type="html"><![CDATA[<p><b>Babel</b></p>
<p>到目前2017年为止，也不是所有的浏览器都支持ES6的特性。<br>所以我们需要把ES6转换成ES5的代码，就要用到所谓的转码器。Babel就是目前使用最广泛的把ES6代码转换成ES5及以前代码的转码器。<br>有了babel我们就可以放心的使用ES6的最新的语法，而不用担心浏览器不支持了！！！<br>为了方便使用，我直接使用webstorm的filewatcher功能<br><a id="more"></a><br><b>安装Babel</b><br>首先要保证电脑上已经安装了npm<br>使用如下命令就可以安装babel安装(我们这里使用的是全局安装)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g babel-cli</div></pre></td></tr></table></figure></p>
<p><b>    安·babel-present-env</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-preset-env --save-dev</div></pre></td></tr></table></figure></p>
<p><b>自动转换为es5代码</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">js文件中的es6代码会自动转换为es5代码</div></pre></td></tr></table></figure>
<p><b>Moudle</b><br>JavaScript 采用 “共享一切” 的代码加载方式是该语言中最令人迷惑且容易出错的方面之一。<br>其它语言使用包（package）的概念来定义代码的作用范围，然而在 ECMAScript 6 之前，每个 JavaScript 文件中定义的内容都由全局作用域共享。<br>当 web 应用变得复杂并需要书写更多的 JavaScript 代码时，上述加载方式会出现命名冲突或安全方面的问题。<br>ECMAScript 6 的目标之一就是解决作用域的问题并将 JavaScript 应用中的代码整理得更有条理，于是模块应运而生。<br>很不幸的是：目前，所有的浏览器都还不能支持ES6的模块。只能通过第三方的工具转成ES5的代码;</p>
<p><b>什么是模块</b><br>模块是指采取不同于现有加载方式的 JavaScript 文件（与 script 这种传统的加载模式相对）。这种方式很有必要，因为它和 script 使用不同的语义：<br>模块中的代码自动运行在严格模式下，并无任何办法修改为非严格模式。<br>模块中的顶级（top level）变量不会被添加到全局作用域中。它们只存在于各自的模块中的顶级作用域。<br>模块顶级作用域中的 this 为 undefined 。<br>模块不允许存在 HTML 式的注释（JavaScript 历史悠久的遗留特性）。<br>模块必须输出可被模块外部代码使用的相关内容。<br>一个模块可以引入另外的模块。</p>
<p><b>导出模块</b><br>可以使用 export 关键字来对外暴露模块中的部分代码。<br>​一般情况下，可以在任何变量，函数或类声明之前添加这个关键字来输出它们，<br>看下面的代码:<br>声明一个文件：a.js 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 输出变量</div><div class="line">export var color = &quot;red&quot;;</div><div class="line">export let name = &quot;Nicholas&quot;;</div><div class="line">export const magicNumber = 7;</div><div class="line">// 输出函数</div><div class="line">export function sum(num1, num2) &#123;</div><div class="line">    return num1 + num1;</div><div class="line">&#125;</div><div class="line">// 输出类</div><div class="line">export class Rectangle &#123;</div><div class="line"></div><div class="line">    constructor(length, width) &#123;</div><div class="line"></div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 该函数没有使用export关键字   所以该函数是模块私有的。也就是说只能在当前文件访问，出了这个文件就访问不到</div><div class="line">function subtract(num1, num2) &#123;</div><div class="line">    return num1 - num2;</div><div class="line">&#125;</div><div class="line">// 定义一个函数...</div><div class="line">function multiply(num1, num2) &#123;</div><div class="line">    return num1 * num2;</div><div class="line">&#125;</div><div class="line">// 可以把这个函数的引用导出。  和导出函数是一样的。</div><div class="line">export &#123; multiply &#125;;</div></pre></td></tr></table></figure>
<p>注意：在上面的代码中，除了exprot关键字，其他和我们以前的代码没有任何不同。</p>
<p><b>引入模块</b><br>一旦有了导出内容的模块，则可以在另一个模块中使用import关键字来获取他们。<br>引入模块的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &#123; identifier1, identifier2 &#125; from &quot;./a.js&quot;;</div></pre></td></tr></table></figure></p>
<p>import 之后的花括号表示从模块中引入的绑定。from 关键字表示从哪个模块引入这些绑定。模块由一个包含模块路径的字符串表示（称为模块指示符，module sepcifier）;</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;Babel&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;到目前2017年为止，也不是所有的浏览器都支持ES6的特性。&lt;br&gt;所以我们需要把ES6转换成ES5的代码，就要用到所谓的转码器。Babel就是目前使用最广泛的把ES6代码转换成ES5及以前代码的转码器。&lt;br&gt;有了babel我们就可以放心的使用ES6的最新的语法，而不用担心浏览器不支持了！！！&lt;br&gt;为了方便使用，我直接使用webstorm的filewatcher功能&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性进阶（7）</title>
    <link href="http://sky-xsk.github.io/2017/09/06/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%887%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/09/06/es6语法特性进阶（7）/</id>
    <published>2017-09-05T16:24:40.000Z</published>
    <updated>2017-09-05T08:42:42.755Z</updated>
    
    <content type="html"><![CDATA[<p><b>类</b><br>和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。<br>这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。<br>尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。<br><a id="more"></a><br><b>ES5之前的模拟的类</b><br>在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function PersonType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">PersonType.prototype.sayName = function() &#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;;</div><div class="line">let person = new PersonType(&quot;Nicholas&quot;);</div><div class="line">person.sayName();   // 输出 &quot;Nicholas&quot;</div><div class="line">console.log(person instanceof PersonType);  // true</div><div class="line">console.log(person instanceof Object);      // true</div></pre></td></tr></table></figure></p>
<p>前面的PersonType我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。</p>
<p><b>ES6中基本的类声明</b><br>在ES6直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//class关键字必须是小写。   后面就是跟的类名</div><div class="line">class PersonClass &#123;</div><div class="line">    // 等效于 PersonType 构造函数。</div><div class="line">    constructor(name) &#123;  //这个表示类的构造函数。constuctor也是关键字必须小写。</div><div class="line">        this.name = name;  //创建属性。  也叫当前类型的自有属性。</div><div class="line">    &#125; </div><div class="line">    // 等效于 PersonType.prototype.sayName.   这里的sayName使用了我们前面的简写的方式。</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let person = new PersonClass(&quot;Nicholas&quot;);</div><div class="line"></div><div class="line">person.sayName();   // 输出 &quot;Nicholas&quot;</div><div class="line">console.log(person instanceof PersonClass);     // true</div><div class="line">console.log(person instanceof Object);          // true</div><div class="line">console.log(typeof PersonClass);                    // &quot;function&quot;</div><div class="line">console.log(typeof PersonClass.prototype.sayName);  // &quot;function&quot;</div></pre></td></tr></table></figure>
<p>1.自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议  尽可能的将所有自有属性创建在构造函数中，这样当查找属性时可以做到一目了然。<br>2.类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。<br>虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记</p>
<p>1.类声明和函数定义不同，类的声明是不会被提升的。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。<br>2.类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。<br>3.所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。<br>4.所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。<br>5.不使用 new 来调用类构造函数会抛出错误。也就是  必须使用new 类()  的方式使用<br>6.试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的）</p>
<p><b>匿名类表达式</b><br>函数有函数表达式，类也有类表达式。<br>类表达式的功能和前面的类的声明是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let PersonClass = class &#123;</div><div class="line">    // 等效于 PersonType 构造函数</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    // 等效于 PersonType.prototype.sayName</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let person = new PersonClass(&quot;Nicholas&quot;);</div><div class="line">person.sayName();   // 输出 &quot;Nicholas&quot;</div><div class="line">console.log(person instanceof PersonClass);     // true</div><div class="line">console.log(person instanceof Object);          // true</div><div class="line">console.log(typeof PersonClass);                    // &quot;function&quot;</div><div class="line">console.log(typeof PersonClass.prototype.sayName);  // &quot;function&quot;</div></pre></td></tr></table></figure>
<p><b>具名类表达式</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let PersonClass = class PersonClass2&#123;</div><div class="line">    // 等效于 PersonType 构造函数</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    // 等效于 PersonType.prototype.sayName</div><div class="line"></div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意：具名类表达式中PersonClass2这个类名只能在类的内部访问到，在外面是访问不到的.</p>
<p><b>作为一等公民的类型</b><br>在JavaScript中，函数是作为一等公民存在的。(也叫一等函数)。</p>
<p>类也是一等公民。<br>类可以作为参数传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function createObject(classDef) &#123;</div><div class="line">    return new classDef();</div><div class="line">&#125;</div><div class="line"></div><div class="line">let obj = createObject(class &#123;</div><div class="line">    sayHi() &#123;</div><div class="line">        console.log(&quot;Hi!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">obj.sayHi();        // &quot;Hi!&quot;</div></pre></td></tr></table></figure></p>
<p>立即调用类构造函数，创建单例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let person = new class &#123;</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;(&quot;Nicholas&quot;);</div><div class="line">person.sayName();       // &quot;Nicholas&quot;</div></pre></td></tr></table></figure></p>
<p><b>动态计算类成员的命名</b><br>类的成员，也可以像我们前面的对象的属性一样可以动态计算.(  使用[ ] 来计算)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let methodName = &quot;sayName&quot;;</div><div class="line">class PersonClass &#123;</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    [methodName]() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let me = new PersonClass(&quot;Nicholas&quot;);</div><div class="line">me.sayName();           // &quot;Nicholas&quot;</div></pre></td></tr></table></figure></p>
<p><b>静态成员</b><br>在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function PersonType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">// 静态方法。  直接添加到构造方法上。  (其实是把构造函数当做一个普通的对象来用。)</div><div class="line">PersonType.create = function(name) &#123;</div><div class="line">    return new PersonType(name);</div><div class="line">&#125;;</div><div class="line">// 实例方法</div><div class="line">PersonType.prototype.sayName = function() &#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;;</div><div class="line">var person = PersonType.create(&quot;Nicholas&quot;);</div></pre></td></tr></table></figure></p>
<p>在上面的create方法在其他语言中一般都是作为静态方法来使用的。<br>下面高能，请注意：<br>ECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class PersonClass &#123;</div><div class="line">    // 等效于 PersonType 构造函数</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    // 等效于 PersonType.prototype.sayName</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">    // 等效于 PersonType.create。</div><div class="line">    static create(name) &#123;</div><div class="line">        return new PersonClass(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let person = PersonClass.create(&quot;Nicholas&quot;);</div></pre></td></tr></table></figure>
<p>注意：静态成员通过实例对象不能访问，只能通过类名访问！！！<br>通过和ES5模拟静态方法的例子你应该知道为啥了吧</p>
<p><b>ES6中的继承</b><br>在ES6之前要完成继承，需要写很多的代码。看下面的继承的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Father(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">&#125;</div><div class="line">Father.prototype.sayName = function () &#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line">function Son(name,age) &#123;</div><div class="line">    Father.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">Son.prototype = new Father();</div><div class="line">Son.prototype.constructor = Son;</div><div class="line">Son.prototype.sayAge = function () &#123;</div><div class="line">    console.log(this.age);</div><div class="line">&#125;</div><div class="line">​</div><div class="line">var son1 = new Son(&quot;儿子&quot;, 20);</div><div class="line">son1.sayAge();  //20</div><div class="line">son1.sayName(); //儿子</div></pre></td></tr></table></figure></p>
<p><b>继承的基本写法</b><br>如果在ES6通过类的方式完成继承就简单了很多。<br>需要用到一个新的关键字：extends</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Father&#123;</div><div class="line">       constructor(name)&#123;</div><div class="line">           this.name = name;</div><div class="line">       &#125;</div><div class="line">       sayName()&#123;</div><div class="line">           console.log(this.name);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   class Son extends Father&#123;  //extents后面跟表示要继承的类型</div><div class="line">       constructor(name, age)&#123;</div><div class="line">           super(name);  //相当于以前的：Father.call(this, name);</div><div class="line">           this.age = age;</div><div class="line">       &#125;</div><div class="line">       //子类独有的方法</div><div class="line">       sayAge()&#123;</div><div class="line"></div><div class="line">           console.log(this.age);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   var son1 = new Son(&quot;李四&quot;, 30);</div><div class="line">   son1.sayAge();</div><div class="line">   son1.sayName();</div><div class="line">   console.log(son1 instanceof Son);  // true</div><div class="line">   console.log(son1 instanceof Father);  //true</div></pre></td></tr></table></figure>
<p>这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。<br>关于super的使用，有几点需要注意：<br>你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。<br>你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。<br>在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。</p>
<p><b>在子类中屏蔽父类的方法</b></p>
<p>如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Father&#123;</div><div class="line">       constructor(name)&#123;</div><div class="line">           this.name = name;</div><div class="line">       &#125;</div><div class="line">       sayName()&#123;</div><div class="line">           console.log(this.name);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   class Son extends Father&#123;  //extents后面跟表示要继承的类型</div><div class="line">       constructor(name, age)&#123;</div><div class="line">           super(name);  //相当于以前的：Father.call(this, name);</div><div class="line">           this.age = age;</div><div class="line">       &#125;</div><div class="line">       //子类独有的方法</div><div class="line">       sayAge()&#123;</div><div class="line">           console.log(this.age);</div><div class="line">       &#125;</div><div class="line">       //子类中的方法会屏蔽到父类中的同名方法。</div><div class="line">       sayName()&#123;</div><div class="line">           super.syaName();  //调用被覆盖的父类中的方法。 </div><div class="line">           console.log(&quot;我是子类的方法，我屏蔽了父类：&quot; + name);</div><div class="line"></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   var son1 = new Son(&quot;李四&quot;, 30);</div><div class="line">   son1.sayAge();</div><div class="line">   son1.sayName();</div></pre></td></tr></table></figure></p>
<p>如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。</p>
<p>注意：<br>如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法<br>普通方法调用需要使用super.父类的方法()  来调用。</p>
<p><b>静态方法也可以继承</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Father&#123;</div><div class="line">    static foo()&#123;</div><div class="line">        console.log(&quot;我是父类的静态方法&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Son extends Father&#123;</div><div class="line">&#125;</div><div class="line">Son.foo(); //子类也继承了父类的静态方法。  这种方式调用和直接通过父类名调用时一样的。</div><div class="line">​</div></pre></td></tr></table></figure></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script>

</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;类&lt;/b&gt;&lt;br&gt;和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。&lt;br&gt;这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。&lt;br&gt;尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性进阶（6）</title>
    <link href="http://sky-xsk.github.io/2017/09/06/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%886%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/09/06/es6语法特性进阶（6）/</id>
    <published>2017-09-05T16:06:21.000Z</published>
    <updated>2017-09-05T08:25:13.778Z</updated>
    
    <content type="html"><![CDATA[<p><b>Map数据结构</b><br>ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。<br>​键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。<br>​这和使用对象属性做为值的方法大相径庭，因为  对象的属性会被强制转换为字符串类型。<br><a id="more"></a><br><b>创建Map对象和Map的基本的存取操作</b><br>1.Map创建也是使用Map构造函数<br>2.向Map存储键值对使用set(key, value);方法<br>3.可以使用get(key),来获取指定key对应的value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&quot;a&quot;, &quot;lisi&quot;);</div><div class="line">map.set(&quot;b&quot;, &quot;zhangsan&quot;);</div><div class="line">map.set(&quot;b&quot;, &quot;zhangsan222&quot;);  // 第二次添加，新的value会替换掉旧的</div><div class="line">console.log(map.get(&quot;a&quot;));</div><div class="line">console.log(map.get(&quot;b&quot;));   //zhangsan222</div><div class="line">console.log(map.get(&quot;c&quot;)); //undefined.如果key不存在，则返回undefined</div><div class="line">console.log(map.size); //2</div></pre></td></tr></table></figure></p>
<p><b>Map与Set类似的3个方法</b><br>has(key) - 判断给定的 key 是否在 map 中存在<br>delete(key) - 移除 map 中的 key 及对应的值<br>clear() - 移除 map 中所有的键值对</p>
<p><b>初始化Map</b><br>创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。<br>也就是传入的实际是一个二维数组！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//map接受一个二维数组</div><div class="line">var map = new Map([</div><div class="line">    //每一个数组中，第一个是是map的可以，第二个是map的value。如果只有第一个，则值是undefined</div><div class="line">    [&quot;name&quot;, &quot;lisi&quot;],  </div><div class="line">    [&quot;age&quot;, 20],</div><div class="line">    [&quot;sex&quot;, &quot;nan&quot;]</div><div class="line">]);</div><div class="line">console.log(map.size);</div><div class="line">console.log(map.get(&quot;name&quot;))</div></pre></td></tr></table></figure></p>
<p><b>Map的forEach方法</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var map = new Map([</div><div class="line">    [&quot;name&quot;, &quot;李四&quot;],</div><div class="line">    [&quot;age&quot;, 20],</div><div class="line">    [&quot;sex&quot;, &quot;nan&quot;]</div><div class="line">]);</div><div class="line">/*</div><div class="line">    回调函数有函数：</div><div class="line">    参数1：键值对的value</div><div class="line">    参数2：键值对的key</div><div class="line">    参数3：map对象本身</div><div class="line">    */</div><div class="line">map.forEach(function (value, key, ownMap) &#123;</div><div class="line">    console.log(`key=$&#123;key&#125; ,vlue=$&#123;value&#125;`);</div><div class="line">    console.log(this);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><b>迭代器(iterator)和for…of循环</b><br>循环问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</div><div class="line">for (var i = 0, len = colors.length; i &lt; len; i++) &#123;</div><div class="line">    console.log(colors[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码写起来简单，但是实际使用的过程中，我们需要自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。<br>迭代器就是为了解决这个问题的。</p>
<p><b>什么是迭代器</b><br>迭代器是一个对象<br>迭代器提供一个方法next() 这个方式总是能够返回迭代到的对象。<br>next返回的对象中，至少有两个属性：done 是一个boolean值(表示数据是否迭代完)。  value：具体的数据(迭代到的具体数据)<br>​    迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。</p>
<p>​    若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。</p>
<p>我们可以用ES5之前的知识手动创建一个迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function createIterator(items) &#123;</div><div class="line">var i = 0;</div><div class="line">return &#123;</div><div class="line">    next: function() &#123;</div><div class="line">        var done = (i &gt;= items.length);</div><div class="line">        var value = !done ? items[i++] : undefined;</div><div class="line">        return &#123;</div><div class="line">            done: done,</div><div class="line">            value: value</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">//创建一个可以在指定数组上面迭代的迭代器对象。</div><div class="line">var iterator = createIterator([1, 2, 3]);</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 1, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 2, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 3, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</div><div class="line">// for all further calls</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure>
<p>从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。</p>
<p>幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。</p>
<p><b>生成器函数</b><br>生成器函数就是返回迭代器的函数！<br>生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。<br>看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//生成器函数。  注意中间的 * 不能丢</div><div class="line">function * createIterator() &#123;</div><div class="line">    //每个yield的后面的值表示我们迭代到的值。   yield也定义了我们迭代的顺序。</div><div class="line">    yield 3;</div><div class="line">    yield 4;</div><div class="line">    yield 2;</div><div class="line">&#125;</div><div class="line">var it = createIterator();</div><div class="line">console.log(it.next().value);   // 2</div><div class="line">console.log(it.next().value);   // 4</div><div class="line">console.log(it.next().value);   // 2</div><div class="line">console.log(it.next().value);  //undefined</div></pre></td></tr></table></figure>
<p>迭代器函数也是函数，所以他可以像正常的函数一样调用，但是迭代器生成器函数会自动返回一个迭代器对象。<br>每调用一次迭代器的next方法，如果碰到 yield 都会返回一个迭代到的一个对象，然后停止执行，直到下次调用next方法，会从上次停止的地方继续执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。</div><div class="line">function *createIterator(items) &#123;</div><div class="line">    for (let i = 0; i &lt; items.length; i++) &#123;</div><div class="line">    //每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 &#123;value : items[i], done : true&#125;</div><div class="line">        yield items[i]; </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let iterator = createIterator([1, 2, 3]);</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 1, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 2, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 3, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</div><div class="line">// 进一步调用</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure>
<p>注意：<br>yield 关键字只能 直接用在生成器内部 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。</p>
<p><b>生成器函数表达式</b><br>你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let createIterator = function *(items) &#123;</div><div class="line">    for (let i = 0; i &lt; items.length; i++) &#123;</div><div class="line">        yield items[i];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let iterator = createIterator([1, 2, 3]);</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 1, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 2, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 3, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</div><div class="line">// 进一步调用</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure></p>
<p>注意：无法使用箭头函数来创建生成器。</p>
<p><b>可迭代类型和for-of迭代循环</b><br>迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。<br>​与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性（方法）的对象。<br>​该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 for-of 循环而设计的。</p>
<p>换句话说，默认情况下只有 数组、set、Map和字符串才可以使用迭代器去迭代。   (也就可以使用for…of了)<br>for…of循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！<br>使用  for…of  迭代数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;];</div><div class="line">for(var item of arr)&#123;</div><div class="line">    console.log(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用  for…of  迭代Set:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var set = new Set([&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;]);</div><div class="line">for(var item of set)&#123;</div><div class="line">    console.log(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用  for…of  迭代Map：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var map = new Map([[&quot;name&quot;, &quot;lisi&quot;],[&quot;sex&quot;, &quot;男&quot;],[&quot;age&quot;, 20]]);</div><div class="line">map.set(&quot;aaa&quot;, &quot;bbb&quot;)</div><div class="line">for(var item of map)&#123;</div><div class="line">    console.log(item);  //注意：这里迭代到的是由key和value组成的数组。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用for … of迭代字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = &quot;abcd&quot;;</div><div class="line">for(let c of s)&#123;</div><div class="line">    console.log(c)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：for…of  只能迭代可以迭代的对象，对于非可迭代对象使用for…of会抛出异常</p>
<p>说明：以数组为例。<br>​    for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。<br>​    如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。</p>
<p><b>访问可迭代类型的默认迭代器</b><br>Symbol.iterator是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let s = &quot;abcd&quot;;</div><div class="line">let it = s[Symbol.iterator]();  //调用字符串的Symbol.iterator方法</div><div class="line">console.log(it.next());  //返回迭代器迭代到的第一个对象</div></pre></td></tr></table></figure></p>
<p>因为Symbol可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function isIterable(object) &#123;</div><div class="line">    return typeof object[Symbol.iterator] === &quot;function&quot;;</div><div class="line">&#125;</div><div class="line">console.log(isIterable([1, 2, 3]));     // true</div><div class="line">console.log(isIterable(&quot;Hello&quot;));       // true</div><div class="line">console.log(isIterable(new Map()));     // true</div><div class="line">console.log(isIterable(new Set()));     // true</div><div class="line">console.log(isIterable(&#123;&quot;name&quot;:&quot;李四&quot;&#125;)); // false。普通对象不可迭代</div></pre></td></tr></table></figure></p>
<p><b>开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let collection = &#123;</div><div class="line">    items: [],</div><div class="line">    *[Symbol.iterator]() &#123;</div><div class="line">        for (let item of this.items) &#123;</div><div class="line">            yield item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">collection.items.push(1);</div><div class="line">collection.items.push(2);</div><div class="line">collection.items.push(3);</div><div class="line">for (let x of collection) &#123;</div><div class="line">    console.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;Map数据结构&lt;/b&gt;&lt;br&gt;ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。&lt;br&gt;​键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。&lt;br&gt;​这和使用对象属性做为值的方法大相径庭，因为  对象的属性会被强制转换为字符串类型。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性进阶（5）</title>
    <link href="http://sky-xsk.github.io/2017/09/05/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%885%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/09/05/es6语法特性进阶（5）/</id>
    <published>2017-09-05T15:57:11.000Z</published>
    <updated>2017-09-05T08:06:29.550Z</updated>
    
    <content type="html"><![CDATA[<p><b>Set数据结构</b><br>JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。<br>​因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。<br>Set是类似数组的一种结构，可以存储数据，与数组的区别主要是  Set中的元素不能重复，而数组中的元素可以重复。<br>一句话总结：Set类型是一个包含无重复元素的有序列表<br><a id="more"></a><br><b>创建Set和并添加元素</b><br>Set本身是一个构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> //创建Set数据结构对象。</div><div class="line">var s = new Set();</div><div class="line">//调用set对象的add方法，向set中添加元素</div><div class="line">s.add(&quot;a&quot;);</div><div class="line">s.add(&quot;c&quot;);</div><div class="line">s.add(&quot;b&quot;);</div><div class="line">//set的size属性可以获取set中元素的个数</div><div class="line">console.log(s.size)</div></pre></td></tr></table></figure></p>
<p><b>    Set中不能添加重复元素</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var s = new Set();</div><div class="line">s.add(&quot;a&quot;);</div><div class="line">s.add(&quot;c&quot;);</div><div class="line">s.add(&quot;b&quot;);</div><div class="line">s.add(&quot;a&quot;);  //重复，所以添加失败。注意这个地方并不会保存。</div><div class="line">console.log(s.size); // 长度是3</div></pre></td></tr></table></figure></p>
<p>看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> var s = new Set();</div><div class="line">s.add(5);</div><div class="line">s.add(&quot;5&quot;);</div><div class="line">console.log(s.size); // 长度是2</div></pre></td></tr></table></figure>
<p>在上面的代码中，数字5和字符串5都会添加成功。为什么呢？<br>Set是使用什么机制来判断两个元素是否相等的呢？<br>是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var s = new Set();</div><div class="line">s.add(+0);</div><div class="line">s.add(-0);  //重复添加不进去</div><div class="line">s.add(NaN);</div><div class="line">s.add(NaN); //重复添加不进去</div><div class="line">s.add([]);</div><div class="line">s.add([]);  //两个空数组不相等，所以可以添加进去</div><div class="line">s.add(&#123;&#125;);</div><div class="line">s.add(&#123;&#125;);  // 两个空对象也不重复，所以也可以添加进去</div><div class="line">console.log(s.size); // 长度是6</div></pre></td></tr></table></figure>
<p><b>使用数组初始化Set</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。</div><div class="line">var s = new Set([2, 3, 2, 2, 4]);</div><div class="line">console.log(s.size)</div></pre></td></tr></table></figure>
<p><b>使用Set的  has()  方法可以判断一个值是否在这个set中。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let set = new Set();</div><div class="line">set.add(5);</div><div class="line">set.add(&quot;5&quot;);</div><div class="line">console.log(set.has(5));    // true</div><div class="line">console.log(set.has(6));    // false</div></pre></td></tr></table></figure></p>
<p><b>移除Set中的元素</b><br>delete(要删除的值)   ：删除单个值<br>clear()：清空所有的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let set = new Set();</div><div class="line">set.add(5);</div><div class="line">set.add(&quot;5&quot;);</div><div class="line">console.log(set.has(5));    // true</div><div class="line">set.delete(5);</div><div class="line">console.log(set.has(5));    // false</div><div class="line">console.log(set.size);      // 1</div><div class="line">set.clear();</div><div class="line">console.log(set.has(&quot;5&quot;));  // false</div><div class="line">console.log(set.size);      // 0</div></pre></td></tr></table></figure></p>
<p><b>遍历Set</b><br>数组有个方法forEach可以遍历数组。<br>Set也有forEach可以遍历Set。<br>使用Set的forEach遍历时的回调函数有三个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function (value, key, ownerSet)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数1：遍历到的元素的值<br>参数2：对set集合来说，参数2的值和参数1的值是完全一样的。<br>参数3：这个 set 自己</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let set = new Set([&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, 9]);</div><div class="line">set.forEach(function (v, k, s) &#123;</div><div class="line">    console.log(v + &quot;   &quot; + (v === k) + &quot;  &quot; + (s === set));   // 永远是true</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><b>for…of也可以遍历set</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(var v of set)&#123;</div><div class="line">    console.log(v)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><b>将Set转换为数组</b><br>将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。<br>把Set转换为数组使用前面讲到的扩展运算符也很容易<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, 3, 3, 4, 5]),</div><div class="line">arr = [...set];  //使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此处对set并没有什么影响</div><div class="line">console.log(arr);             // [1,2,3,4,5]</div></pre></td></tr></table></figure></p>
<p>这种情况在需要去数组中重复元素的时候非常好用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function eliminateDuplicates(items) &#123;</div><div class="line">    return [...new Set(items)];</div><div class="line">&#125;</div><div class="line">let numbers = [1, 2, 3, 3, 3, 4, 5, 5, 2, 1, 1],</div><div class="line">    //返回的是新的没有重复元素的数组。</div><div class="line">    noDuplicates = eliminateDuplicates(numbers);</div><div class="line">console.log(noDuplicates);      // [1,2,3,4,5]</div></pre></td></tr></table></figure></p>
<p>Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;Set数据结构&lt;/b&gt;&lt;br&gt;JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。&lt;br&gt;​因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。&lt;br&gt;Set是类似数组的一种结构，可以存储数据，与数组的区别主要是  Set中的元素不能重复，而数组中的元素可以重复。&lt;br&gt;一句话总结：Set类型是一个包含无重复元素的有序列表&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性进阶（4）</title>
    <link href="http://sky-xsk.github.io/2017/09/05/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%884%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/09/05/es6语法特性进阶（4）/</id>
    <published>2017-09-05T15:43:50.000Z</published>
    <updated>2017-09-05T07:56:57.364Z</updated>
    
    <content type="html"><![CDATA[<p><b>数组解构基本语法</b><br>数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如：<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">let [ firstColor, secondColor ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(secondColor);       // &quot;green&quot;</div></pre></td></tr></table></figure>
<p>如果只想取数组中的某一项，则可以不用命名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">//只取数组中的第三项。</div><div class="line">let [ , , thirdColor ] = colors;</div><div class="line">console.log(thirdColor);        // &quot;blue&quot;</div></pre></td></tr></table></figure>
<p><b>解构表达式</b><br>你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],</div><div class="line">    firstColor = &quot;black&quot;,</div><div class="line">    secondColor = &quot;purple&quot;;</div><div class="line">[ firstColor, secondColor ] = colors;  //可以不用加括号。当然添加也不犯法</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(secondColor);       // &quot;green&quot;</div></pre></td></tr></table></figure></p>
<p>数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> let a = 3,</div><div class="line">    b = 4,</div><div class="line">    temp;</div><div class="line">temp = a;</div><div class="line">a = b;</div><div class="line">b = temp;</div><div class="line">console.log(a);</div><div class="line">console.log(b)</div></pre></td></tr></table></figure>
<p>那么在ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> let a = 3,</div><div class="line">b = 4;</div><div class="line">//左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。</div><div class="line">[a, b] = [b, a];</div><div class="line">console.log(a);</div><div class="line">console.log(b)</div></pre></td></tr></table></figure>
<p><b>新的基本类型：Symbol</b></p>
<p>以前我们有5种基本数据类型：Number、String、Boolean、Null、Undefined<br>ES6新增了一种新的数据类型：Symbol<br>在ES5之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。</p>
<p><b>创建Symbol</b><br>Symbol在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是Symbol却不可以使用字面量的是形式去创建。<br>我们可以使用symbol全局函数来创建Symbol。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let firstName = Symbol();   //创建一个Symbol</div><div class="line">let person = &#123;&#125;;</div><div class="line">person[firstName] = &quot;张三&quot;;</div><div class="line">console.log(person[firstName]);     // &quot;张三&quot;</div></pre></td></tr></table></figure></p>
<p>说明：上面的代码中，firstName 作为 symbol 类型被创建并赋值给 person 对象以作其属性。每次访问这个属性时必须使用该 symbol 。<br>在创建Symbol的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> var s1 = Symbol(&quot;abc&quot;);</div><div class="line">var s2 = Symbol(&quot;abc&quot;);</div><div class="line">console.log(s1 == s2); //false</div></pre></td></tr></table></figure>
<p>注意：任意两个Symbol都不会相等，即使创建他们的时候使用了相同的参数。</p>
<p><b>识别Symbol</b><br>既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let symbol = Symbol();</div><div class="line">console.log(typeof symbol);         // &quot;symbol&quot;</div></pre></td></tr></table></figure></p>
<p><b>Symbol作为属性名</b><br>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var mySymbol = Symbol();</div><div class="line">// 第一种写法</div><div class="line">var a = &#123;&#125;;</div><div class="line">a[mySymbol] = &apos;Hello!&apos;;</div><div class="line">// 第二种写法</div><div class="line">var a = &#123;</div><div class="line">    [mySymbol]: &apos;Hello!&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上两种写法都是相同的结果<br>注意：<br>symbol作为对象的属性的时候，只能使用 [ ] 去访问，不能使用点去访问。<br>symbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of时无法遍历到这个symbol属性的。</p>
<p><b>Symbol属性名的遍历</b><br>Symbol 作为属性名，该属性不会出现在for…in循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。<br>看下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">var a = Symbol(&apos;a&apos;);</div><div class="line">var b = Symbol(&apos;b&apos;);</div><div class="line">obj[a] = &apos;Hello&apos;;</div><div class="line">obj[b] = &apos;World&apos;;</div><div class="line">// 返回obj对象所有Symbol类型的属性名组成的数组。</div><div class="line">var objectSymbols = Object.getOwnPropertySymbols(obj);</div><div class="line">console.log(objectSymbols)  //[Symbol(a), Symbol(b)]</div></pre></td></tr></table></figure>
<p>看下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">var foo = Symbol(&quot;foo&quot;);</div><div class="line">obj[foo] = &quot;lisi&quot;;</div><div class="line">for (var i in obj) &#123;</div><div class="line">  console.log(i); // 无输出 。   因为遍历不到Symbol型的属性 </div><div class="line">&#125;</div><div class="line">Object.getOwnPropertyNames(obj);// []   只能拿到非Symbol类型的属性</div><div class="line">Object.getOwnPropertySymbols(obj) //[Symbol(foo)]</div></pre></td></tr></table></figure>
<p>还有一个新API可以拿到所有类型的属性，包括常规和Symbol型的。<br>Reflect.ownKeys</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">  [Symbol(&apos;my_key&apos;)]: 1,</div><div class="line">  enum: 2,</div><div class="line">  nonEnum: 3</div><div class="line">&#125;;</div><div class="line">Reflect.ownKeys(obj);//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</div></pre></td></tr></table></figure>
<p>说明：<br>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<p><b>Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)</b><br>一、Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个sybol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//第一次搜不到，则新创建一个返回，并在全局环境(window)中注册</div><div class="line">var a = Symbol.for(&quot;foo&quot;);</div><div class="line">//第二次搜到上次创建的</div><div class="line">var b = Symbol.for(&quot;foo&quot;);</div><div class="line">console.log(a === b);  //因为两次搜到的是同一个Symbol，所以此处是true</div></pre></td></tr></table></figure></p>
<p>Symbol.for()和Symbol()都可以创建Symbol类型的数据。<br>二者区别：<br>Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。<br>Symbol()则不会有搜索的过程，每次都是一个全新的不同的symbol，而且也不会向全局环境中注册。<br>看下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = Symbol(&quot;foo&quot;);</div><div class="line">var b = Symbol.for(&quot;foo&quot;);</div><div class="line">console.log(a == b); //false</div></pre></td></tr></table></figure>
<p>二、Symbol.keyFor(symbol):返回一个已经注册的symbol的”key”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = Symbol(&quot;foo&quot;);</div><div class="line">var b = Symbol.for(&quot;foo&quot;);</div><div class="line">console.log(Symbol.keyFor(a)); // undefined.   因为a没有想全局环境中登记，所以是undefinded</div><div class="line">console.log(Symbol.keyFor(b)); // foo</div></pre></td></tr></table></figure></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;数组解构基本语法&lt;/b&gt;&lt;br&gt;数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如：&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性进阶（3）</title>
    <link href="http://sky-xsk.github.io/2017/09/05/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%883%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/09/05/es6语法特性进阶（3）/</id>
    <published>2017-09-05T15:27:08.000Z</published>
    <updated>2017-09-05T07:43:15.369Z</updated>
    
    <content type="html"><![CDATA[<p><b>字符串功能的增强</b><br>在以前在字符串中查找字符串的时候，都是使用indexOf方法。<br>ES6新增了三个方法来查找字符串。<br><a id="more"></a><br>includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。<br>startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。<br>endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。<br>每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。<br>当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 则是字符串搜索的结束位置。<br>若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。<br>实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var msg = &quot;Hello world!&quot;;</div><div class="line">console.log(msg.startsWith(&quot;Hello&quot;));       // true</div><div class="line">console.log(msg.endsWith(&quot;!&quot;));             // true</div><div class="line">console.log(msg.includes(&quot;o&quot;));             // true</div><div class="line">console.log(msg.startsWith(&quot;o&quot;));           // false</div><div class="line">console.log(msg.endsWith(&quot;world!&quot;));        // true</div><div class="line">console.log(msg.includes(&quot;x&quot;));             // false</div><div class="line">console.log(msg.startsWith(&quot;o&quot;, 4));        // true</div><div class="line">console.log(msg.endsWith(&quot;o&quot;, 8));          // true</div><div class="line">console.log(msg.includes(&quot;o&quot;, 8));          // false</div></pre></td></tr></table></figure>
<p><b>repeat方法</b><br>ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(&quot;x&quot;.repeat(3));         // &quot;xxx&quot;</div><div class="line">console.log(&quot;hello&quot;.repeat(2));     // &quot;hellohello&quot;</div><div class="line">console.log(&quot;abc&quot;.repeat(4));       // &quot;abcabcabcabc&quot;</div></pre></td></tr></table></figure></p>
<p><b>字符串模板字面量</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应：</div><div class="line">多行字符串  针对多行字符串的形式概念（formal concept）。</div><div class="line">基本的字符串格式化  将字符串中的变量置换为值的能力。</div><div class="line">转义 HTML  能将字符串进行转义并使其安全地插入到 HTML 的能力。</div><div class="line">模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。</div></pre></td></tr></table></figure></p>
<p><b>基本语法</b><br>使用一对反引号 ``(tab正上方的按键)来表示模板字面量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let message = `Hello world!`;   //使用模板字面量创建了一个字符串</div><div class="line">console.log(message);               // &quot;Hello world!&quot;</div><div class="line">console.log(typeof message);        // &quot;string&quot;</div><div class="line">console.log(message.length);        // 12</div></pre></td></tr></table></figure></p>
<p>注意：如果模板字符串中使用到了反引号，则应该转义。但是单双引号不需要转义</p>
<p><b>多行字符串</b><br>在ES5之前JavaScript是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是bug的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> var s = &quot;abc \</div><div class="line">aaaaaa&quot;;</div><div class="line">console.log(s); //但是输出的结果中不包括换行</div></pre></td></tr></table></figure></p>
<p>但是在ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var s = `abc</div><div class="line">aaaaa</div><div class="line">dsalfja</div><div class="line">dfadfja`;</div><div class="line">console.log(s);</div></pre></td></tr></table></figure></p>
<p>但是要注意：  反引号中的所有空格和缩进都是有效字符。</p>
<p><b>字符串置换</b><br>置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。<br>语法：${变量名、表达式、任意运算、方法调用等}<br>可以嵌入任何有效的JavaScript代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name = &quot;李四&quot;;</div><div class="line">var msg = `欢迎你$&#123;name&#125;同学`;</div><div class="line">console.log(msg)</div></pre></td></tr></table></figure>
<p><b>什么是模板标签?</b><br>模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let message = myTag`Hello world`;</div></pre></td></tr></table></figure>
<p>在上面的代码中，myTag就是模板标签。<br>myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。</p>
<p><b>定义模板标签</b></p>
<p>一个标签仅代表一个函数，他接受需要处理的模板字面量。<br>标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。<br>函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。<br>标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let name = &apos;张三&apos;,</div><div class="line">    age = 20,</div><div class="line">    message = show`我来给大家介绍$&#123;name&#125;的年龄是$&#123;age&#125;.`;</div><div class="line">/*</div><div class="line">    应该定义一个函数show：</div><div class="line">    参数1：一个字符串数组。在本例中包含三个元素。</div><div class="line">            0:&quot;我来给大家介绍&quot;</div><div class="line">            1:&quot;的年龄是&quot;</div><div class="line">            2:&quot;.&quot;</div><div class="line">    参数2和参数3：表示需要置换的字符串的值。  </div><div class="line">    */</div><div class="line">function show(stringArr, value1, value2) &#123;</div><div class="line">    console.log(stringArr); //</div><div class="line">    console.log(value1);  // 张三</div><div class="line">    console.log(value2);  // 20</div><div class="line">    return &quot;abc&quot;;</div><div class="line">&#125;</div><div class="line">console.log(message); //abc</div></pre></td></tr></table></figure>
<p>为了简化书写，一般把Value1和Value2写成剩余字符串的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function show(stringArr, ...values)&#123;&#125;</div></pre></td></tr></table></figure>
<p><b>解构的实用</b><br>在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let options = &#123;</div><div class="line">    repeat: true,</div><div class="line">    save: false</div><div class="line">&#125;;</div><div class="line">// 从对象中提取数据</div><div class="line">let repeat = options.repeat,</div><div class="line">save = options.save;</div></pre></td></tr></table></figure></p>
<p>这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个数据结构。<br>这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。</p>
<p><b>对象解构的基本形式</b></p>
<p>对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">//这里就相当于声明了两个变量： type = node.type;  name:node.name</div><div class="line">let &#123; type, name &#125; = node;</div><div class="line">console.log(type);      // &quot;Identifier&quot;</div><div class="line">console.log(name);      // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>在上面的结构中必须要初始化。否则会出现语法错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 语法错误！</div><div class="line">var &#123; type, name &#125;;</div><div class="line">// 语法错误！</div><div class="line">let &#123; type, name &#125;;</div><div class="line">// 语法错误！</div><div class="line">const &#123; type, name &#125;;</div></pre></td></tr></table></figure>
<p><b>解构赋值表达式</b><br>如果声明的变量想改变他们的值，也可以使用解构表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;,</div><div class="line">type = &quot;Literal&quot;,</div><div class="line">name = 5;</div><div class="line">//注意：此处必须要在圆括号内才能使用解构表达式</div><div class="line">(&#123;type, name&#125; = node);</div><div class="line">console.log(type);      // &quot;Identifier&quot;</div><div class="line">console.log(name);      // &quot;foo&quot;&quot;</div></pre></td></tr></table></figure></p>
<p><b>对象解构时的默认值</b><br>如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">//因为node中没有叫value的属性，所以valued的值将会是undefined</div><div class="line">let &#123; type, name, value &#125; = node;</div><div class="line">console.log(type);      // &quot;Identifier&quot;</div><div class="line">console.log(name);      // &quot;foo&quot;</div><div class="line">console.log(value);     // undefined</div></pre></td></tr></table></figure></p>
<p>不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">//手动添加value的默认值为3</div><div class="line">let &#123; type, name, value = 3&#125; = node;</div><div class="line">console.log(type);      // &quot;Identifier&quot;</div><div class="line">console.log(name);      // &quot;foo&quot;</div><div class="line">console.log(value);     // 3</div></pre></td></tr></table></figure></p>
<p><b>赋值给不同的变量名</b><br>在前面的操作中，都是把对象的属性值，赋值给同名变量。<br>其实也可以赋值给不同名的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">// localType才是要定义的新的变量。  type是node的属性</div><div class="line">let &#123;type: localType, name: localName&#125; = node;</div><div class="line">console.log(localType);     // &quot;Identifier&quot;</div><div class="line">console.log(localName);     // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>注意：冒号后面才是要定义的新的变量，这个和我们的对象字面量不太一样！<br>这个地方也可以使用默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123; type: localType, name: localName = &quot;bar&quot; &#125; = node;</div><div class="line">console.log(localType);     // &quot;Identifier&quot;</div><div class="line">console.log(localName);     // &quot;bar&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;字符串功能的增强&lt;/b&gt;&lt;br&gt;在以前在字符串中查找字符串的时候，都是使用indexOf方法。&lt;br&gt;ES6新增了三个方法来查找字符串。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性进阶（2）</title>
    <link href="http://sky-xsk.github.io/2017/09/05/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/09/05/es6语法特性进阶（2）/</id>
    <published>2017-09-05T15:11:43.000Z</published>
    <updated>2017-09-05T07:45:04.080Z</updated>
    
    <content type="html"><![CDATA[<p><b>对象功能的扩展</b><br>在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。<br>ECMAScript 6 给对象的各个方面，从简单的语法扩展到操作与交互，都做了改进。<br><a id="more"></a><br><b>对象类别</b><br>ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括：<br>普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。<br>特异对象（exotic object）的某些内部行为和默认的有所差异。<br>标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。<br>内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。</p>
<p><b>简写的属性初始化</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age) &#123;</div><div class="line">    //返回一个对象：属性名和参数名相同。</div><div class="line">    return &#123;</div><div class="line">        name:name,</div><div class="line">        age:age</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(createPerson(&quot;lisi&quot;, 30)); // &#123;name:&quot;lisi&quot;, age:30&#125;</div><div class="line">//在ES6中，上面的写法可以简化成如下形式</div></pre></td></tr></table></figure>
<p>在ES6中，上面的写法可以简化成如下的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age) &#123;</div><div class="line">    //返回一个对象：属性名和参数名相同。</div><div class="line">    return &#123;</div><div class="line">        name,  //当对象属性名和本地变量名相同时，可以省略冒号和值</div><div class="line">        age</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(createPerson(&quot;lisi&quot;, 30)); // &#123;name:&quot;lisi&quot;, age:30&#125;</div></pre></td></tr></table></figure>
<p>当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。<br>该项扩展使得对象字面量的初始化变得简明的同时也消除了命名错误。对象属性被同名变量赋值在 JavaScript 中是一种普遍的编程模式，所以这项扩展的添加非常受欢迎。</p>
<p><b>简写的方法声明</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name:&apos;lisi&apos;,</div><div class="line">    sayHell:function () &#123;</div><div class="line">        console.log(&quot;我的名字是：&quot; + this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">person.sayHell()</div></pre></td></tr></table></figure>
<p>在ES6中，上面的写法可以简化成如下的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> var person = &#123;</div><div class="line">    name:&apos;李四&apos;,</div><div class="line">    sayHell() &#123;</div><div class="line">        console.log(&quot;我的名字是：&quot; + this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">person.sayHell();</div></pre></td></tr></table></figure>
<p>省略了冒号和function看起来更简洁;</p>
<p><b>在字面量中动态计算属性名</b><br>在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过  对象.[变量名]  的方式去访问。而且这种动态计算属性名的方式 在字面量中 是无法使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var p = &#123;</div><div class="line">    name : &apos;李四&apos;,</div><div class="line">    age : 20</div><div class="line">&#125;</div><div class="line">var attName = &apos;name&apos;;</div><div class="line">console.log(p[attName]) //这里 attName表示的是一个变量名。</div></pre></td></tr></table></figure>
<p>而下面的方式使用时没有办法访问到attName这个变量的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var attName = &apos;name&apos;;</div><div class="line">var p = &#123;</div><div class="line">    attName : &apos;李四&apos;,  // 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。</div><div class="line">    age : 20</div><div class="line">&#125;</div><div class="line">console.log(p[attName])  // undefined</div></pre></td></tr></table></figure></p>
<p>在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> var attName = &apos;name&apos;;</div><div class="line">var p = &#123;</div><div class="line">    [attName] : &apos;李四&apos;,  // 引用了变量attName。相当于添加了一个属性名为name的属性</div><div class="line">    age : 20</div><div class="line">&#125;</div><div class="line">console.log(p[attName])  // 李四</div></pre></td></tr></table></figure>
<p><b>新增的方法 Object.is()</b></p>
<p>ECMAScript 从第五版开始避免在 Object.prototype 上添加新的全局函数或方法，转而去考虑具体的对象类型如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。<br>ECMAScript 6 在全局 Object 上添加了几个新的方法来轻松地完成一些特定任务。<br>在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（）或严格比较操作符（=）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。<br>ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">console.log(+0 == -0);              // true</div><div class="line">console.log(+0 === -0);             // true</div><div class="line">console.log(Object.is(+0, -0));     // false</div><div class="line">console.log(NaN == NaN);            // false</div><div class="line">console.log(NaN === NaN);           // false</div><div class="line">console.log(Object.is(NaN, NaN));   // true</div><div class="line">console.log(5 == 5);                // true</div><div class="line">console.log(5 == &quot;5&quot;);              // true</div><div class="line">console.log(5 === 5);               // true</div><div class="line">console.log(5 === &quot;5&quot;);             // false</div><div class="line">console.log(Object.is(5, 5));       // true</div><div class="line">console.log(Object.is(5, &quot;5&quot;));     // false</div></pre></td></tr></table></figure>
<p>很多情况下 Object.is() 的表现和 = 是相同的。它们之间的区别是前者 认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 = 取决于代码的实际情况。</p>
<p><b>Object.assign()</b><br>使用assign主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。<br>assing可以把一个对象的属性和方法完整的转copy到另外一个对象中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> var p = &#123;</div><div class="line">    name : &quot;lisi&quot;</div><div class="line">    age : 20,</div><div class="line">    friends : [&apos;张三&apos;, &apos;李四&apos;]</div><div class="line">&#125;</div><div class="line">var p1 = &#123;&#125;;</div><div class="line">Object.assign(p1, p); //则p1中就有了与p相同的属性和方法.  p1是接受者，p是提供者</div><div class="line">console.log(p1);</div><div class="line">//这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）</div><div class="line">console.log(p1.friends == p.friends);  //true   p1和p的friends同事指向了同一个数组。</div><div class="line">p.friends.push(&quot;王五&quot;);</div><div class="line">console.log(p1.friends); //[&apos;张三&apos;, &apos;李四&apos;, &apos;王五&apos;]</div></pre></td></tr></table></figure></p>
<p>assign方法可以接受任意多的提供者。意味着后面提供者的同名属性和覆盖前面提供者的属性值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> var p = &#123;</div><div class="line">    name : &quot;lisi&quot;,</div><div class="line">    age : 20,</div><div class="line">    friends : [&apos;张三&apos;, &apos;李四&apos;]</div><div class="line">&#125;</div><div class="line">var p1 = &#123;</div><div class="line">    name : &apos;zs&apos;,</div><div class="line">&#125;</div><div class="line">var p2 = &#123;&#125;;</div><div class="line"></div><div class="line">Object.assign(p2, p, p1); //p和p1都是提供者</div><div class="line">console.log(p2.name); // zs</div></pre></td></tr></table></figure>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;对象功能的扩展&lt;/b&gt;&lt;br&gt;在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。&lt;br&gt;ECMAScript 6 给对象的各个方面，从简单的语法扩展到操作与交互，都做了改进。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性进阶（1）</title>
    <link href="http://sky-xsk.github.io/2017/09/05/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/09/05/es6语法特性进阶（1）/</id>
    <published>2017-09-05T14:51:58.000Z</published>
    <updated>2017-09-05T07:11:30.257Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 6 最有意思的部分之一就是箭头函数。正如其名，箭头函数由 “箭头”（=&gt;）这种新的语法来定义。<br>其实在别的语言中早就有了这种语法结构，不过他们叫拉姆达表达式。<br><a id="more"></a><br><b>箭头函数语法</b><br>箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var sum = (num1, num2) =&gt;&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">console.log(sum(3, 4));</div><div class="line">//前面的箭头函数等同于下面的传统函数</div><div class="line">var add = function (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line"></div><div class="line">&#125;</div><div class="line">console.log(add(2, 4))</div></pre></td></tr></table></figure>
<p>如果函数体内只有一行代码，则包裹函数体的 大括号 ({ })完全可以省略。如果有return，return关键字也可以省略。<br>如果函数体内有多条语句，则 {} 不能省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> var sum = (num1, num2) =&gt; num1 + num2;</div><div class="line">console.log(sum(5, 4));</div><div class="line">//前面的箭头函数等同于下面的传统函数</div><div class="line">var add = function (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">console.log(add(2, 4));</div><div class="line">//如果这一行代码是没有返回值的，则方法的返回自也是undefined</div><div class="line">var foo = (num1, num2) =&gt; console.log(&quot;aaa&quot;);</div><div class="line">console.log(foo(3,4));  //这个地方的返回值就是undefined</div></pre></td></tr></table></figure>
<p>如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。当然如果不传入参数也不可以省略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var foo = a=&gt; a+3; //因为只有一个参数，所以()可以省略</div><div class="line"> console.log(foo(4)); // 7</div></pre></td></tr></table></figure>
<p>如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个小括号 ()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> var foo = ()=&gt;(&#123;name:&quot;lisi&quot;, age:30&#125;);</div><div class="line">console.log(foo());</div><div class="line">//等同于下面的；</div><div class="line">var foo1 = ()=&gt;&#123;</div><div class="line">    return &#123;</div><div class="line">        name:&quot;lisi&quot;,</div><div class="line">        age : 30</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><b>使用箭头函数实现函数自执行</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> var person = (name =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">            name: name,</div><div class="line">            age: 30</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">)(&quot;zs&quot;);</div><div class="line">console.log(person);</div></pre></td></tr></table></figure>
<p><b>箭头函数中无this绑定(No this Binding)</b><br>在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。</p>
<p>在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式</p>
<p>箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> var PageHandler = &#123;</div><div class="line">    id: &quot;123456&quot;,</div><div class="line">    init: function () &#123;</div><div class="line">        document.addEventListener(&quot;click&quot;,</div><div class="line">            event =&gt; this.doSomething(event.type), false); // 在此处this的和init函数内的this相同。</div><div class="line">    &#125;,</div><div class="line">    doSomething: function (type) &#123;</div><div class="line">        console.log(&quot;Handling &quot; + type + &quot; for &quot; + this.id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">PageHandler.init();</div></pre></td></tr></table></figure>
<p>看下面的一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> var p = &#123;</div><div class="line">    foo:()=&gt;console.log(this)   //此处this为window</div><div class="line">&#125;</div><div class="line">p.foo();  //输出为 window对象。   并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。</div><div class="line">//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。</div></pre></td></tr></table></figure>
<p>说明：<br>1.箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。<br>2.由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。</p>
<p><b>无arguments</b><br>虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。</div><div class="line">    return ()=&gt;arguments[0]; //箭头函数的返回值是foo函数的第一个参数</div><div class="line">&#125;</div><div class="line">var arrow = foo(4, 5);</div><div class="line">console.log(arrow()); // 4</div><div class="line">`</div></pre></td></tr></table></figure>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMAScript 6 最有意思的部分之一就是箭头函数。正如其名，箭头函数由 “箭头”（=&amp;gt;）这种新的语法来定义。&lt;br&gt;其实在别的语言中早就有了这种语法结构，不过他们叫拉姆达表达式。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6语法特性学习</title>
    <link href="http://sky-xsk.github.io/2017/09/05/es6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sky-xsk.github.io/2017/09/05/es6语法特性学习/</id>
    <published>2017-09-05T14:24:59.000Z</published>
    <updated>2017-09-05T06:54:46.121Z</updated>
    
    <content type="html"><![CDATA[<p><b>ES6简介</b><br>    历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。<br>​    由于ES6是在2015年发布的，所以也叫ES2015。<br>    以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、….<br><a id="more"></a><br><b>块级作用域绑定</b><br>在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。<br>块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：<br>1.函数内部<br>2.在代码块（即 {  }）内部<br>块级作用域是很多类C语言的工作机制，ECMAScript 6 引入块级声明的目的是增强 JavaScript 的灵活性，同时又能与其它编程语言保持一致。<br><b>let声明</b><br>使用let声明变量的语法和使用var声明的语法是一样的。但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let a = 10;</div><div class="line">if(a &gt; 5)&#123;</div><div class="line">    console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错）</div><div class="line">    let b = 20;</div><div class="line">    console.log(b);</div><div class="line">&#125;</div><div class="line">console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错）</div></pre></td></tr></table></figure></p>
<p>注意：<br>1.用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问<br>2.用let声明的变量也没有声明提前这一特性。<br>3.在同一个块中，let声明的变量也不能重复声明。<br>4.在声明变量的时候尽量使用let，慢慢的抛弃var<br><b>const声明</b><br>在  ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。<br>const声明的常量和let变量一样也是具有块级作用域的特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = 20;</div><div class="line">if (true) &#123;</div><div class="line">    const b = 20;</div><div class="line">    b = 30;  //错误! 常量不能重新赋值</div><div class="line">    const c; //错误！ 常量声明的同时必须赋值。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：<br>1.const的特性除了声明的是常量为，其他与let一样。<br>2.在let和const声明前的这段区域称之为暂存性死区（The Temporal Dead Zone —TDZ)。<br>3.使用let和const声明的变量和常量不再是window的属性。  也就是说通过window.a是无法访问到的。<br><b>循环中的块级绑定</b><br>使用var声明的循环变量在循环结束后仍然可以访问到。   使用let声明的循环变量，在循环结束之后会立即销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 3; i++)&#123; // 循环结束之后会立即销毁 i</div><div class="line">       console.log(i);</div><div class="line">   &#125;</div><div class="line">console.log(i);  //此处无法访问到 i 。</div></pre></td></tr></table></figure></p>
<p><b>循环中的函数</b><br>看下面的代码，是输出10个10，而不是0，1，2，…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    funcs.push(function () &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">funcs.forEach(function (func) &#123;</div><div class="line">    func();     // 输出 &quot;10&quot; 共10次</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>解决办法需要使用函数的自执行特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    funcs.push((function(value) &#123;</div><div class="line">        return function() &#123;</div><div class="line">            console.log(value);</div><div class="line">        &#125;</div><div class="line">    &#125;(i)));</div><div class="line">&#125;</div><div class="line">funcs.forEach(function(func) &#123;</div><div class="line">    func();     // 输出 0，1，2 ... 9</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for … of循环中也适用;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">    funcs.push(function () &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">funcs.forEach(function (func) &#123;</div><div class="line">    func();     // 输出 0，1，2 ... 9</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>说明：<br>let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。</p>
<p><b>函数的新增特性</b></p>
<p>JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout, callback) &#123;</div><div class="line">    timeout = timeout || 2000;</div><div class="line">    callback = callback || function() &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000.<br>ES6从语言层面面上增加了 默认值的 支持。看下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。</div><div class="line"></div><div class="line">function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123;</div><div class="line">    // 其余代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><b>默认参数对 arguments 对象的影响</b><br>在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> function foo(a, b) &#123;</div><div class="line">    //非严格模式</div><div class="line">    console.log(arguments[0] === a); //true</div><div class="line">    console.log(arguments[1] === b); //true</div><div class="line">    a = 10;</div><div class="line">    b = 20;</div><div class="line">    console.log(arguments[0] === a); //true</div><div class="line">    console.log(arguments[1] === b); //true</div><div class="line">&#125;</div><div class="line">foo(1, 2);</div></pre></td></tr></table></figure>
<p>在ES5的严格模式下，arguments只反映参数的初始值，而不再反映命名参数的变化！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo(a, b) &#123;</div><div class="line">    //严格模式</div><div class="line">    &quot;use strict&quot;</div><div class="line">    console.log(arguments[0] === a); //true</div><div class="line">    console.log(arguments[1] === b); //true</div><div class="line">    a = 10;</div><div class="line">    b = 20;</div><div class="line">    console.log(arguments[0] === a); //false。  修改a的值不会影响到arguments[0]的值</div><div class="line">    console.log(arguments[1] === b); //false</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(1, 2);</div></pre></td></tr></table></figure>
<p>当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> function foo(a, b = 30) &#123;</div><div class="line">    console.log(arguments[0] === a); //true</div><div class="line">    console.log(arguments[1] === b); //true</div><div class="line">    a = 10;</div><div class="line">    b = 20;</div><div class="line">    console.log(arguments[0]  === a); //false。  由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。</div><div class="line">    console.log(arguments[1] === b); //false。  b使用了默认值，所以表现的和严格模式一样。</div><div class="line">&#125;</div><div class="line">foo(1, 2);</div></pre></td></tr></table></figure>
<p>注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。</p>
<p><b>默认参数表达式 (Default Parameter Expressions)</b><br>参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function getValue() &#123;</div><div class="line">        return 5;</div><div class="line">&#125;</div><div class="line">function add(first, second = getValue()) &#123; //表示使用getValue这个函数的返回值作为second的默认值。</div><div class="line">    return first + second;</div><div class="line">&#125;</div><div class="line">console.log(add(1, 1));     // 2.  调用add函数的时候，传入了第二个参数，则以传入的参数为准。</div><div class="line">console.log(add(1));        // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。</div></pre></td></tr></table></figure></p>
<p>有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> let value = 5;</div><div class="line">function getValue() &#123;</div><div class="line">    return value++;</div><div class="line">&#125;</div><div class="line">function add(first, second = getValue()) &#123;  //</div><div class="line">    return first + second;</div><div class="line">&#125;</div><div class="line">console.log(add(1, 1));     // 2</div><div class="line">console.log(add(1));        // 6</div><div class="line">console.log(add(1));        // 7</div><div class="line">console.log(add(1));        // 8</div></pre></td></tr></table></figure>
<p>由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function add(first, second = first) &#123;  // 使用第一个参数作为第二个参数的默认值</div><div class="line">    return first + second;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function add(first = second, second)) &#123;  // 这种写法是错误的</div><div class="line">    return first + second;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><b>未命名参数问题</b><br>Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是略显繁琐。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> function foo(a) &#123;</div><div class="line">    console.log(a);</div><div class="line">    console.log(arguments[1])  //取得传入的多余的参数。</div><div class="line">&#125;</div><div class="line">foo(2, 3);</div></pre></td></tr></table></figure></p>
<p>ES6，提供了一种更加优雅处理未命名参数的问题：剩余参数( Rest Parameters )<br>语法：function a(a, … b){ }<br>剩余参数使用三个点( … )和变量名来表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a, ...b) &#123;</div><div class="line">    console.log(a);</div><div class="line">    console.log(b instanceof Array);  //true  .多余的参数都被放入了b中。b其实就是一个数组。</div><div class="line">&#125;</div><div class="line">foo(2, 3, 4, 6);</div></pre></td></tr></table></figure>
<p>注意：<br>1.函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。<br>2.虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。<br>3.剩余参数是在函数声明的时候出现的。</p>
<p><b>函数中的扩展运算符</b></p>
<p>例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用applay方法。<br>看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let values = [25, 50, 75, 100]  </div><div class="line">console.log(Math.max.apply(Math, values));  // 100</div></pre></td></tr></table></figure>
<p>上面这种方法虽然可行，但是总是不是那么直观。<br>使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> let values = [25, 50, 75, 100]</div><div class="line">console.log(Math.max(...values));  //使用扩展运算符。相当于拆解了数组了。</div><div class="line">console.log(Math.max(...values, 200));  //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。</div></pre></td></tr></table></figure>
<p>注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。<br>1.剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面<br>2.扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script>




</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;ES6简介&lt;/b&gt;&lt;br&gt;    历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。&lt;br&gt;​    由于ES6是在2015年发布的，所以也叫ES2015。&lt;br&gt;    以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、….&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title> 理解js中apply和call </title>
    <link href="http://sky-xsk.github.io/2017/08/05/%E7%90%86%E8%A7%A3js%E4%B8%ADapply%E5%92%8Ccall/"/>
    <id>http://sky-xsk.github.io/2017/08/05/理解js中apply和call/</id>
    <published>2017-08-04T16:27:45.000Z</published>
    <updated>2017-08-04T08:47:45.836Z</updated>
    
    <content type="html"><![CDATA[<p><b>call与apply的方法定义</b><br>call方法:<br>function.call(thisObj[, arg1[, arg2[, [,…argN]]]]);<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：<br>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 this指定的新对象。<br><a id="more"></a></p>
<p>apply方法：<br>function.apply(thisObj[, argArray])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。 </p>
<p>apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。</p>
<p>call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 </p>
<p>实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function jia(a,b)  </div><div class="line">&#123;  </div><div class="line">    alert(a+b);  </div><div class="line">&#125;  </div><div class="line">function jian(a,b)  </div><div class="line">&#123;  </div><div class="line">    alert(a-b);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">jia.call(jian,3,1);</div></pre></td></tr></table></figure>
<p>看最后一句代码jia.call(sub,3,1); 其实等同于 jia(3,1);结果为4;<br>还可以这样写 jia.call(this,3,1);  结果也是一样的； 这个例子中的意思就是用  jia来替换 jian方法；<br>如过把它用apply写的话就是jia.apply(this,[3,1]);  或者 jia.apply(jian,[3,1]);；<br>这里要注意的是，js 中的函数其实是对象，函数名是对 Function 对象的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Animal()&#123;    </div><div class="line">    this.name = &quot;dog&quot;;    </div><div class="line">    this.showName = function()&#123;    </div><div class="line">        alert(this.name);    </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">  </div><div class="line">function Cat()&#123;    </div><div class="line">     this.name = &quot;Cat&quot;;    </div><div class="line">&#125;    </div><div class="line">   </div><div class="line">var animal = new Animal();     //new新的实例</div><div class="line">var cat = new Cat();    </div><div class="line">animal.showName.call(cat,&quot;,&quot;);    </div><div class="line">animal.showName.apply(cat,[]);</div></pre></td></tr></table></figure>
<p>这段代码的意思其实就是，把 animal 的方法放到cat上执行，原来是没有showName的方法的，现在可以用了！输出的结果为‘Cat’；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Animal(name)&#123;      </div><div class="line">    this.name = name;      </div><div class="line">    this.showName = function()&#123;      </div><div class="line">        alert(this.name);      </div><div class="line">    &#125;      </div><div class="line">&#125;      </div><div class="line">function Cat(name)&#123;    </div><div class="line">    Animal.call(this, name);    </div><div class="line">&#125;      </div><div class="line">var cat = new Cat(&quot;Cat&quot;);     </div><div class="line">cat.showName();</div></pre></td></tr></table></figure>
<p> Animal.call(this) 的意思就是使用 Animal对象代替this对象，Cat对象就能够直接调用Animal的方法以及属性了,这里实现的是方法的继承；cat继承Animal里面的name；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Class10()  </div><div class="line">&#123;  </div><div class="line">    this.showSub = function(a,b)  </div><div class="line">    &#123;  </div><div class="line">        alert(a-b);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">function Class11()  </div><div class="line">&#123;  </div><div class="line">    this.showAdd = function(a,b)  </div><div class="line">    &#123;  </div><div class="line">        alert(a+b);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">function Class2()  </div><div class="line">&#123;  </div><div class="line">    Class10.call(this);  </div><div class="line">    Class11.call(this);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，使用两个 call 就实现多重继承了，当然，js的继承还有其他方法，例如使用原型链，只是在此说明call 的用法。说了call ，当然还有 apply，这两个方法基本上是一个意思，区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments;</p>
<blockquote>
<p>apply的一些其他巧妙用法(借鉴)</p>
</blockquote>
<p>（1）Math.max 可以实现得到数组中最大的一项：<br>因为Math.max不支持Math.max([param1,param2])也就是数组，但是它支持Math.max(param1,param2…)，所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样就轻易的可以得到一个数组中的最大项（apply会将一个数组转换为一个参数接一个参数的方式传递给方法）<br>这块在调用的时候第一个参数给了null，这是因为没有对象去调用这个方法，我只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个null过去。<br>用这种方法也可以实现得到数组中的最小项：Math.min.apply(null,array)</p>
<p>（2）Array.prototype.push可以实现两个数组的合并<br>同样push方法没有提供push一个数组，但是它提供了push(param1,param2…paramN)，同样也可以用apply来转换一下这个数组，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.var arr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);</div><div class="line">2.var arr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;);</div><div class="line">3.Array.prototype.push.apply(arr1,arr2);</div></pre></td></tr></table></figure></p>
<p>得到合并后数组的长度，因为push就是返回一个数组的长度也可以这样理解，arr1调用了push方法，参数是通过apply将数组转换为参数列表的集合</p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;call与apply的方法定义&lt;/b&gt;&lt;br&gt;call方法:&lt;br&gt;function.call(thisObj[, arg1[, arg2[, [,…argN]]]]);&lt;br&gt;定义：调用一个对象的一个方法，以另一个对象替换当前对象。&lt;br&gt;说明：&lt;br&gt;call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 this指定的新对象。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://sky-xsk.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title> 穷忙的人生（转自阮一峰）</title>
    <link href="http://sky-xsk.github.io/2017/08/04/%E7%A9%B7%E5%BF%99%E7%9A%84%E4%BA%BA%E7%94%9F%EF%BC%88%E8%BD%AC%E8%87%AA%E9%98%AE%E4%B8%80%E5%B3%B0%EF%BC%89/"/>
    <id>http://sky-xsk.github.io/2017/08/04/穷忙的人生（转自阮一峰）/</id>
    <published>2017-08-04T15:18:08.000Z</published>
    <updated>2017-08-04T07:26:36.702Z</updated>
    
    <content type="html"><![CDATA[<p>香港曾经有一档电视真人秀，叫做《穷富翁大作战》，专门邀请富人体验穷人的生活。<br>有一期节目的主人公是田北辰。他的父亲田元灏是香港纺织界的头面人物，人称”一代裤王”。他本科毕业于康奈尔大学电子工程专业，又去读了哈佛大学 MBA，回到香港后创办了服装品牌 G2000 和 U2，是那种很努力的”富二代”。<br><a id="more"></a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4155235-6c6dc4f70e55df35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>他崇尚自由竞争和人生奋斗，座右铭是”如果你今天对自己满意，明天就会被淘汰”，一直宣扬 “如果你有斗志，弱者也可以变成强者。”<br><img src="http://upload-images.jianshu.io/upload_images/4155235-87dfa9d6ed0b73bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>但是，参加了这次电视节目以后，他的观点发生了180度转变，对着电视镜头公开说：<br>“这个社会在极严厉地惩罚，那些没条件读书的人。穷人一輩子都不可能变有钱人。在強弱悬殊的情况下，只有弱者越弱，越來越慘！”</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4155235-82bbefbea69a7a95.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>2、<br>田北辰为什么改变观点，认为穷人不可能翻身呢？原来，节目组请他<a href="http://cj.sina.com.cn/article/detail/2381596945/91594?column=china&amp;ch=9" target="_blank" rel="external">体验</a>了两天清洁工的生活，薪资是每小时25港币，每天的生活费只有50港币，住在只有1.6平方米的”笼屋”，月租1350港币。<br>所谓”笼屋”，外面看着像衣橱，门一拉开，里面只能放下一张床，关上门四面全挨着木板墙，东西都挂在墙上。就是这种条件，房产中介还称它为”豪华笼屋”，因为还有600港币的更低档，就是在马桶上放一块木板睡人。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-0b2f657336418664.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/4155235-5b974a7ed221ca49.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上班时间是早上五点，地铁头班车还没开，只能坐夜宵巴士，车费是13港币，田北辰惊呼：”每天生活费只有50港币，这怎么坐得起！”<br><img src="http://upload-images.jianshu.io/upload_images/4155235-28df3561779792e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>开始工作后，好不容易熬到中午吃饭，但只有15元的预算，大部分的饭要20元，他最后只能坐在街边的楼梯上，就着白开水嚼干粮。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-e842e157bf49db11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/4155235-6dff51c3be14b856.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>吃完了，还要抓紧时间躺在花坛上休息一会。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-2b1f2088e0367a4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>做满9个小时，就可以下班了。但是，真正的清洁工为了养家户口，还要去做夜班，一天在外近17个小时，只能睡5、6个小时。田北辰说，因为只有两天，自己才有斗志坚持下去，如果要做一个月，甚至半年，那就太绝望了！<br>“没有学历、技术的人，为了活下去，不是住笼屋就是要工作到半夜，对于他们，最重要事情是下一顿吃什么，怎么会有时间和精力去思考未来怎么发展？来来去去都在死胡同！”</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4155235-775885266363fcf6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>3、<br>每天忙于工作，干到累死，但还是很穷，只能租屋住，没有自己的积蓄，一旦停止工作或者生病在床，生活来源顿时就成问题。田北辰体验的这种人生，社会学家早就注意到了，起名为”穷忙族”，百度百科的<a href="http://baike.baidu.com/item/%E7%A9%B7%E5%BF%99%E6%97%8F/1407708" target="_blank" rel="external">定义</a>如下。<br>“穷忙族是指那些薪水不多，整日奔波劳动，却始终无法摆脱贫穷的人。最早出现于上世纪90年代的美国，指拼命工作仍然无法摆脱最低水准生活的人们。日本经济学家门仓贵史在《穷忙族》一书中，他对”穷忙族”下的定义是：每天繁忙地工作却依然不能过上富裕生活的人。”</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4155235-c0e2c39d5bc99788.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>不仅香港有”穷忙族”，内地也越来越多。举例来说，根据<a href="http://news.sina.com.cn/o/2017-04-09/doc-ifyecfnu7833937.shtml" target="_blank" rel="external">报道</a>，2016年上海送外卖最多的送餐员，是一位叫做何文妹的中年女性，至少送出了12214单。即使全年无休，每天平均也要33单，从午饭时间一直送到深夜，一刻不停。电瓶车的电瓶，一天要准备6组。车上插着两个手机，一个导航，一个接单。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-e6603e748c0f841c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这种强度的劳动，每年能有多少收入呢？每单的送餐费是8元，这就是说，何文妹一年的送餐总收入在10万元左右。扣除电瓶费、车辆维护费、通信费等等以后，净收入大概还能剩下8万多元。这是”送餐王”的收入水平，大部分送餐员的收入，应该远不如她，可能只有一半左右。<br>上海的底层劳动者，收入基本就是这种水平。他们还要用这些钱支付房租。每天下班回到家，累得就想睡觉，睁开眼就要去上班，日复一日，人生的出路在哪里？<br><img src="http://upload-images.jianshu.io/upload_images/4155235-3a71e93a31703118.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>4、<br>将来的”穷忙族”，不仅是低技能的底层劳动者，还将包括很多受过高等教育、写字楼工作的白领。年轻人如果没有家庭支持，想要靠自己的努力出人头地，会变得越来越难。因为单靠工资收入，已经不足以积累财富了。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-f72bf93cd01dbc3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>有一项<a href="https://c.m.163.com/news/a/CH66B8Q700018M4D.html?spss=newsapp&amp;spsw=1" target="_blank" rel="external">统计</a>说：<br>“1993年属于低等收入者的城里人，到了1995年有43%都能向上爬。而相比之下，2011年属于低等收入者的城里人，到了2013年只有20%摘掉最底层的帽子。一个不恰当的比喻，如果上世纪90年代算是城市穷人的黄金时代的话，那今天这种好日子已经结束了。”<br>“一方面，城里穷人越来越难走出贫困；另一方面，城里富人的位置也坐得越来越稳。1993-1995年，城里的高等收入者有64%的概率能一直当富人。而到了2011-2013年，高等收入者竟然有84%的概率能保证自己不被从富人列表中除名。”</p>
<p>上面的数字就是说，如果你是穷人，80%的概率以后你还是穷人；如果你是富人，84%的概率是以后你还是富人。一个台湾人<a href="http://mapleduh.pixnet.net/blog/post/47158492" target="_blank" rel="external">感叹</a>说：<br>“那种奴隶化的生活（长时间工作，却仅能勉强满足温饱）才是历史的常态。过去三十年社会阶层的大幅流动，是历史的不正常，现在开始回归常态。99%的我们，都面临着这种大趋势的吞噬：你的工资不变，但房价和物价却是越来越高，于是你必需花更多时间来挣钱，甚至一天做二份工，最后成为没有自己时间的奴隶。”</p>
<p>总的来看，下一代青年不太可能有上一代那么多机会。经济增长率已经开始放缓，还将继续放缓，人口增长高峰已经过去，老龄化越来越严重，老人的消费远不及年轻人。矿业、制造业、零售业、证券业……除了高科技，几乎所有行业都不会有以前那么高的增长率。上一代人赶上了中国经济起飞，还拥有依靠房地产翻身的机会，但是下一代人不会再有这样的机会。你现在买入一套房子，十年后价值翻上十倍，完全是零可能。<br>越来越多的人将会发现，即使从小就努力学习，从很好的学校毕业，后来努力工作，但迎接他们的将是”长久的低薪、难升迁的职场、高昂的物价、买不起的房子……”。尽管你很努力，待人友善，有公德心，但就是挣不到钱，只能在社会的底层挣扎。<br>5、<br>2015年，社会工作者藤田孝典调查日本的老人问题。<br>他<a href="http://www.cup.com.hk/2017/06/26/the-poor-elderly-in-japan/" target="_blank" rel="external">发现</a>，很多老人年轻时都拿过中产阶级的薪水（400万日元），但是现在已经沦落到社会的底层，过着非常困苦的生活。”七老八十还要在大热天当廉价劳工，因经济拮据而妻离子散，唯有独居烂屋，孤零零度过晚年。”<br>藤田孝典将这些老人称为”下流老人”（底层老人）。他称，日本的下流老人以后可能会达到1亿人。要知道，日本现在的总人口也只有1.27亿。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-557254feb427ad5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>下流老人有三大特征。（1）收入极低，即使政府提供补助费，也难以维持健康饮食，以及一般家庭应有的生活；（2）存款不足，老人必须提心吊胆地过活，一旦碰到突发事故或慢性病，日常已经捉襟见肘的生活，就会面临崩溃危险；（3）老无所依，子女连自己都养不起，更遑论赡养老人。日本不少老人因家庭破碎而长期独居，平日缺乏与亲朋邻里的交流，关系疏离，一旦发生意外无人照应。在晚年失去可以依靠的人，是下流老人最悲苦的特征。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-6531380cd857314c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>下流老人的根源就是，钱花光了，人还没死。日本媒体还发明了一个词”老后破产”，这就是长寿的恶梦。<br><img src="http://upload-images.jianshu.io/upload_images/4155235-bb01500f6a026ae6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>现代科技如此发达，人的寿命越来越长，可是工作又积累不了财富，于是，”清贫青年，流沙中年，下流老人”就成了大多数人必然的命运归宿。<br>感觉自己就是在穷忙，越穷越忙，越忙越穷！</p>
<blockquote>
<p><strong>穷忙族测试</strong><br>测试，你是”穷忙族”吗？<br>1、一周工作超过54小时，但是看不到前途<br>2、一年内未曾加薪<br>3、三年内未曾升职<br>4、薪水很低，到月底总是很艰难<br>5、积蓄少，无力置产<br>6、工资不低，但花钱很大手笔<br>7、收入不低，但内心没有安全感<br>以上七项，如果你有两项或者两项以上，那么BINGO!恭喜你，你属于”穷忙族”了！</p>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;香港曾经有一档电视真人秀，叫做《穷富翁大作战》，专门邀请富人体验穷人的生活。&lt;br&gt;有一期节目的主人公是田北辰。他的父亲田元灏是香港纺织界的头面人物，人称”一代裤王”。他本科毕业于康奈尔大学电子工程专业，又去读了哈佛大学 MBA，回到香港后创办了服装品牌 G2000 和 U2，是那种很努力的”富二代”。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://sky-xsk.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>火星文-正则表达式（学习）转载</title>
    <link href="http://sky-xsk.github.io/2017/07/19/%E7%81%AB%E6%98%9F%E6%96%87-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%AD%A6%E4%B9%A0%EF%BC%89%E8%BD%AC%E8%BD%BD/"/>
    <id>http://sky-xsk.github.io/2017/07/19/火星文-正则表达式（学习）转载/</id>
    <published>2017-07-19T15:50:55.000Z</published>
    <updated>2017-07-19T08:14:58.824Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个字符串是否含有某种子串、将匹配的子串做替换或者从某个字符串中取出符合某个条件的子串等。<br><a id="more"></a><br><b>正则表达式的创建方式</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> var reg = /pattern/flags</div><div class="line">// 字面量创建方式</div><div class="line">var reg = new RegExp(pattern,flags);</div><div class="line">//实例创建方式</div></pre></td></tr></table></figure></p>
<p>pattern:正则表达式<br>flags:标识(修饰符)<br>标识主要包括：<br>i 忽略大小写匹配<br>m 多行匹配，即在到达一行文本末尾时还会继续寻常下一行中是否与正则匹配的项<br>g 全局匹配 模式应用于所有字符串，而非在找到第一个匹配项时停止</p>
<p><b>字面量创建方式和构造函数创建方式的区别</b></p>
<p>字面量创建方式不能进行字符串拼接，实例创建方式可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var regParam = &apos;cm&apos;;</div><div class="line">var reg1 = new RegExp(regParam+&apos;1&apos;);</div><div class="line">var reg2 = /regParam/;</div><div class="line">console.log(reg1);  //   /cm1/</div><div class="line">console.log(reg2);  //  /regParam/</div></pre></td></tr></table></figure></p>
<p>字面量创建方式特殊含义的字符不需要转义，实例创建方式需要转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var reg1 = new RegExp(&apos;\d&apos;);  //    /d/ </div><div class="line">var reg2 = new RegExp(&apos;\\d&apos;)  //   /\d/</div><div class="line">var reg3 = /\d/;              //  /\d/</div></pre></td></tr></table></figure></p>
<p><b>元字符</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">\d : 0-9之间的任意一个数字  \d只占一个位置</div><div class="line">\w : 数字，字母 ，下划线 0-9 a-z A-Z _</div><div class="line">\s : 空格或者空白等</div><div class="line">\D : 除了\d</div><div class="line">\W : 除了\w</div><div class="line">\S : 除了\s</div><div class="line"> . : 除了\n之外的任意一个字符</div><div class="line"> \ : 转义字符</div><div class="line"> | : 或者</div><div class="line">() : 分组</div><div class="line">\n : 匹配换行符</div><div class="line">\b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 =&gt; 不占用字符串位数</div><div class="line"> ^ : 限定开始位置 =&gt; 本身不占位置</div><div class="line"> $ : 限定结束位置 =&gt; 本身不占位置</div><div class="line">[a-z] : 任意字母 []中的表示任意一个都可以</div><div class="line">[^a-z] : 非字母 []中^代表除了</div><div class="line">[abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符</div></pre></td></tr></table></figure></p>
<p><b>代表次数的量词元字符</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* : 0到多个</div><div class="line">+ : 1到多个</div><div class="line">? : 0次或1次 可有可无</div><div class="line">&#123;n&#125; : 正好n次；</div><div class="line">&#123;n,&#125; : n到多次</div><div class="line">&#123;n,m&#125; : n次到m次</div></pre></td></tr></table></figure></p>
<p>量词出现在元字符后面 如\d+，限定出现在前面的元字符的次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var str = &apos;1223334444&apos;;</div><div class="line">var reg = /\d&#123;2&#125;/g;</div><div class="line">var res = str.match(reg);</div><div class="line">console.log(res)  //[&quot;12&quot;, &quot;23&quot;, &quot;33&quot;, &quot;44&quot;, &quot;44&quot;]</div><div class="line"></div><div class="line">var str =&apos;  我是空格君  &apos;;</div><div class="line">var reg = /^\s+|\s+$/g; //匹配开头结尾空格</div><div class="line">var res = str.replace(reg,&apos;&apos;);</div><div class="line">console.log(&apos;(&apos;+res+&apos;)&apos;)  //(我是空格君)</div></pre></td></tr></table></figure></p>
<p>一般[]中的字符没有特殊含义 如+就表示+,但是像\w这样的还是有特殊含义的;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var str1 = &apos;abc&apos;;</div><div class="line">var str2 = &apos;dbc&apos;;</div><div class="line">var str3 = &apos;.bc&apos;;</div><div class="line">var reg = /[ab.]bc/; //此时的.就表示.</div><div class="line">reg.test(str1)  //true</div><div class="line">reg.test(str2)  //false</div><div class="line">reg.test(str3)  //true</div></pre></td></tr></table></figure></p>
<p>[]中，不会出现两位数;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[12]表示1或者2 不过[0-9]这样的表示0到9 [a-z]表示a到z</div><div class="line">例如:匹配从18到65年龄段所有的人</div><div class="line">var reg = /[18-65]/; // 这样写对么</div><div class="line">reg.test(&apos;50&apos;)</div><div class="line"> //Uncaught SyntaxError: Invalid regular expression: /[18-65]/: Range out of order in character class</div><div class="line">//聪明的你想可能是8-6这里不对，于是改成[16-85]似乎可以匹配16到85的年龄段的，但实际上发现这也是不靠谱的</div><div class="line"></div><div class="line">实际上我们匹配这个18-65年龄段的正则我们要拆开来匹配</div><div class="line">我们拆成3部分来匹配 18-19  20-59 60-65 </div><div class="line">reg = /(18|19)|([2-5]\d)|(6[0-5])/;</div></pre></td></tr></table></figure>
<p>()的提高优先级功能:凡是有|出现的时候，我们一定要注意是否有必要加上()来提高优先级；<br>()的分组 重复子项 (两个放到一起说);<br>分组：<br>只要正则中出现了小括号那么就会形成一份分组<br>只要有分组，exec(match)和replace中的结果就会发生改变(后边的正则方法中再说)</p>
<p>分组的引用(重复子项) :<br>只要在正则中出现了括号就会形成一个分组，我们可以通过\n (n是数字代表的是第几个分组)来引用这个分组，第一个小分组我们可以用\1来表示<br>例如：求出这个字符串’abAAbcBCCccdaACBDDabcccddddaab’中出现最多的字母,并求出出现多少次(忽略大小写)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var str = &apos;abbbbAAbcBCCccdaACBDDabcccddddaab&apos;;</div><div class="line">str = str.toLowerCase().split(&apos;&apos;).sort(function(a,b)&#123;return a.localeCompare(b)&#125;).join(&apos;&apos;);</div><div class="line">var reg = /(\w)\1+/ig;</div><div class="line">var maxStr = &apos;&apos;;</div><div class="line">var maxLen = 0;</div><div class="line">str.replace(reg,function($0,$1)&#123;</div><div class="line">    var regLen = $0.length;</div><div class="line">    if(regLen&gt;maxLen)&#123;</div><div class="line">        maxLen = regLen;</div><div class="line">        maxStr = $1;</div><div class="line">    &#125;else if(maxLen == regLen)&#123;</div><div class="line">        maxStr += $1;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">console.log(`出现最多的字母是$&#123;maxStr&#125;,共出现了$&#123;maxLen&#125;次`);</div></pre></td></tr></table></figure></p>
<p>当我们加()只是为了提高优先级而不想捕获小分组时，可以在()中加?:来取消分组的捕获;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var str = &apos;aaabbb&apos;;</div><div class="line">var reg = /(a+)(?:b+)/;</div><div class="line">var res =reg.exec(str);</div><div class="line">console.log(res)</div><div class="line">//[&quot;aaabbb&quot;, &quot;aaa&quot;, index: 0, input: &quot;aaabbb&quot;]</div><div class="line">//只捕获第一个小分组的内容</div></pre></td></tr></table></figure>
<p><b>正则运算符的优先级</b><br>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。<br>相同优先级的会从左到右进行运算，不同优先级的运算先高后低。<br>下面是常见的运算符的优先级排列,依次从最高到最低说明各种正则表达式运算符的优先级顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">\ : 转义符</div><div class="line">(), (?:), (?=), []  =&gt; 圆括号和方括号</div><div class="line">*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;   =&gt; 量词限定符</div><div class="line">^, $, \任何元字符、任何字符 </div><div class="line">|       =&gt; 替换，&quot;或&quot;操作</div><div class="line">字符具有高于替换运算符的优先级，一般用 | 的时候，为了提高 | 的优先级，我们常用()来提高优先级</div><div class="line">如： 匹配 food或者foot的时候 reg = /foo(t|d)/ 这样来匹配</div></pre></td></tr></table></figure></p>
<p><b>正则的特性</b><br>贪婪性:<br>所谓的贪婪性就是正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。如果我们想尽可能的少的去捕获符合条件的字符串的话，可以在量词元字符后加”?”;<br>懒惰性:<br>懒惰性则是正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。如果想捕获目标中所有符合条件的字符串的话，我们可以用标识符g来标明是全局捕获;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var str = &apos;123aaa456&apos;;</div><div class="line">var reg = /\d+/;  //只捕获一次,一次尽可能多的捕获</div><div class="line">var res = str.match(reg)</div><div class="line">console.log(res)</div><div class="line">// [&quot;123&quot;, index: 0, input: &quot;123aaa456&quot;]</div><div class="line">reg = /\d+?/g; //解决贪婪性、懒惰性</div><div class="line">res = str.match(reg)</div><div class="line">console.log(res)</div><div class="line">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]</div></pre></td></tr></table></figure>
<p><b>和正则相关的一些方法</b></p>
<p>这里我们只介绍test、exec、match和replace这四个方法;<br>reg.test(str) 用来验证字符串是否符合正则 符合返回true 否则返回false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = &apos;abc&apos;;</div><div class="line">var reg = /\w+/;</div><div class="line">console.log(reg.test(str));  //true</div></pre></td></tr></table></figure></p>
<p>reg.exec() 用来捕获符合规则的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var str = &apos;abc123cba456aaa789&apos;;</div><div class="line">var reg = /\d+/;</div><div class="line">console.log(reg.exec(str))</div><div class="line">//  [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;];</div><div class="line">console.log(reg.lastIndex)</div><div class="line">// lastIndex : 0 </div><div class="line"></div><div class="line">reg.exec捕获的数组中 </div><div class="line">// [0:&quot;123&quot;,index:3,input:&quot;abc123cba456aaa789&quot;]</div><div class="line">0:&quot;123&quot; 表示我们捕获到的字符串</div><div class="line">index:3 表示捕获开始位置的索引</div><div class="line">input 表示原有的字符串</div></pre></td></tr></table></figure></p>
<p>当我们用exec进行捕获时，如果正则没有加’g’标识符，则exec捕获的每次都是同一个，当正则中有’g’标识符时 捕获的结果就不一样了,我们还是来看刚刚的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var str = &apos;abc123cba456aaa789&apos;;</div><div class="line">var reg = /\d+/g;  //此时加了标识符g</div><div class="line">console.log(reg.lastIndex)</div><div class="line">// lastIndex : 0 </div><div class="line"></div><div class="line">console.log(reg.exec(str))</div><div class="line">//  [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]</div><div class="line">console.log(reg.lastIndex)</div><div class="line">// lastIndex : 6</div><div class="line"></div><div class="line">console.log(reg.exec(str))</div><div class="line">// [&quot;456&quot;, index: 9, input: &quot;abc123cba456aaa789&quot;]</div><div class="line">console.log(reg.lastIndex)</div><div class="line">// lastIndex : 12</div><div class="line"></div><div class="line">console.log(reg.exec(str))</div><div class="line">// [&quot;789&quot;, index: 15, input: &quot;abc123cba456aaa789&quot;]</div><div class="line">console.log(reg.lastIndex)</div><div class="line">// lastIndex : 18</div><div class="line"></div><div class="line">console.log(reg.exec(str))</div><div class="line">// null</div><div class="line">console.log(reg.lastIndex)</div><div class="line">// lastIndex : 0</div></pre></td></tr></table></figure></p>
<p>每次调用exec方法时,捕获到的字符串都不相同<br>lastIndex ：这个属性记录的就是下一次捕获从哪个索引开始。<br>当未开始捕获时，这个值为0。<br>如果当前次捕获结果为null。那么lastIndex的值会被修改为0.下次从头开始捕获。<br>而且这个lastIndex属性还支持人为赋值。</p>
<p>exec的捕获还受分组()的影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var str = &apos;2017-01-05&apos;;</div><div class="line">var reg = /-(\d+)/g</div><div class="line">// [&quot;-01&quot;, &quot;01&quot;, index: 4, input: &quot;2017-01-05&quot;]</div><div class="line">&quot;-01&quot; : 正则捕获到的内容</div><div class="line">&quot;01&quot;  : 捕获到的字符串中的小分组中的内容</div></pre></td></tr></table></figure>
<p>str.match(reg) 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//match和exec的用法差不多</div><div class="line">var str = &apos;abc123cba456aaa789&apos;;</div><div class="line">var reg = /\d+/;</div><div class="line">console.log(reg.exec(str));</div><div class="line">//[&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]</div><div class="line">console.log(str.match(reg));</div><div class="line">//[&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]</div></pre></td></tr></table></figure>
<p>上边两个方法console的结果有什么不同呢？二个字符串是一样滴。<br>当我们进行全局匹配时，二者的不同就会显现出来了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var str = &apos;abc123cba456aaa789&apos;;</div><div class="line">var reg = /\d+/g;</div><div class="line">console.log(reg.exec(str));</div><div class="line">// [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]</div><div class="line">console.log(str.match(reg));</div><div class="line">// [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]</div></pre></td></tr></table></figure>
<p>当全局匹配时，match方法会一次性把符合匹配条件的字符串全部捕获到数组中,<br>如果想用exec来达到同样的效果需要执行多次exec方法。</p>
<p>我们可以尝试着用exec来简单模拟下match方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">String.prototype.myMatch = function (reg) &#123;</div><div class="line">    var arr = [];</div><div class="line">    var res = reg.exec(this);</div><div class="line">    if (reg.global) &#123;</div><div class="line">        while (res) &#123;</div><div class="line">            arr.push(res[0]);</div><div class="line">            res = reg.exec(this)</div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;</div><div class="line">        arr.push(res[0]);</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var str = &apos;abc123cba456aaa789&apos;;</div><div class="line">var reg = /\d+/;</div><div class="line">console.log(str.myMatch(reg))</div><div class="line">// [&quot;123&quot;]</div><div class="line"></div><div class="line">var str = &apos;abc123cba456aaa789&apos;;</div><div class="line">var reg = /\d+/g;</div><div class="line">console.log(str.myMatch(reg))</div><div class="line">// [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]</div></pre></td></tr></table></figure></p>
<p>此外，match和exec都可以受到分组()的影响，不过match只在没有标识符g的情况下才显示小分组的内容，如果有全局g，则match会一次性全部捕获放到数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var str = &apos;abc&apos;;</div><div class="line">var reg = /(a)(b)(c)/;</div><div class="line"></div><div class="line">console.log( str.match(reg) );</div><div class="line">// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;]</div><div class="line">console.log( reg.exec(str) );</div><div class="line">// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;]</div><div class="line"></div><div class="line">当有全局g的情况下</div><div class="line">var str = &apos;abc&apos;;</div><div class="line">var reg = /(a)(b)(c)/g;</div><div class="line">console.log( str.match(reg) );</div><div class="line">// [&quot;abc&quot;]</div><div class="line">console.log( reg.exec(str) );</div><div class="line">// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;]</div></pre></td></tr></table></figure>
<p>str.replace() 这个方法大家肯定不陌生，现在我们要说的就是和这个方法和正则相关的东西了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">正则去匹配字符串，匹配成功的字符去替换成新的字符串</div><div class="line">写法：str.replace(reg,newStr);</div><div class="line"></div><div class="line">var str = &apos;a111bc222de&apos;;</div><div class="line">var res = str.replace(/\d/g,&apos;Q&apos;)</div><div class="line">console.log(res)</div><div class="line">// &quot;aQQQbcQQQde&quot;</div><div class="line"></div><div class="line">replace的第二个参数也可以是一个函数</div><div class="line">str.replace(reg,fn);</div><div class="line"></div><div class="line">var str = &apos;2017-01-06&apos;;</div><div class="line">str = str.replace(/-\d+/g,function()&#123;</div><div class="line">    console.log(arguments)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">控制台打印结果：</div><div class="line">[&quot;-01&quot;, 4, &quot;2017-01-06&quot;]</div><div class="line">[&quot;-06&quot;, 7, &quot;2017-01-06&quot;]</div><div class="line">&quot;2017undefinedundefined&quot;</div><div class="line">从打印结果我们发现每一次输出的值似乎跟exec捕获时很相似，既然与exec似乎很相似，那么似乎也可以打印出小分组中的内容喽 </div><div class="line"></div><div class="line">var str = &apos;2017-01-06&apos;;</div><div class="line">str = str.replace(/-(\d+)/g,function()&#123;</div><div class="line">    console.log(arguments)</div><div class="line">&#125;)</div><div class="line">[&quot;-01&quot;, &quot;01&quot;, 4, &quot;2017-01-06&quot;]</div><div class="line">[&quot;-06&quot;, &quot;06&quot;, 7, &quot;2017-01-06&quot;]</div><div class="line">&quot;2017undefinedundefined&quot;</div></pre></td></tr></table></figure>
<p>从结果看来我们的猜测没问题。<br>此外，我们需要注意的是，如果我们需要替换replace中正则找到的字符串，函数中需要一个返回值去替换正则捕获的内容。</p>
<p>通过replace方法获取url中的参数的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(function(pro)&#123;</div><div class="line">    function queryString()&#123;</div><div class="line">        var obj = &#123;&#125;,</div><div class="line">            reg = /([^?&amp;#+]+)=([^?&amp;#+]+)/g;</div><div class="line">        this.replace(reg,function($0,$1,$2)&#123;</div><div class="line">            obj[$1] = $2;</div><div class="line">        &#125;)</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line">    pro.queryString = queryString;</div><div class="line">&#125;(String.prototype));</div><div class="line"></div><div class="line">// 例如 url为 https://www.baidu.com?a=1&amp;b=2</div><div class="line">// window.location.href.queryString();</div><div class="line">// &#123;a:1,b:2&#125;</div></pre></td></tr></table></figure>
<p>零宽断言</p>
<p>用于查找在某些内容(但并不包括这些内容)之前或之后的东西，如\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。</p>
<p>在使用正则表达式时，捕获的内容前后必须是特定的内容，而我们又不想捕获这些特定内容的时候，零宽断言就可以派上用场了。</p>
<p>零宽度正预测先行断言 (?=exp)<br>零宽度负预测先行断言 (?!exp)<br>零宽度正回顾后发断言 (?&lt;=exp)<br>零宽度负回顾后发断言 (?&lt;!exp)<br>这四胞胎看着名字好长，给人一种好复杂好难的感觉，我们还是挨个来看看它们究竟是干什么的吧。</p>
<p>(?=exp) 这个简单理解就是说字符出现的位置的右边必须匹配到exp这个表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var str = &quot;i&apos;m singing and dancing&quot;;</div><div class="line">var reg = /\b(\w+(?=ing\b))/g</div><div class="line">var res = str.match(reg);</div><div class="line">console.log(res)</div><div class="line">// [&quot;sing&quot;, &quot;danc&quot;]</div><div class="line"></div><div class="line"></div><div class="line">注意一点，这里说到的是位置，不是字符。</div><div class="line">var str = &apos;abc&apos;;</div><div class="line">var reg = /a(?=b)c/;</div><div class="line">console.log(res.test(str));  // false</div></pre></td></tr></table></figure>
<p>这个看起来似乎是正确的，实际上结果是false<br>reg中a(?=b)匹配字符串’abc’ 字符串a的右边是b这个匹配没问题,接下来reg中a(?=b)后边的c匹配字符串时是从字符串’abc’中a的后边b的前边的这个位置开始匹配的，<br>这个相当于/ac/匹配’abc’,显然结果是false了;</p>
<p>(?!exp) 这个就是说字符出现的位置的右边不能是exp这个表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = &apos;nodejs&apos;;</div><div class="line">var reg = /node(?!js)/;</div><div class="line">console.log(reg.test(str)) // false</div></pre></td></tr></table></figure>
<p>(?&lt;=exp) 这个就是说字符出现的位置的前边是exp这个表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = &apos;￥998$888&apos;;</div><div class="line">var reg = /(?&lt;=\$)\d+/;</div><div class="line">console.log(reg.exec(str)) //888</div></pre></td></tr></table></figure>
<p>(?&lt;!exp) 这个就是说字符出现的位置的前边不能是exp这个表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = &apos;￥998$888&apos;;</div><div class="line">var reg = /(?&lt;!\$)\d+/;</div><div class="line">console.log(reg.exec(str)) //998</div></pre></td></tr></table></figure>
<p>###（感谢）转载自：<a href="http://www.cnblogs.com/chenmeng0818/p/6370819.html" target="_blank" rel="external">http://www.cnblogs.com/chenmeng0818/p/6370819.html</a></p>
<blockquote>
<p></p><p>访客的ip和所在地址：<b id="vositor" style="color:red"></b>  访问时间: <b id="vositortimes" style="color:red"></b> 当前时间: <b id="vositortime" style="color:red"></b></p><p></p>
<script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">
     var add = document.getElementById('vositor').innerHTML=returnCitySN['cip'] + ' , ' + returnCitySN['cname']; 
      function sTime(){ 
      var d = new Date(); 
      var s = d.getHours();
      var m = d.getMinutes();
      var se = d.getSeconds();
      if(s<10){
         s="0"+s; 
      }else if(m<10){
          m="0"+m; 
      }else if(se<10){
          se="0"+se; 
      }
      var tt = s +":"+ m +":"+ se; 
      document.getElementById("vositortime").innerText = tt;
      return tt; 
      } 
      var showTime = setInterval(sTime,1000);   
      function getDate(){
          var ts = sTime();
          document.getElementById("vositortimes").innerText = ts;
      }
      getDate();
</script></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个字符串是否含有某种子串、将匹配的子串做替换或者从某个字符串中取出符合某个条件的子串等。&lt;br&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://sky-xsk.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
</feed>
